<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vector3D · MicroscopePSFs.jl</title><meta name="title" content="Vector3D · MicroscopePSFs.jl"/><meta property="og:title" content="Vector3D · MicroscopePSFs.jl"/><meta property="twitter:title" content="Vector3D · MicroscopePSFs.jl"/><meta name="description" content="Documentation for MicroscopePSFs.jl."/><meta property="og:description" content="Documentation for MicroscopePSFs.jl."/><meta property="twitter:description" content="Documentation for MicroscopePSFs.jl."/><meta property="og:url" content="https://JuliaSMLM.github.io/MicroscopePSFs.jl/psfs/vector3d/"/><meta property="twitter:url" content="https://JuliaSMLM.github.io/MicroscopePSFs.jl/psfs/vector3d/"/><link rel="canonical" href="https://JuliaSMLM.github.io/MicroscopePSFs.jl/psfs/vector3d/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MicroscopePSFs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">PSF Types</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../gaussian2d/">Gaussian2D</a></li><li><a class="tocitem" href="../airy2d/">Airy2D</a></li><li><a class="tocitem" href="../scalar3d/">Scalar3D</a></li><li class="is-active"><a class="tocitem" href>Vector3D</a><ul class="internal"><li><a class="tocitem" href="#Mathematical-Model"><span>Mathematical Model</span></a></li><li><a class="tocitem" href="#Constructor-Options"><span>Constructor Options</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Integration-with-Camera"><span>Integration with Camera</span></a></li><li><a class="tocitem" href="#Aberration-Modeling"><span>Aberration Modeling</span></a></li><li><a class="tocitem" href="#Dipole-Orientations-and-Polarization"><span>Dipole Orientations and Polarization</span></a></li><li><a class="tocitem" href="#Refractive-Index-Interfaces"><span>Refractive Index Interfaces</span></a></li><li><a class="tocitem" href="#Supercritical-Angle-Fluorescence"><span>Supercritical Angle Fluorescence</span></a></li><li><a class="tocitem" href="#Performance-Considerations"><span>Performance Considerations</span></a></li><li><a class="tocitem" href="#Relationship-to-Other-PSFs"><span>Relationship to Other PSFs</span></a></li><li><a class="tocitem" href="#When-to-Use-Vector3DPSF"><span>When to Use Vector3DPSF</span></a></li></ul></li><li><a class="tocitem" href="../spline_psf/">Spline PSF</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">PSF Types</a></li><li class="is-active"><a href>Vector3D</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vector3D</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/main/docs/src/psfs/vector3d.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Vector3DPSF"><a class="docs-heading-anchor" href="#Vector3DPSF">Vector3DPSF</a><a id="Vector3DPSF-1"></a><a class="docs-heading-anchor-permalink" href="#Vector3DPSF" title="Permalink"></a></h1><p>The <code>Vector3DPSF</code> model implements a comprehensive three-dimensional point spread function based on vectorial diffraction theory. It accounts for polarization effects, high-NA phenomena, dipole emission patterns, and arbitrary aberrations, providing the highest level of physical accuracy among the PSF models. This model is particularly important for high-NA objectives and applications where polarization effects cannot be ignored.</p><h2 id="Mathematical-Model"><a class="docs-heading-anchor" href="#Mathematical-Model">Mathematical Model</a><a id="Mathematical-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Model" title="Permalink"></a></h2><p>The Vector3DPSF implements a full vectorial diffraction model based on the Richards-Wolf vector diffraction theory, accounting for dipole emission patterns, polarization effects, refractive index interfaces, and optical aberrations.</p><h3 id="Complete-PSF-Formula"><a class="docs-heading-anchor" href="#Complete-PSF-Formula">Complete PSF Formula</a><a id="Complete-PSF-Formula-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-PSF-Formula" title="Permalink"></a></h3><p class="math-container">\[PSF(x - x_i, y - y_i, z_i, z_s) = \sum_{m=x,y} \sum_{n=p_x, p_y, p_z} |F[h(k_x, k_y)w_{m,n}A(k_x, k_y)e^{\iota 2\pi(k_x x_i+k_y y_i+k_{z\mathrm{med}} z_i-k_{z\mathrm{imm}}z_s)}]|^2\]</p><p>Where:</p><ul><li><span>$(x_i, y_i, z_i)$</span> is the emitter position where <span>$z_i$</span> represents the depth above the coverslip</li><li><span>$z_s$</span> is the distance the sample stage was moved away from the nominal focal plane at the coverslip </li><li><span>$F$</span> denotes the Fourier transform operation </li><li><span>$h(k_x, k_y)$</span> is the complex pupil function incorporating aberrations </li><li><span>$w_{m,n}$</span> represents the electric field components at the pupil plane from a fixed dipole and incorporates Fresnel coefficients </li><li><span>$A(k_x, k_y)$</span> is the apodization factor for energy conservation </li><li><span>$k_{z\mathrm{med}}$</span> and <span>$k_{z\mathrm{imm}}$</span> are the z-components of the wave vectors in the sample and immersion media respectively </li></ul><h3 id="Electric-Field-Components"><a class="docs-heading-anchor" href="#Electric-Field-Components">Electric Field Components</a><a id="Electric-Field-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-Field-Components" title="Permalink"></a></h3><p>The vectorial field components <span>$w_{m,n}$</span> at the pupil plane are calculated as:</p><p class="math-container">\[w_{x,n} = P_n \cos(\phi) - S_n \sin(\phi)\]</p><p class="math-container">\[w_{y,n} = P_n \sin(\phi) + S_n \cos(\phi)\]</p><p>Where <span>$\phi$</span> is the angular component in the polar coordinate of the frequency space, and <span>$P_n$</span> and <span>$S_n$</span> are electric field components in <span>$p$</span> and <span>$s$</span> polarizations relative to the incident plane at the sample space:</p><p class="math-container">\[\begin{align}
P_{px} &amp;= T_p \cos \theta_1 \cos \phi \\
P_{py} &amp;= T_p \cos \theta_1 \sin \phi \\
P_{pz} &amp;= -T_p \sin \theta_1 \\
S_{px} &amp;= -T_s \sin \phi \\
S_{py} &amp;= T_s \cos \phi \\
S_{pz} &amp;= 0
\end{align}\]</p><p>Where <span>$P_x$</span>, <span>$P_y$</span>, <span>$P_z$</span> are the cartesian components of the dipole moments.</p><h3 id="Fresnel-Coefficients"><a class="docs-heading-anchor" href="#Fresnel-Coefficients">Fresnel Coefficients</a><a id="Fresnel-Coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Fresnel-Coefficients" title="Permalink"></a></h3><p>The total transmission coefficients <span>$T_p$</span> and <span>$T_s$</span> for p- and s-polarized light account for the interfaces between different media (sample, coverslip, and immersion medium):</p><p class="math-container">\[\begin{align}
T_P &amp;= \tau_{P12} \tau_{P23} \\
T_S &amp;= \tau_{S12} \tau_{S23}
\end{align}\]</p><p>With interface-specific Fresnel transmission coefficients:</p><p class="math-container">\[\begin{align}
\tau_{Pij} &amp;= \frac{2n_i\cos\theta_i}{n_i\cos\theta_j + n_j\cos\theta_i} \\
\tau_{Sij} &amp;= \frac{2n_i\cos\theta_i}{n_i\cos\theta_i + n_j\cos\theta_j}
\end{align}\]</p><p>Where <span>$n_i$</span> and <span>$\theta_i$</span> are the refractive index and the light propagation angle in medium <span>$i$</span>, and the subscriptions 1, 2, 3 denote the sample medium, the coverslip, and the immersion medium.</p><h3 id="Apodization-Factor"><a class="docs-heading-anchor" href="#Apodization-Factor">Apodization Factor</a><a id="Apodization-Factor-1"></a><a class="docs-heading-anchor-permalink" href="#Apodization-Factor" title="Permalink"></a></h3><p>The apodization factor <span>$A(k_x, k_y)$</span> maintains energy conservation across media interfaces:</p><p class="math-container">\[A(k_x, k_y) = \frac{\sqrt{\cos\theta_{\mathrm{imm}}}}{\cos\theta_{\mathrm{med}}}\]</p><p>Where:</p><p class="math-container">\[\cos\theta_{\mathrm{med}} = \sqrt{1 - \frac{(k_x^2 + k_y^2)\lambda^2}{4\pi^2 n_{\mathrm{med}}^2}}\]</p><p class="math-container">\[\cos\theta_{\mathrm{imm}} = \sqrt{1 - \frac{(k_x^2 + k_y^2)\lambda^2}{4\pi^2 n_{\mathrm{imm}}^2}}\]</p><p>This factor accounts for the change in solid angle that occurs during refraction, critical for accurately modeling high-NA systems.</p><h3 id="Wave-Vectors"><a class="docs-heading-anchor" href="#Wave-Vectors">Wave Vectors</a><a id="Wave-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Wave-Vectors" title="Permalink"></a></h3><p>The z-components of the wave vectors in the different media are:</p><p class="math-container">\[k_{z\mathrm{med}} = \sqrt{\frac{n^2_{\mathrm{med}}}{\lambda^2} - \frac{n^2_{\mathrm{imm}}}{\lambda^2}\sin^2 \theta_{\mathrm{imm}}}\]</p><p class="math-container">\[k_{z\mathrm{imm}} = \frac{n_{\mathrm{imm}}}{\lambda}\cos \theta_{\mathrm{imm}}\]</p><p>When <span>$\theta_{\mathrm{imm}}$</span> exceeds the critical angle, <span>$k_{z\mathrm{med}}$</span> becomes imaginary, resulting in evanescent waves and giving rise to supercritical angle fluorescence (SAF) effects.</p><h2 id="Constructor-Options"><a class="docs-heading-anchor" href="#Constructor-Options">Constructor Options</a><a id="Constructor-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-Options" title="Permalink"></a></h2><pre><code class="language-julia hljs">Vector3DPSF(nₐ::Real, λ::Real, dipole::DipoleVector;
            base_pupil::Union{Nothing, PupilFunction}=nothing,
            base_zernike::Union{Nothing, ZernikeCoefficients}=nothing,
            n_medium::Real=1.33,
            n_coverslip::Real=1.52,
            n_immersion::Real=1.52,
            z_stage::Real=0.0, 
            grid_size::Integer=128)</code></pre><h3 id="Required-Parameters"><a class="docs-heading-anchor" href="#Required-Parameters">Required Parameters</a><a id="Required-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Required-Parameters" title="Permalink"></a></h3><ul><li><code>nₐ</code>: Numerical aperture of the objective</li><li><code>wavelength</code>: Wavelength of light in microns</li><li><code>dipole</code>: Dipole orientation vector specified using <code>DipoleVector</code></li></ul><h3 id="Optional-Parameters"><a class="docs-heading-anchor" href="#Optional-Parameters">Optional Parameters</a><a id="Optional-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Parameters" title="Permalink"></a></h3><ul><li><code>base_pupil</code>: Optional base aberration pupil function (default: none)</li><li><code>base_zernike</code>: Zernike coefficients for aberrations (default: none)</li><li><code>n_medium</code>: Refractive index of the sample medium (default: 1.33, water)</li><li><code>n_immersion</code>: Refractive index of the immersion medium (default: 1.52, oil)</li><li><code>n_coverslip</code>: Refractive index of the coverslip (default: 1.52, glass)</li><li><code>z_stage</code>: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm) (default: 0.0)</li><li><code>grid_size</code>: Size of grid for pupil function (default: 128)</li></ul><h3 id="Type-Parameters"><a class="docs-heading-anchor" href="#Type-Parameters">Type Parameters</a><a id="Type-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Parameters" title="Permalink"></a></h3><ul><li><code>T</code>: Numeric precision type, automatically determined from input</li></ul><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><h3 id="Creating-a-PSF"><a class="docs-heading-anchor" href="#Creating-a-PSF">Creating a PSF</a><a id="Creating-a-PSF-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-PSF" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create dipole vectors for different orientations
dipole_x = DipoleVector(1.0, 0.0, 0.0)  # X-oriented dipole
dipole_y = DipoleVector(0.0, 1.0, 0.0)  # Y-oriented dipole
dipole_z = DipoleVector(0.0, 0.0, 1.0)  # Z-oriented dipole
dipole_xy = DipoleVector(0.707, 0.707, 0.0)  # 45° in XY plane

# Create a basic Vector3DPSF with Z-oriented dipole
psf = Vector3DPSF(
    1.4,                # Numerical aperture
    0.532,              # Wavelength in microns
    dipole_z,           # Z-oriented dipole
    n_medium=1.33,      # Sample is water
    n_immersion=1.52   # Immersion oil
)

# Create a PSF with aberrations
zc = ZernikeCoefficients(15)
add_spherical!(zc, 0.5)  # Add 0.5 waves of spherical aberration
psf_aberrated = Vector3DPSF(
    1.4,
    0.532,
    dipole_z,
    n_medium=1.33,
    base_zernike=zc
)</code></pre><h3 id="Direct-Evaluation"><a class="docs-heading-anchor" href="#Direct-Evaluation">Direct Evaluation</a><a id="Direct-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Evaluation" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Evaluate PSF at a specific 3D position
x = 0.1  # μm
y = 0.2  # μm
z = 0.5  # μm (depth above the coverslip)
intensity = psf(x, y, z)

# Get complex vector field amplitude (returns [Ex, Ey])
E_field = amplitude(psf, x, y, z)
Ex = E_field[1]  # X-component of electric field
Ey = E_field[2]  # Y-component of electric field

# Calculate intensity manually if needed
intensity_manual = abs2(Ex) + abs2(Ey)</code></pre><h3 id="Creating-PSF-Images"><a class="docs-heading-anchor" href="#Creating-PSF-Images">Creating PSF Images</a><a id="Creating-PSF-Images-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-PSF-Images" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create a grid of positions for a 2D slice at a specific z
x = range(-1, 1, length=101)  # μm
y = range(-1, 1, length=101)  # μm
z = 0.0  # focal plane

# Compute PSF values at each position
intensity_2d = [psf(xi, yi, z) for yi in y, xi in x]

# Visualize with CairoMakie
using CairoMakie
fig = Figure(size=(600, 500))
ax = Axis(fig[1, 1], aspect=DataAspect(),
          title=&quot;Vector3DPSF (z=0μm, z-oriented dipole)&quot;,
          xlabel=&quot;x (μm)&quot;, ylabel=&quot;y (μm)&quot;)
hm = heatmap!(ax, x, y, intensity_2d, colormap=:viridis)
Colorbar(fig[1, 2], hm)

# Compare different dipole orientations
psf_x = Vector3DPSF(1.4, 0.532, dipole_x, n_medium=1.33)
psf_y = Vector3DPSF(1.4, 0.532, dipole_y, n_medium=1.33)
psf_z = Vector3DPSF(1.4, 0.532, dipole_z, n_medium=1.33)

fig2 = Figure(size=(900, 300))
psfs = [psf_x, psf_y, psf_z]
titles = [&quot;X-oriented dipole&quot;, &quot;Y-oriented dipole&quot;, &quot;Z-oriented dipole&quot;]

for (i, (p, title)) in enumerate(zip(psfs, titles))
    ax = Axis(fig2[1, i], aspect=DataAspect(),
              title=title,
              xlabel=&quot;x (μm)&quot;, ylabel=i==1 ? &quot;y (μm)&quot; : &quot;&quot;)
    img = [p(xi, yi, 0.0) for yi in y, xi in x]
    heatmap!(ax, x, y, img, colormap=:viridis)
end
fig2</code></pre><h2 id="Integration-with-Camera"><a class="docs-heading-anchor" href="#Integration-with-Camera">Integration with Camera</a><a id="Integration-with-Camera-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Camera" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Create camera with 100nm pixels (20×20 pixel grid)
pixel_size = 0.1  # μm
camera = IdealCamera(1:20, 1:20, pixel_size)

# Create 3D emitter at position (1μm, 1μm, 0.5μm) with 1000 photons
# Note: z=0.5μm represents the depth above the coverslip
emitter = Emitter3D(1.0, 1.0, 0.5, 1000.0)  # x, y, z (depth above coverslip), photons

# Integrate PSF over pixels with 2×2 subsampling
pixels = integrate_pixels(psf, camera, emitter, sampling=2)

# For dipole emitters, you can use the DipoleEmitter3D type
dipole_emitter = DipoleEmitter3D(1.0, 1.0, 0.5, 1000.0, 0.0, 0.0, 1.0)  # x, y, z (depth above coverslip), photons, dx, dy, dz

# Visualize the camera image
using CairoMakie
fig = Figure(size=(500, 400))
ax = Axis(fig[1, 1], aspect=DataAspect(),
          title=&quot;Integrated Camera Image (z=0.5μm)&quot;,
          xlabel=&quot;x (μm)&quot;, ylabel=&quot;y (μm)&quot;)
ax.yreversed = true  # Flip y-axis to match camera convention

# Get physical coordinates of pixel centers
x_centers = (1:20) * pixel_size - pixel_size/2
y_centers = (1:20) * pixel_size - pixel_size/2

hm = heatmap!(ax, x_centers, y_centers, pixels&#39;, colormap=:viridis)
scatter!(ax, [emitter.x], [emitter.y], color=:red, marker=:cross, markersize=15)
Colorbar(fig[1, 2], hm)
fig</code></pre><h2 id="Aberration-Modeling"><a class="docs-heading-anchor" href="#Aberration-Modeling">Aberration Modeling</a><a id="Aberration-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Aberration-Modeling" title="Permalink"></a></h2><p>The Vector3DPSF supports the same aberration modeling capabilities as Scalar3DPSF:</p><pre><code class="language-julia hljs"># Create Zernike coefficients object with up to 21 terms
zc = ZernikeCoefficients(21)

# Add common aberrations
add_defocus!(zc, 1.0)           # 1 wave of defocus
add_astigmatism!(zc, 0.5, π/4)  # 0.5 waves of astigmatism at 45°
add_coma!(zc, 0.3)              # 0.3 waves of coma
add_spherical!(zc, 0.2)         # 0.2 waves of spherical aberration

# Create PSF with these aberrations
psf = Vector3DPSF(1.4, 0.532, dipole_z, n_medium=1.33, base_zernike=zc)

# Update aberrations for an existing PSF
add_spherical!(psf.zernike_coeffs, 0.3)  # Add more spherical aberration
update_pupils!(psf)  # Update the pupil function to reflect the changes</code></pre><h2 id="Dipole-Orientations-and-Polarization"><a class="docs-heading-anchor" href="#Dipole-Orientations-and-Polarization">Dipole Orientations and Polarization</a><a id="Dipole-Orientations-and-Polarization-1"></a><a class="docs-heading-anchor-permalink" href="#Dipole-Orientations-and-Polarization" title="Permalink"></a></h2><p>The Vector3DPSF model allows for simulating different dipole orientations, which is crucial for applications like single-molecule orientation studies:</p><pre><code class="language-julia hljs"># Create PSFs for different dipole orientations
orientations = [
    (&quot;X-oriented&quot;, DipoleVector(1.0, 0.0, 0.0)),
    (&quot;Y-oriented&quot;, DipoleVector(0.0, 1.0, 0.0)),
    (&quot;Z-oriented&quot;, DipoleVector(0.0, 0.0, 1.0)),
    (&quot;XY-plane 45°&quot;, DipoleVector(0.707, 0.707, 0.0)),
    (&quot;3D 45°&quot;, DipoleVector(0.577, 0.577, 0.577))
]

# Compare how different orientations appear at different z positions
z_positions = [-1.0, 0.0, 1.0]  # μm
x = y = range(-1, 1, length=51)  # μm

fig = Figure(size=(1200, 800))

for (i, (name, dipole)) in enumerate(orientations)
    psf = Vector3DPSF(1.4, 0.532, dipole, n_medium=1.33)
    
    for (j, z) in enumerate(z_positions)
        ax = Axis(fig[i, j], aspect=DataAspect(),
                 title=j==1 ? name : &quot;z = $(z)μm&quot;,
                 xlabel=i==length(orientations) ? &quot;x (μm)&quot; : &quot;&quot;,
                 ylabel=j==1 ? &quot;y (μm)&quot; : &quot;&quot;)
                 
        img = [psf(xi, yi, z) for yi in y, xi in x]
        heatmap!(ax, x, y, img, colormap=:viridis)
    end
end

fig</code></pre><h2 id="Refractive-Index-Interfaces"><a class="docs-heading-anchor" href="#Refractive-Index-Interfaces">Refractive Index Interfaces</a><a id="Refractive-Index-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Refractive-Index-Interfaces" title="Permalink"></a></h2><p>The Vector3DPSF model accounts for refractive index mismatches at the interfaces:</p><pre><code class="language-julia hljs"># Compare different refractive index configurations
configs = [
    (&quot;Matched (water)&quot;, 1.33, 1.33, 1.33),     # All water
    (&quot;Oil immersion&quot;, 1.33, 1.52, 1.52),    # Water sample, oil immersion
    (&quot;Glycerol immersion&quot;, 1.33, 1.47, 1.47)  # Water sample, glycerol immersion
]

fig = Figure(size=(900, 300))

for (i, (name, n_medium, n_coverslip, n_immersion)) in enumerate(configs)
    psf = Vector3DPSF(
        1.4, 0.532, dipole_z,
        n_medium=n_medium,
        n_coverslip=n_coverslip,
        n_immersion=n_immersion
    )
    
    ax = Axis(fig[1, i], aspect=DataAspect(),
              title=name,
              xlabel=&quot;x (μm)&quot;, ylabel=i==1 ? &quot;y (μm)&quot; : &quot;&quot;)
              
    img = [psf(xi, yi, 0.0) for yi in y, xi in x]
    heatmap!(ax, x, y, img, colormap=:viridis)
end

fig</code></pre><h2 id="Supercritical-Angle-Fluorescence"><a class="docs-heading-anchor" href="#Supercritical-Angle-Fluorescence">Supercritical Angle Fluorescence</a><a id="Supercritical-Angle-Fluorescence-1"></a><a class="docs-heading-anchor-permalink" href="#Supercritical-Angle-Fluorescence" title="Permalink"></a></h2><p>A notable feature of the Vector3DPSF model is its ability to accurately capture Supercritical Angle Fluorescence (SAF), which occurs when light emitted by fluorophores near the coverslip is collected at angles exceeding the critical angle:</p><pre><code class="language-julia hljs"># Compare SAF effect at different depths above the coverslip
z_positions = [0.0, 0.1, 0.3, 0.5, 1.0]  # μm above coverslip
x = y = range(-1, 1, length=51)  # μm

fig = Figure(size=(1200, 300))

# Create PSF with oil immersion (favorable for SAF)
psf = Vector3DPSF(
    1.4, 0.532, dipole_z,
    n_medium=1.33,   # Water
    n_immersion=1.52  # Oil
)

for (i, z) in enumerate(z_positions)
    ax = Axis(fig[1, i], aspect=DataAspect(),
             title=&quot;z = $(z)μm above coverslip&quot;,
             xlabel=&quot;x (μm)&quot;, 
             ylabel=i==1 ? &quot;y (μm)&quot; : &quot;&quot;)
             
    # Evaluate PSF with emitter at specific depth above coverslip
    img = [psf(xi, yi, z) for yi in y, xi in x]
    hm = heatmap!(ax, x, y, img, colormap=:viridis)
    
    # Add radial profile
    r = range(0, 1, length=50)
    intensity = [psf(ri, 0.0, z) for ri in r]
    lines!(ax, r, intensity .* 1.5, color=:red, linewidth=2)
end

fig</code></pre><p>As the emitter moves away from the coverslip, you&#39;ll observe the SAF contribution decreasing, which appears as a change in both the total intensity and the shape of the PSF.</p><h2 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h2><p>The Vector3DPSF is the most computationally intensive model in MicroscopePSFs.jl:</p><ul><li>Significantly slower than all other PSF models</li><li>Performance scales with the resolution of the pupil function (grid_size parameter)</li><li>Calculating the vector pupils is computationally intensive but only needs to be done once</li><li>For performance-critical applications, consider creating a <code>SplinePSF</code> from a Vector3DPSF:</li></ul><pre><code class="language-julia hljs"># Create a SplinePSF for faster repeated evaluations
x_range = range(-2, 2, length=81)  # μm
y_range = range(-2, 2, length=81)  # μm
z_range = range(-2, 2, length=41)  # μm

# This step is slow but only needs to be done once
spline_psf = SplinePSF(psf, x_range, y_range, z_range)

# Now evaluations are much faster
intensity = spline_psf(0.1, 0.2, 0.3)</code></pre><h2 id="Relationship-to-Other-PSFs"><a class="docs-heading-anchor" href="#Relationship-to-Other-PSFs">Relationship to Other PSFs</a><a id="Relationship-to-Other-PSFs-1"></a><a class="docs-heading-anchor-permalink" href="#Relationship-to-Other-PSFs" title="Permalink"></a></h2><p>The Vector3DPSF is related to other PSF models in the following ways:</p><ol><li><strong>Scalar3DPSF</strong>: Vector3DPSF reduces to Scalar3DPSF when polarization effects are negligible (low NA)</li><li><strong>Airy2D</strong>: For z=0 and low NA, the Vector3DPSF approaches the Airy pattern</li><li><strong>SplinePSF</strong>: For performance-critical applications, create a SplinePSF from a Vector3DPSF</li></ol><h2 id="When-to-Use-Vector3DPSF"><a class="docs-heading-anchor" href="#When-to-Use-Vector3DPSF">When to Use Vector3DPSF</a><a id="When-to-Use-Vector3DPSF-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Vector3DPSF" title="Permalink"></a></h2><p>The Vector3DPSF model is recommended for:</p><ol><li>High-NA objectives (NA &gt; 1.2)</li><li>Polarization-sensitive applications</li><li>Applications requiring dipole emission pattern modeling</li><li>Systems with significant refractive index mismatches</li><li>Research requiring the highest level of physical accuracy</li><li>Studies involving near-interface fluorescence effects like SAF</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scalar3d/">« Scalar3D</a><a class="docs-footer-nextpage" href="../spline_psf/">Spline PSF »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 14 March 2025 20:19">Friday 14 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
