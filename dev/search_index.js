var documenterSearchIndex = {"docs":
[{"location":"psfs/airy2d/#Airy2D","page":"Airy2D","title":"Airy2D","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy2D PSF model represents the diffraction-limited point spread function for a circular aperture under the paraxial approximation. Unlike the simpler Gaussian approximation, this model accurately captures the characteristic diffraction rings that appear in real microscope images, making it more physically accurate while still maintaining good computational efficiency.","category":"page"},{"location":"psfs/airy2d/#Mathematical-Model","page":"Airy2D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy pattern is defined in terms of its field amplitude:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"A(r) = fracnusqrt4pi cdot frac2J_1(nu r)nu r","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"where:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"r = sqrtx^2 + y^2 is the radial distance from the optical axis in microns\nnu = frac2pi cdot textNAlambda is the optical parameter\nJ_1 is the Bessel function of the first kind, order 1\ntextNA is the numerical aperture\nlambda is the wavelength in microns","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The intensity is given by the squared magnitude of the amplitude:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"I(r) = A(r)^2","category":"page"},{"location":"psfs/airy2d/#Constructor-Options","page":"Airy2D","title":"Constructor Options","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Airy2D(na::Real, wavelength::Real)","category":"page"},{"location":"psfs/airy2d/#Parameters","page":"Airy2D","title":"Parameters","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in microns","category":"page"},{"location":"psfs/airy2d/#Alternative-Constructor","page":"Airy2D","title":"Alternative Constructor","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Airy2D(psf::Gaussian2D; λ::Real=0.532)","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Creates an Airy2D PSF that approximates the provided Gaussian2D PSF, using the specified wavelength.","category":"page"},{"location":"psfs/airy2d/#Type-Parameters","page":"Airy2D","title":"Type Parameters","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"T: Numeric precision type, automatically determined from input","category":"page"},{"location":"psfs/airy2d/#Basic-Usage","page":"Airy2D","title":"Basic Usage","text":"","category":"section"},{"location":"psfs/airy2d/#Creating-a-PSF","page":"Airy2D","title":"Creating a PSF","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"# Create an Airy PSF for a high-NA objective with green light\npsf = Airy2D(1.4, 0.532)  # NA=1.4, wavelength=532nm\n\n# Create from a Gaussian2D PSF (for comparison purposes)\ngaussian_psf = Gaussian2D(0.15)\nairy_equivalent = Airy2D(gaussian_psf, λ=0.532)","category":"page"},{"location":"psfs/airy2d/#Direct-Evaluation","page":"Airy2D","title":"Direct Evaluation","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"# Evaluate PSF at a specific position\nintensity = psf(0.1, 0.2)  # At position x=0.1μm, y=0.2μm\n\n# Get complex amplitude\namp = amplitude(psf, 0.1, 0.2)","category":"page"},{"location":"psfs/airy2d/#Creating-a-PSF-Image","page":"Airy2D","title":"Creating a PSF Image","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"# Create a grid of positions\nx = range(-2, 2, length=201)  # μm\ny = range(-2, 2, length=201)  # μm\n\n# Compute PSF values on the grid\nintensity_values = [psf(xi, yi) for yi in y, xi in x]\n\n# Visualize with CairoMakie\nusing CairoMakie\nfig = Figure(size=(600, 500))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Airy PSF (NA=1.4, λ=532nm)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nhm = heatmap!(ax, x, y, intensity_values, colormap=:viridis)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/airy2d/#Integration-with-Camera","page":"Airy2D","title":"Integration with Camera","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"# Create camera with 100nm pixels (20×20 pixel grid)\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:20, 1:20, pixel_size)\n\n# Create emitter at position (1μm, 1μm) with 1000 photons\nemitter = Emitter2D(1.0, 1.0, 1000.0)\n\n# Integrate PSF over pixels with 2×2 subsampling\npixels = integrate_pixels(psf, camera, emitter, sampling=2)\n\n# Visualize the camera image\nusing CairoMakie\nfig = Figure(size=(500, 400))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Integrated Camera Image\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nax.yreversed = true  # Flip y-axis to match camera convention\n\n# Get physical coordinates of pixel centers\nx_centers = (1:20) * pixel_size .- pixel_size/2\ny_centers = (1:20) * pixel_size .- pixel_size/2\n\nhm = heatmap!(ax, x_centers, y_centers, pixels', colormap=:viridis)\nscatter!(ax, [emitter.x], [emitter.y], color=:red, marker=:cross, markersize=15)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/airy2d/#Properties-of-the-Airy-Pattern","page":"Airy2D","title":"Properties of the Airy Pattern","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy pattern has several notable features that distinguish it from the Gaussian approximation:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Central Maximum: Contains 83.8% of the total intensity\nFirst Minimum: Occurs at a radius of 1.22λ/NA (the Rayleigh criterion)\nFirst Ring: Contains 7.2% of the total intensity\nSubsequent Rings: Contain decreasing fractions of the intensity\nInfinite Extent: Unlike the Gaussian, which asymptotically approaches zero, the Airy pattern extends to infinity with alternating rings","category":"page"},{"location":"psfs/airy2d/#Performance-Considerations","page":"Airy2D","title":"Performance Considerations","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy2D PSF offers a good balance between physical accuracy and computational efficiency:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"More computationally intensive than Gaussian2D due to Bessel function evaluations\nMuch faster than 3D models like Scalar3DPSF and Vector3DPSF\nHandles the special case at r=0 efficiently by using a series expansion\nWell-suited for applications where diffraction rings are important but 3D effects are not","category":"page"},{"location":"psfs/airy2d/#Limitations","page":"Airy2D","title":"Limitations","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy2D model has several limitations:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"2D Only: Only valid for in-focus imaging (no defocus modeling)\nParaxial Approximation: Less accurate for very high-NA objectives (> 1.4)\nNo Aberrations: Doesn't account for optical aberrations\nNo Polarization: Doesn't model polarization effects\nNo Refractive Index Mismatches: Assumes uniform media","category":"page"},{"location":"psfs/airy2d/#Relationship-to-Other-PSFs","page":"Airy2D","title":"Relationship to Other PSFs","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy2D pattern is related to other PSF models in the following ways:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Gaussian2D: The Airy pattern can be approximated by a Gaussian with σ ≈ 0.22λ/NA\nScalar3DPSF: The Airy2D pattern is the in-focus (z=0) slice of the Scalar3DPSF with no aberrations\nVector3DPSF: For low-NA objectives, the in-focus Vector3DPSF approaches the Airy pattern","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"For applications requiring 3D imaging or higher physical accuracy, consider using Scalar3DPSF or Vector3DPSF models instead.","category":"page"},{"location":"psfs/spline_psf/#SplinePSF","page":"Spline PSF","title":"SplinePSF","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The SplinePSF model provides an efficient representation of point spread functions using B-spline interpolation. Unlike other PSF models that are based on physical principles, SplinePSF is a computational acceleration technique that can significantly speed up PSF evaluations for complex models like Vector3DPSF or Scalar3DPSF. It can also be used to represent experimentally measured PSFs from calibration data.","category":"page"},{"location":"psfs/spline_psf/#Mathematical-Model","page":"Spline PSF","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The SplinePSF uses B-spline interpolation to rapidly evaluate a pre-computed PSF grid:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"I(x y z) = sum_ijk c_ijk beta^n(x - x_i) beta^n(y - y_j) beta^n(z - z_k)","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"where:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"c_ijk are the B-spline coefficients\nbeta^n is the B-spline basis function of order n (typically cubic, n=3)\nx_i y_j z_k are the knot points of the spline","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"This representation allows for:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Continuous representation with smooth derivatives\nFast evaluation through efficient lookup and computation\nAccurate interpolation between sampled grid points","category":"page"},{"location":"psfs/spline_psf/#Constructor-Options","page":"Spline PSF","title":"Constructor Options","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"SplinePSF offers several constructor methods for different use cases:","category":"page"},{"location":"psfs/spline_psf/#From-Another-PSF-Model-(Most-Common)","page":"Spline PSF","title":"From Another PSF Model (Most Common)","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# 3D PSF\nSplinePSF(psf::AbstractPSF, \n          x_range::AbstractRange,\n          y_range::AbstractRange,\n          z_range::AbstractRange;\n          order::Integer=3)\n\n# 2D PSF\nSplinePSF(psf::AbstractPSF, \n          x_range::AbstractRange,\n          y_range::AbstractRange;\n          order::Integer=3)","category":"page"},{"location":"psfs/spline_psf/#From-Pre-computed-PSF-Data","page":"Spline PSF","title":"From Pre-computed PSF Data","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# From 3D PSF stack\nSplinePSF(psf_stack::AbstractArray{<:Real,3}, \n          x_range::AbstractRange,\n          y_range::AbstractRange,\n          z_range::AbstractRange;\n          order::Integer=3)\n\n# From 2D PSF image\nSplinePSF(psf_image::AbstractArray{<:Real,2}, \n          x_range::AbstractRange,\n          y_range::AbstractRange;\n          order::Integer=3)","category":"page"},{"location":"psfs/spline_psf/#Convenience-Constructor-with-Auto-ranges","page":"Spline PSF","title":"Convenience Constructor with Auto-ranges","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"SplinePSF(psf::AbstractPSF; \n          lateral_range::Float64=2.0,\n          axial_range::Float64=1.0,\n          lateral_step::Float64=0.05,\n          axial_step::Float64=0.1,\n          order::Integer=3)","category":"page"},{"location":"psfs/spline_psf/#Parameters","page":"Spline PSF","title":"Parameters","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"psf: Source PSF to sample or pre-computed PSF data\nx_range, y_range, z_range: Coordinate ranges for the grid points\norder: Interpolation order (default: 3 for cubic B-splines)\nlateral_range: Half-width of lateral (xy) sampling range in microns\naxial_range: Half-width of axial (z) sampling range in microns\nlateral_step: Step size in microns for lateral sampling\naxial_step: Step size in microns for axial sampling","category":"page"},{"location":"psfs/spline_psf/#Basic-Usage","page":"Spline PSF","title":"Basic Usage","text":"","category":"section"},{"location":"psfs/spline_psf/#Creating-a-SplinePSF","page":"Spline PSF","title":"Creating a SplinePSF","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"using MicroscopePSFs\n\n# Create a source PSF to accelerate\ndipole_z = DipoleVector(0.0, 0.0, 1.0)\nvector_psf = Vector3DPSF(\n    1.4,                # Numerical aperture\n    0.532,              # Wavelength in microns\n    dipole_z,           # Dipole orientation\n    n_medium=1.33       # Sample medium refractive index\n)\n\n# Define coordinate sampling grid with explicit step sizes\nx_range = range(-2.0, 2.0, step=0.1)  # μm, 0.1μm step size\ny_range = range(-2.0, 2.0, step=0.1)  # μm, 0.1μm step size\nz_range = range(-2.0, 2.0, step=0.2)  # μm, 0.2μm step size\n\n# Create a spline representation (this step may take time)\nspline_psf = SplinePSF(vector_psf, x_range, y_range, z_range)\n\n# Alternatively, use the convenience constructor with auto-ranges\nspline_psf_auto = SplinePSF(vector_psf, \n                           lateral_range=2.0, \n                           axial_range=1.0,\n                           lateral_step=0.1, \n                           axial_step=0.2)","category":"page"},{"location":"psfs/spline_psf/#Direct-Evaluation","page":"Spline PSF","title":"Direct Evaluation","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# Evaluate at specific 3D position\nx = 0.1  # μm\ny = 0.2  # μm\nz = 0.5  # μm\nintensity = spline_psf(x, y, z)\n\n# For 2D PSFs or z=0 evaluation\nintensity_2d = spline_psf(x, y)\n\n# Get complex amplitude (returns sqrt of intensity as complex value)\namp = amplitude(spline_psf, x, y, z)","category":"page"},{"location":"psfs/spline_psf/#Creating-PSF-Images","page":"Spline PSF","title":"Creating PSF Images","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# Create a grid of positions with explicit step size\nx = range(-1, 1, step=0.02)  # μm, 0.02μm step size\ny = range(-1, 1, step=0.02)  # μm, 0.02μm step size\nz = 0.0  # focal plane\n\n# Compute PSF values at each position\nintensity_2d = [spline_psf(xi, yi, z) for yi in y, xi in x]\n\n# Visualize with CairoMakie\nusing CairoMakie\nfig = Figure(size=(600, 500))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"SplinePSF Interpolation (z=0μm)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nhm = heatmap!(ax, x, y, intensity_2d, colormap=:viridis)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/spline_psf/#Integration-with-Camera","page":"Spline PSF","title":"Integration with Camera","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# Create camera with 100nm pixels (20×20 pixel grid)\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:20, 1:20, pixel_size)\n\n# Create 3D emitter at position (1μm, 1μm, 0.5μm) with 1000 photons\nemitter = Emitter3D(1.0, 1.0, 0.5, 1000.0)  # x, y, z, photons\n\n# Integrate PSF over pixels with 2×2 subsampling\npixels = integrate_pixels(spline_psf, camera, emitter, sampling=2)\n\n# Visualize the camera image\nusing CairoMakie\nfig = Figure(size=(500, 400))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Integrated Camera Image (z=0.5μm)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nax.yreversed = true  # Flip y-axis to match camera convention\n\n# Get physical coordinates of pixel centers\nx_centers = (1:20) * pixel_size - pixel_size/2\ny_centers = (1:20) * pixel_size - pixel_size/2\n\nhm = heatmap!(ax, x_centers, y_centers, pixels', colormap=:viridis)\nscatter!(ax, [emitter.x], [emitter.y], color=:red, marker=:cross, markersize=15)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/spline_psf/#Performance-Comparison","page":"Spline PSF","title":"Performance Comparison","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"One of the main purposes of SplinePSF is to accelerate computation. Here's how to compare performance:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"using MicroscopePSFs\nusing BenchmarkTools\n\n# Create computationally expensive PSF\ndipole_z = DipoleVector(0.0, 0.0, 1.0)\nvector_psf = Vector3DPSF(1.4, 0.532, dipole_z, n_medium=1.33)\n\n# Create a spline version with same parameters\nx_range = range(-2.0, 2.0, length=41)\ny_range = range(-2.0, 2.0, length=41)\nz_range = range(-2.0, 2.0, length=21)\nspline_psf = SplinePSF(vector_psf, x_range, y_range, z_range)\n\n# Compare evaluation speed for single point\n@btime $vector_psf(0.5, 0.5, 0.1)  # Slow\n@btime $spline_psf(0.5, 0.5, 0.1)  # Fast\n\n# Compare speed for camera integration\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:16, 1:16, pixel_size)\nemitter = Emitter3D(1.0, 1.0, 0.0, 1000.0)\n\n@btime integrate_pixels($vector_psf, $camera, $emitter)  # Slow\n@btime integrate_pixels($spline_psf, $camera, $emitter)  # Fast","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Typical speedups range from 10-100× depending on the complexity of the original PSF model and grid size.","category":"page"},{"location":"psfs/spline_psf/#Working-with-Experimental-PSFs","page":"Spline PSF","title":"Working with Experimental PSFs","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"SplinePSF can also be used with experimentally measured PSF data:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# Load experimental PSF data\n# (In practice, this would be loaded from a file)\nfunction load_experimental_psf(filename)\n    # Example function - actual implementation would depend on file format\n    # Here we assume you have a 3D stack in HDF5 format\n    using HDF5\n    h5open(filename, \"r\") do file\n        return read(file, \"psf_stack\")\n    end\nend\n\n# Define physical coordinates for the experimental PSF\npixel_size = 0.1  # μm in the image\nz_step = 0.2      # μm between z-planes\nmeasured_psf = load_experimental_psf(\"path/to/measured_psf.h5\")\n\n# Create coordinate ranges based on PSF stack dimensions\nnx, ny, nz = size(measured_psf)\nx_center = nx ÷ 2\ny_center = ny ÷ 2\nz_center = nz ÷ 2\n\nx_range = range(-(x_center) * pixel_size, (nx-x_center-1) * pixel_size, length=nx)\ny_range = range(-(y_center) * pixel_size, (ny-y_center-1) * pixel_size, length=ny)\nz_range = range(-(z_center) * z_step, (nz-z_center-1) * z_step, length=nz)\n\n# Create the SplinePSF\nexperimental_psf = SplinePSF(measured_psf, x_range, y_range, z_range)","category":"page"},{"location":"psfs/spline_psf/#B-Spline-Interpolation-Details","page":"Spline PSF","title":"B-Spline Interpolation Details","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The SplinePSF uses different interpolation orders with specific trade-offs:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Order Name Properties Use Case\n0 Constant Simple nearest neighbor, no continuity Very fast, low accuracy\n1 Linear Continuous function, discontinuous derivatives Good compromise\n3 Cubic Continuous second derivatives Best accuracy (default)","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Cubic splines (order=3) provide:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Continuous second derivatives for smooth interpolation\nLocal support for efficient computation\nGood approximation of smooth functions\nAnalytic derivatives for optimization\nMinimal memory requirements compared to accuracy","category":"page"},{"location":"psfs/spline_psf/#Accuracy-Considerations","page":"Spline PSF","title":"Accuracy Considerations","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The accuracy of SplinePSF depends on the density of the sampling grid:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# Compare SplinePSF with original PSF\nscalar_psf = Scalar3DPSF(1.4, 0.532, 1.518)\n\n# Create a SplinePSF with recommended sampling resolution\nspline_psf = SplinePSF(scalar_psf, \n                      range(-2, 2, step=0.05),  # 0.05μm steps in x\n                      range(-2, 2, step=0.05),  # 0.05μm steps in y\n                      range(-1, 1, step=0.1))   # 0.1μm steps in z\n\n# Create test positions\nx_eval = range(-1, 1, step=0.02)  # Fine evaluation grid for comparison\ny = 0.0\nz = 0.0\n\n# Calculate profiles\noriginal = [scalar_psf(xi, y, z) for xi in x_eval]\nspline = [spline_psf(xi, y, z) for xi in x_eval]\n\n# Visualize comparison\nusing CairoMakie\nfig = Figure(size=(800, 400))\nax = Axis(fig[1, 1], xlabel=\"Position (μm)\", ylabel=\"Intensity\",\n          title=\"SplinePSF Accuracy Comparison\")\n\nlines!(ax, x_eval, original, label=\"Original PSF\", linewidth=2)\nlines!(ax, x_eval, spline, label=\"SplinePSF (0.05μm xy, 0.1μm z steps)\", \n       linestyle=:dash, linewidth=2)\n\naxislegend(ax)\nfig","category":"page"},{"location":"psfs/spline_psf/#Performance-Considerations","page":"Spline PSF","title":"Performance Considerations","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"SplinePSF is designed for computational efficiency:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Initial Construction: Creating the SplinePSF can be slow for complex source PSFs\nEvaluation Speed: Once created, evaluation is very fast (typically 10-100× faster than source PSF)\nMemory Usage: Memory scales with grid size (O(nx×ny×nz))\nInterpolation Order: Higher order provides more accuracy at slight computational cost\nBoundary Handling: Returns 0 for positions outside the grid boundaries","category":"page"},{"location":"psfs/spline_psf/#Limitations","page":"Spline PSF","title":"Limitations","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The SplinePSF model has several limitations:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Sampling Range: Limited to positions within the sampled grid range\nMemory Requirements: Can use significant memory for large, dense grids\nInitial Computation: Requires upfront computation time to create\nNo Physics Propagation: Cannot directly model physical effects not in the source PSF\nPhase Information: Limited phase accuracy in complex field representation","category":"page"},{"location":"psfs/spline_psf/#When-to-Use-SplinePSF","page":"Spline PSF","title":"When to Use SplinePSF","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Consider using SplinePSF when:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Performance is Critical: For fitting or simulation tasks requiring many PSF evaluations\nWorking with Complex Models: To accelerate Vector3DPSF or aberrated Scalar3DPSF evaluations\nUsing Experimental PSFs: When working with measured PSF data\nRunning on Limited Resources: To make complex models feasible on modest hardware\nBuilding Interactive Applications: Where real-time performance is necessary","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page provides a comprehensive reference of the types and functions in MicroscopePSFs.jl.","category":"page"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These types and functions form the core public API of MicroscopePSFs.jl.","category":"page"},{"location":"api/#PSF-Types","page":"API Reference","title":"PSF Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractPSF","category":"page"},{"location":"api/#MicroscopePSFs.AbstractPSF","page":"API Reference","title":"MicroscopePSFs.AbstractPSF","text":"AbstractPSF\n\nAbstract base type for all Point Spread Functions\n\n\n\n\n\n","category":"type"},{"location":"api/#2D-PSF-Models","page":"API Reference","title":"2D PSF Models","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Gaussian2D\nAiry2D","category":"page"},{"location":"api/#MicroscopePSFs.Gaussian2D","page":"API Reference","title":"MicroscopePSFs.Gaussian2D","text":"Gaussian2D{T<:AbstractFloat} <: Abstract2DPSF{T}\n\nIsotropic 2D Gaussian PSF.\n\nFields\n\nσ: Standard deviation in physical units (typically microns)\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Airy2D","page":"API Reference","title":"MicroscopePSFs.Airy2D","text":"Airy2D{T<:AbstractFloat} <: Abstract2DPSF{T}\n\n2D Airy pattern PSF using paraxial, scalar model.\n\nField amplitude for a circular aperture is given by:     A(r) = ν/√(4π) * (2J₁(νr)/(νr)) where:     ν = 2π*nₐ/λ     J₁ is the Bessel function of first kind, order 1     r is the radial distance from optical axis\n\nFields\n\nnₐ: Numerical aperture\nλ: Wavelength in microns\nν: Optical parameter = 2π*nₐ/λ\n\n\n\n\n\n","category":"type"},{"location":"api/#3D-PSF-Models","page":"API Reference","title":"3D PSF Models","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Scalar3DPSF\nVector3DPSF","category":"page"},{"location":"api/#MicroscopePSFs.Scalar3DPSF","page":"API Reference","title":"MicroscopePSFs.Scalar3DPSF","text":"Scalar3DPSF{T} <: Abstract3DPSF{T}\n\nScalar 3D PSF using explicit pupil function representation.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in microns\nn::T: Refractive index\npupil::PupilFunction{T}: Complex pupil function\nzernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}: Zernike coefficients used to create this PSF (if applicable)\n\nNotes\n\nCan be initialized with either a PupilFunction or ZernikeCoefficients using the Scalar3DPSF factory function.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Vector3DPSF","page":"API Reference","title":"MicroscopePSFs.Vector3DPSF","text":"Vector3DPSF{T<:AbstractFloat} <: Abstract3DPSF{T}\n\nVector PSF model using explicit pupil function representation. Allows direct manipulation of pupil function for custom aberrations.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in microns\nn_medium::T: Sample medium refractive index\nn_coverslip::T: Cover slip refractive index\nn_immersion::T: Immersion medium refractive index\ndipole::DipoleVector{T}: Dipole orientation\nz_stage::T: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)\nvector_pupils::VectorPupilFunction{T}: Pre-calculated pupil functions containing vector field components (Ex,Ey), dipole orientation effects, base aberrations, apodization, and all position-independent factors\nbase_pupil::Union{Nothing, PupilFunction{T}}: Base pupil function representing system aberrations\nzernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}: Zernike coefficients used to create this PSF (if applicable)\n\n\n\n\n\n","category":"type"},{"location":"api/#Data-driven-PSF","page":"API Reference","title":"Data-driven PSF","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SplinePSF","category":"page"},{"location":"api/#MicroscopePSFs.SplinePSF","page":"API Reference","title":"MicroscopePSFs.SplinePSF","text":"SplinePSF{T<:AbstractFloat, IT<:AbstractInterpolation} <: AbstractPSF\n\nA point spread function (PSF) represented as a B-spline interpolation.\n\nFields\n\nspline: The B-spline interpolation object \nx_range: Range of x-coordinates used for uniform grid interpolation\ny_range: Range of y-coordinates used for uniform grid interpolation  \nz_range: Range of z-coordinates for 3D PSFs, or nothing for 2D PSFs\noriginal_grid: Original grid data used to create the interpolation\ninterp_order: Interpolation order used (0=constant, 1=linear, 3=cubic)\n\nNotes\n\nCoordinates and ranges are in physical units (typically microns)\nPSF values are preserved from the original PSF that was sampled\nInterpolation order determines the smoothness of the interpolation:\n0: Constant (nearest neighbor)\n1: Linear\n3: Cubic B-spline (default, most accurate)\nThe original grid is stored to ensure exact reproduction when saving/loading\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-Interface-Functions","page":"API Reference","title":"Core Interface Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"amplitude\nintegrate_pixels\nintegrate_pixels_amplitude","category":"page"},{"location":"api/#MicroscopePSFs.amplitude","page":"API Reference","title":"MicroscopePSFs.amplitude","text":"amplitude(p::PupilFunction, x::Real, y::Real, z::Real)\n\nCalculate complex amplitude from pupil function integration.\n\nArguments\n\np::PupilFunction: Pupil function\nx::Real: X position in μm\ny::Real: Y position in μm\nz::Real: Z position in μm\n\n\n\n\n\namplitude(psf::AbstractPSF, x::Real, y::Real)\n\nEvaluate complex field amplitude at position (x,y) relative to PSF center.\n\nArguments\n\nx, y: Position in microns relative to PSF center\n\nReturns\n\nComplex amplitude normalized such that |amplitude|² gives normalized intensity\n\nCoordinates\n\nInput coordinates (x,y) are in physical units (microns) relative to PSF center.\n\nExamples\n\npsf = Airy2D(1.4, 0.532)\namp = amplitude(psf, 0.1, 0.2)\nintensity = abs2(amp)  # Convert to intensity\n\n\n\n\n\namplitude(psf::AbstractPSF, x::Real, y::Real, z::Real)\n\nEvaluate complex field amplitude in 3D. z is axial distance from focus in microns.\n\n\n\n\n\namplitude(psf::Scalar3DPSF{T}, x::Real, y::Real, z::Real) where {T}\n\nCalculate complex amplitude at a 3D position using scalar diffraction theory.\n\nArguments\n\npsf: Scalar3DPSF instance\nx, y, z: Position in microns relative to PSF center\n\nReturns\n\nComplex amplitude at the specified position\n\nNotes\n\nUses Fourier optics to propagate from pupil to image space\nAccounts for defocus and aberrations encoded in the pupil function\n\n\n\n\n\namplitude(psf::Vector3DPSF, x::Real, y::Real, z::Real)\n\nCompute complex vector amplitude at given position.\n\nArguments\n\npsf: Vector PSF instance\nx, y: Lateral position in microns relative to PSF center\nz: Axial position in microns representing depth above the coverslip\n\nReturns\n\nVector [Ex, Ey] of complex field amplitudes\n\nNotes\n\nz coordinate represents the depth above the coverslip\nz_stage in the PSF indicates the distance the stage was moved away from the nominal focal plane\nIncludes both UAF and SAF contributions automatically\n\n\n\n\n\namplitude(psf::SplinePSF, x::Real, y::Real, z::Real)\n\nCalculate the complex amplitude of the 3D PSF at position (x, y, z).\n\nArguments\n\npsf: SplinePSF instance\nx, y, z: Coordinates in microns relative to PSF center\n\nReturns\n\nComplex amplitude = sqrt(intensity) with zero phase\n\nNotes\n\nReturns sqrt(intensity) as Complex to match the interface of other PSFs\nThe SplinePSF does not model phase information\n\n\n\n\n\namplitude(psf::SplinePSF, x::Real, y::Real)\n\nCalculate the complex amplitude of the PSF at position (x, y) with z=0.\n\nArguments\n\npsf: SplinePSF instance\nx, y: Coordinates in microns relative to PSF center\n\nReturns\n\nComplex amplitude = sqrt(intensity) with zero phase\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.integrate_pixels","page":"API Reference","title":"MicroscopePSFs.integrate_pixels","text":"integrate_pixels(psf::AbstractPSF, camera::AbstractCamera, emitter::AbstractEmitter; sampling::Integer=2)\n\nIntegrate PSF intensity over camera pixels.\n\nFor each pixel in the camera, numerically integrates the PSF intensity using the specified  sampling density. Physical coordinates are relative to camera with (0,0) at top-left corner.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\ncamera::AbstractCamera: Camera geometry defining pixel edges in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsampling::Integer=2: Number of samples per pixel in each dimension\n\nReturns\n\nMatrix{T}: Integrated intensities where T matches emitter.photons type\nArray is indexed as [y,x] with [1,1] at top-left pixel\nValues represent actual photon counts in each pixel based on emitter's photon value\n\nExamples\n\ncamera = IdealCamera(0:0.1:2.0, 0:0.1:2.0)  # 20x20 camera, 100nm pixels\nemitter = Emitter2D(1.0, 1.0, 1000.0)       # Emitter at (1μm, 1μm) with 1000 photons\npsf = Gaussian2D(0.15)                       # σ = 150nm\npixels = integrate_pixels(psf, camera, emitter)\n# Sum of pixels will be ≤ 1000, depending on how much of the PSF is captured by the camera\n\nSee also: integrate_pixels_amplitude, AbstractPSF\n\n\n\n\n\nintegrate_pixels(psf::Scalar3DPSF,\n                camera::AbstractCamera,\n                emitter::AbstractEmitter;\n                sampling::Integer=2)\n\nIntegrate PSF intensity over camera pixels for a 3D emitter.\n\nArguments\n\npsf: Scalar3DPSF instance\ncamera: Camera geometry defining pixel layout\nemitter: Emitter with position information (must have z-coordinate)\nsampling: Subpixel sampling density for integration accuracy (default: 2)\n\nReturns\n\nArray of integrated PSF intensities with dimensions [ny, nx]\nValues represent actual photon counts based on emitter.photons\n\nNotes\n\nUses the z-coordinate from the emitter for the focal plane\nHigher sampling values give more accurate results but slower computation\n\n\n\n\n\nintegrate_pixels(psf::Vector3DPSF,\n                camera::AbstractCamera,\n                emitter::AbstractEmitter;\n                sampling::Integer=2)\n\nIntegrate Vector3DPSF over camera pixels.\n\nArguments\n\npsf: Vector3DPSF instance with fixed dipole orientation\ncamera: Camera geometry\nemitter: Emitter with position information (emitter.z represents depth above the coverslip)\nsampling: Subpixel sampling density for integration accuracy\n\nReturns\n\nArray of integrated PSF intensities with dimensions [ny, nx]\nValues represent actual photon counts based on emitter.photons\n\nNotes\n\nDipole orientation comes from the PSF itself, not the emitter\nFor varying dipole orientations, create multiple PSFs\nThe emitter's z position must represent depth above the coverslip\n\n\n\n\n\nintegrate_pixels(psf::SplinePSF, \n                camera::AbstractCamera, \n                emitter::AbstractEmitter;\n                sampling::Integer=2)\n\nIntegrate PSF over camera pixels using interpolation.\n\nArguments\n\npsf: SplinePSF instance\ncamera: Camera geometry\nemitter: Emitter with position information\nsampling: Subpixel sampling density for integration accuracy\n\nReturns\n\nArray of integrated PSF intensities with dimensions [ny, nx]\nValues represent actual photon counts based on emitter's photon value\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude","text":"integrate_pixels_amplitude(psf::AbstractPSF, camera::AbstractCamera, emitter::AbstractEmitter; sampling::Integer=2)\n\nIntegrate PSF complex amplitude over camera pixels.\n\nFor each pixel in the camera, numerically integrates the PSF amplitude using the specified sampling density. Unlike intensity integration, returns unnormalized complex amplitudes which can be used for coherent calculations.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\ncamera::AbstractCamera: Camera geometry defining pixel edges in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsampling::Integer=2: Number of samples per pixel in each dimension\n\nReturns\n\nMatrix{Complex{T}}: Integrated complex amplitudes where T matches emitter.photons type\nArray is indexed as [y,x] with [1,1] at top-left pixel\nValues are not normalized to preserve complex amplitude relationships\n\nNotes\n\nFor coherent calculations, use this function instead of integrate_pixels\nReturn type is complex to support PSFs with phase information\nTo get intensity from amplitude: abs2.(integrate_pixels_amplitude(...))\n\nExamples\n\ncamera = IdealCamera(0:0.1:2.0, 0:0.1:2.0)  # 20x20 camera, 100nm pixels\nemitter = Emitter2D(1.0, 1.0, 1000.0)       # Emitter at (1μm, 1μm)\npsf = Gaussian2D(0.15)                       # σ = 150nm\namplitudes = integrate_pixels_amplitude(psf, camera, emitter)\nintensities = abs2.(amplitudes)              # Convert to intensity if needed\n\nSee also: integrate_pixels, AbstractPSF\n\n\n\n\n\nintegrate_pixels_amplitude(psf::Vector3DPSF,\n                          camera::AbstractCamera,\n                          emitter::AbstractEmitter;\n                          sampling::Integer=2)\n\nIntegrate Vector3DPSF complex amplitude over camera pixels.\n\nArguments\n\npsf: Vector3DPSF instance with fixed dipole orientation\ncamera: Camera geometry\nemitter: Emitter with position information (emitter.z represents depth above the coverslip)\nsampling: Subpixel sampling density for integration accuracy\n\nReturns\n\nArray of integrated complex field components with dimensions [ny, nx, 2]\nFirst two dimensions are spatial, third dimension holds [Ex, Ey]\n\nNotes\n\nFor coherent calculations in vectorial microscopy\nPreserves relative phase information between field components\nThe emitter's z position must represent depth above the coverslip\n\n\n\n\n\nintegrate_pixels_amplitude(psf::SplinePSF,\n                         camera::AbstractCamera,\n                         emitter::AbstractEmitter;\n                         sampling::Integer=2)\n\nIntegrate PSF amplitude (complex) over camera pixels.\n\nArguments\n\npsf: SplinePSF instance\ncamera: Camera geometry\nemitter: Emitter with position information\nsampling: Subpixel sampling density for integration accuracy\n\nReturns\n\nArray of integrated PSF complex amplitudes with dimensions [ny, nx]\n\n\n\n\n\n","category":"function"},{"location":"api/#Pupil-Functions","page":"API Reference","title":"Pupil Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PupilFunction\nVectorPupilFunction","category":"page"},{"location":"api/#MicroscopePSFs.PupilFunction","page":"API Reference","title":"MicroscopePSFs.PupilFunction","text":"PupilFunction{T}\n\nRepresents a pupil function with physical parameters.\n\nFields\n\nnₐ: Numerical aperture\nλ: Wavelength in μm\nn: Refractive index\nfield: Complex-valued pupil function array\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.VectorPupilFunction","page":"API Reference","title":"MicroscopePSFs.VectorPupilFunction","text":"VectorPupilFunction{T}\n\nVector pupil function storing Ex,Ey field components as PupilFunctions.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in μm\nn_medium::T: Refractive index of the sample medium\nn_coverslip::T: Refractive index of the coverslip\nn_immersion::T: Refractive index of the immersion medium\nEx::PupilFunction{T}: x-component of electric field\nEy::PupilFunction{T}: y-component of electric field\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike-Module","page":"API Reference","title":"Zernike Module","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ZernikeCoefficients\nZernikeIndexing\nOSA\nNoll","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.ZernikeCoefficients","page":"API Reference","title":"MicroscopePSFs.Zernike.ZernikeCoefficients","text":"ZernikeCoefficients{T<:Real}\n\nMutable structure to hold Zernike coefficients for both magnitude and phase of a pupil function.\n\nFields\n\nmag::Vector{T}: Coefficients for magnitude\nphase::Vector{T}: Coefficients for phase\n\nNotes\n\nFirst coefficient (index 1) typically represents piston\nMagnitude coefficients are typically normalized with mag[1] = 1\nPhase coefficients represent phase in radians\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Zernike.ZernikeIndexing","page":"API Reference","title":"MicroscopePSFs.Zernike.ZernikeIndexing","text":"ZernikeIndexing\n\nEnum type for different Zernike polynomial indexing conventions. Used to specify which indexing scheme to use in calculations.\n\nValues\n\nOSA: OSA/ANSI standard indexing\nNoll: Noll indexing scheme\n\n\n\n\n\n","category":"type"},{"location":"api/#Aberration-Functions","page":"API Reference","title":"Aberration Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"add_aberration!\nadd_defocus!\nadd_astigmatism!\nadd_coma!\nadd_spherical!\nreset!\nscale!\nmerge!\nrms\ntrim!\nsignificant_terms","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.add_aberration!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_aberration!","text":"add_aberration!(coeffs::ZernikeCoefficients, \n               index::Integer, \n               mag_value::Real=0, \n               phase_value::Real=0;\n               indexing::ZernikeIndexing=OSA) -> ZernikeCoefficients\n\nAdd aberration terms to existing coefficients.\n\nArguments\n\ncoeffs: ZernikeCoefficients to modify\nindex: Index of Zernike term (starting at 0)\nmag_value: Value to add to magnitude coefficient\nphase_value: Value to add to phase coefficient\nindexing: Indexing convention for the index\n\nNotes\n\nIndex is 0-based to match standard Zernike notation\nReturns the modified coefficients for chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_defocus!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_defocus!","text":"add_defocus!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd defocus aberration (n=2, l=0).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_astigmatism!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_astigmatism!","text":"add_astigmatism!(coeffs::ZernikeCoefficients, \n                 amount::Real, \n                 angle::Real=0.0) -> ZernikeCoefficients\n\nAdd astigmatism with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_coma!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_coma!","text":"add_coma!(coeffs::ZernikeCoefficients, \n          amount::Real, \n          angle::Real=0.0) -> ZernikeCoefficients\n\nAdd coma with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_spherical!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_spherical!","text":"add_spherical!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd primary spherical aberration.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.reset!","page":"API Reference","title":"MicroscopePSFs.Zernike.reset!","text":"reset!(coeffs::ZernikeCoefficients) -> ZernikeCoefficients\n\nReset coefficients to default state (mag[1]=1, all others zero).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.scale!","page":"API Reference","title":"MicroscopePSFs.Zernike.scale!","text":"scale!(coeffs::ZernikeCoefficients, factor::Real) -> ZernikeCoefficients\n\nScale all coefficients (except piston) by given factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.rms","page":"API Reference","title":"MicroscopePSFs.Zernike.rms","text":"rms(coeffs::ZernikeCoefficients) -> Tuple{Float64,Float64}\n\nCalculate RMS values for magnitude and phase coefficients (excluding piston).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.trim!","page":"API Reference","title":"MicroscopePSFs.Zernike.trim!","text":"trim!(coeffs::ZernikeCoefficients, threshold::Real) -> ZernikeCoefficients\n\nSet coefficients below threshold (relative to RMS) to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.significant_terms","page":"API Reference","title":"MicroscopePSFs.Zernike.significant_terms","text":"significant_terms(coeffs::ZernikeCoefficients, \n                 threshold::Real=0.01) -> Vector{Tuple{Int,Float64,Float64}}\n\nReturn list of significant terms: (index, magnitude, phase) above threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike-Polynomial-Functions","page":"API Reference","title":"Zernike Polynomial Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"zernikepolynomial\nradialpolynomial\nmax_radial_order\nevaluate_pupil","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.zernikepolynomial","page":"API Reference","title":"MicroscopePSFs.Zernike.zernikepolynomial","text":"zernikepolynomial(n::Integer, l::Integer, ρ::Real, ϕ::Real) -> Real\n\nCompute the complete Zernike polynomial Z_n^l(ρ,ϕ).\n\nArguments\n\nn: Radial order\nl: Azimuthal frequency (signed)\nρ: Radial coordinate (0 ≤ ρ ≤ 1)\nϕ: Azimuthal angle in radians\n\nNotes\n\nUses born-wolf normalization\nCombines radial polynomial with appropriate trigonometric function\n\n\n\n\n\nzernikepolynomial(j::Integer, ρ::Real, ϕ::Real, indexing::ZernikeIndexing=OSA) -> Real\n\nCompute Zernike polynomial using single-index notation.\n\nArguments\n\nj: Polynomial index (OSA or Noll)\nρ: Radial coordinate\nϕ: Azimuthal angle\nindexing: Index convention to use (OSA or Noll)\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.radialpolynomial","page":"API Reference","title":"MicroscopePSFs.Zernike.radialpolynomial","text":"radialpolynomial(n::Integer, m::Integer, ρ::Real) -> Real\n\nCompute the radial component R_n^m(ρ) of the Zernike polynomial.\n\nArguments\n\nn: Radial order\nm: Azimuthal order (absolute value of azimuthal frequency)\nρ: Radial coordinate (0 ≤ ρ ≤ 1)\n\nNotes\n\nReturns 0 for ρ > 1\nNormalizes according to born-wolf convention\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.evaluate_pupil","page":"API Reference","title":"MicroscopePSFs.Zernike.evaluate_pupil","text":"evaluate_pupil(coeffs::ZernikeCoefficients, grid_size::Integer;\n              indexing::ZernikeIndexing=OSA) -> Matrix{Complex{Float64}}\n\nGenerate complex pupil function from Zernike coefficients.\n\nArguments\n\ncoeffs: ZernikeCoefficients containing magnitude and phase coefficients\ngrid_size: Size of the output grid (gridsize × gridsize)\nindexing: Indexing convention for coefficients (OSA or Noll)\n\nReturns\n\nComplex-valued matrix representing the pupil function\n\nNotes\n\nOutput grid is normalized to unit circle\nPoints outside unit circle are set to zero\nPhase is applied as exp(iϕ)\n\n\n\n\n\n","category":"function"},{"location":"api/#Index-Conversion","page":"API Reference","title":"Index Conversion","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"nl2osa\nosa2nl\nnl2noll\nnoll2nl\nosa2noll\nnoll2osa\nconvert_index","category":"page"},{"location":"api/#Emitters","page":"API Reference","title":"Emitters","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"DipoleVector\nDipoleEmitter3D","category":"page"},{"location":"api/#MicroscopePSFs.DipoleVector","page":"API Reference","title":"MicroscopePSFs.DipoleVector","text":"DipoleVector{T} <: Real\n\nA 3D vector representing the dipole orientation.\n\nFields\n\npx::T: x component of the dipole vector\npy::T: y component of the dipole vector\npz::T: z component of the dipole vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.DipoleEmitter3D","page":"API Reference","title":"MicroscopePSFs.DipoleEmitter3D","text":"DipoleEmitter3D{T} <: AbstractEmitter\n\n3D dipole emitter with position, orientation and optical properties.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns \nz::T: z-coordinate in microns\nphotons::T: number of photons\ndipole::DipoleVector{T}: dipole orientation vector\n\n\n\n\n\n","category":"type"},{"location":"api/#I/O-Functions","page":"API Reference","title":"I/O Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"save_psf\nload_psf","category":"page"},{"location":"api/#MicroscopePSFs.save_psf","page":"API Reference","title":"MicroscopePSFs.save_psf","text":"save_psf(filename::String, object; metadata::Dict=Dict())\n\nSave a PSF or related object (e.g., ZernikeCoefficients, PupilFunction) to an HDF5 file.\n\nArguments\n\nfilename: Path where the PSF will be saved\nobject: Object to save (PSF, ZernikeCoefficients, PupilFunction, etc.)\nmetadata: Optional dictionary of additional metadata to include\n\nReturns\n\nfilename for chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#Complete-API-(All-Documented-Functions)","page":"API Reference","title":"Complete API (All Documented Functions)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section lists additional internal functions and types that are documented but not part of the public API.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MicroscopePSFs]\nPublic = false","category":"page"},{"location":"api/#MicroscopePSFs.Abstract2DPSF","page":"API Reference","title":"MicroscopePSFs.Abstract2DPSF","text":"Abstract2DPSF{T<:AbstractFloat}\n\nAbstract type for all 2D point spread functions. Parameterized by numeric type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Abstract3DPSF","page":"API Reference","title":"MicroscopePSFs.Abstract3DPSF","text":"Abstract3DPSF{T<:AbstractFloat}\n\nAbstract type for all 3D point spread functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs._check_normalization-Tuple{Any}","page":"API Reference","title":"MicroscopePSFs._check_normalization","text":"_check_normalization(values; tol=1e-6)\n\nInternal function to verify array sums to 1 within tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._integrate_pixels_generic-Union{Tuple{T}, Tuple{AbstractPSF, AbstractCamera, AbstractEmitter, Function, Type{T}}} where T","page":"API Reference","title":"MicroscopePSFs._integrate_pixels_generic","text":"_integrate_pixels_generic(\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter,\n    f::Function,  # Function to integrate\n    ::Type{T};   # Return type\n    sampling::Integer=2\n) where T\n\nInternal generic integration routine used by both intensity and amplitude integration.\n\nReturns\n\nMatrix{T} with dimensions [y,x] starting at [1,1] for top-left pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_check_required_fields-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_check_required_fields","text":"_io_check_required_fields(group, fields)\n\nCheck if all required fields exist in an HDF5 group. Throws an error if any required field is missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_complex_array-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_load_complex_array","text":"_io_load_complex_array(group, name)\n\nLoad a complex array from an HDF5 group by combining real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_range-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_load_range","text":"_io_load_range(group, name)\n\nLoad a range from an HDF5 group by reconstructing from start, step, and length.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_zernike_coeffs-Tuple{Any}","page":"API Reference","title":"MicroscopePSFs._io_load_zernike_coeffs","text":"_io_load_zernike_coeffs(file; group_name=\"zernike_coefficients\")\n\nLoad ZernikeCoefficients from an HDF5 file from a specified group. Returns nothing if the group doesn't exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_complex_array-Tuple{Any, Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_complex_array","text":"_io_save_complex_array(group, name, array)\n\nSave a complex array to an HDF5 group by splitting into real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_pupil_params-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_pupil_params","text":"_io_save_pupil_params(params, pupil)\n\nSave common pupil parameters to an HDF5 group.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_range-Tuple{Any, Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_range","text":"_io_save_range(group, name, range)\n\nSave a range to an HDF5 group by storing start, step, and length.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_zernike_coeffs-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_zernike_coeffs","text":"_io_save_zernike_coeffs(file, coeffs; group_name=\"zernike_coefficients\")\n\nSave ZernikeCoefficients to an HDF5 file in a specified group. Does nothing if coeffs is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Airy2D}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Airy2D})\n\nLoad an Airy2D PSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Gaussian2D}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Gaussian2D})\n\nLoad a Gaussian2D PSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{PupilFunction}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{PupilFunction})\n\nLoad a PupilFunction from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Scalar3DPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Scalar3DPSF})\n\nLoad a Scalar3DPSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{SplinePSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{SplinePSF})\n\nLoad a SplinePSF from an HDF5 file, reconstructing it using the standard constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Vector3DPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Vector3DPSF})\n\nLoad a Vector3DPSF from an HDF5 file, reconstructing all components.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPupilFunction}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{VectorPupilFunction})\n\nLoad a VectorPupilFunction from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ZernikeCoefficients}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{ZernikeCoefficients})\n\nLoad ZernikeCoefficients from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._sample_psf_2d-Tuple{AbstractPSF, AbstractRange, AbstractRange}","page":"API Reference","title":"MicroscopePSFs._sample_psf_2d","text":"_sample_psf_2d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange)\n\nInternal helper function to sample a 2D PSF on a regular grid. Returns an array with dimensions [y, x] containing raw PSF values.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._sample_psf_3d-Tuple{AbstractPSF, AbstractRange, AbstractRange, AbstractRange}","page":"API Reference","title":"MicroscopePSFs._sample_psf_3d","text":"_sample_psf_3d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange, z_range::AbstractRange)\n\nInternal helper function to sample a 3D PSF on a regular grid. Returns an array with dimensions [y, x, z] containing raw PSF values.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Airy2D}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Airy2D)\n\nSave an Airy2D PSF to an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Gaussian2D}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Gaussian2D)\n\nSave a Gaussian2D PSF to an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, PupilFunction}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, pupil::PupilFunction)\n\nSave a PupilFunction to an HDF5 file, including physical parameters and complex field.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Scalar3DPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Scalar3DPSF)\n\nSave a Scalar3DPSF to an HDF5 file, including pupil function and any Zernike coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, SplinePSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::SplinePSF)\n\nSave a SplinePSF to an HDF5 file, including the original grid data used to create the spline interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Vector3DPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Vector3DPSF)\n\nSave a Vector3DPSF to an HDF5 file, including all optical parameters, dipole orientation, and vector pupil fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, pupil::VectorPupilFunction)\n\nSave a VectorPupilFunction to an HDF5 file, including all physical parameters and both Ex and Ey field components.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ZernikeCoefficients}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, zc::ZernikeCoefficients)\n\nSave ZernikeCoefficients to an HDF5 file, storing magnitude and phase arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.apply_aperture!","page":"API Reference","title":"MicroscopePSFs.apply_aperture!","text":"apply_aperture!(p::PupilFunction, radius::Real=1.0)\n\nApply circular aperture to pupil function. Radius is relative to NA.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.apply_defocus!-Tuple{PupilFunction, Real}","page":"API Reference","title":"MicroscopePSFs.apply_defocus!","text":"apply_defocus!(p::PupilFunction, z::Real)\n\nApply defocus phase to pupil function for propagation distance z.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_apodization-NTuple{4, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_apodization","text":"calculate_apodization(kr2::Real, λ::Real, \n                    n_medium::Real, n_immersion::Real)\n\nCalculate apodization factor for energy conservation.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn_medium: Refractive index of the sample medium\nn_immersion: Refractive index of the immersion medium\n\nReturns\n\nApodization factor for energy conservation\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_axial_phase","page":"API Reference","title":"MicroscopePSFs.calculate_axial_phase","text":"calculate_axial_phase(z::Real, z_stage::Real, kz_medium::Complex, \n                     kz_coverslip::Complex, kz_immersion::Complex,\n                     coverslip_thickness::Real=0.17)\n\nCalculate total axial phase from defocus.\n\nArguments\n\nz: Emitter position relative to the coverslip (depth above the coverslip in μm)\nz_stage: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)\nkz_medium: z-component of wave vector in sample medium\nkz_coverslip: z-component of wave vector in coverslip\nkz_immersion: z-component of wave vector in immersion medium\ncoverslip_thickness: Thickness of coverslip in mm (default: 0.17mm)\n\nReturns\n\nDefocus phase\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.calculate_dipole_field_components-Tuple{Complex, Complex, Complex, DipoleVector, Complex, Complex}","page":"API Reference","title":"MicroscopePSFs.calculate_dipole_field_components","text":"calculate_dipole_field_components(ϕ::Complex, sinθ::Complex, cosθ::Complex,\n                                dipole::DipoleVector, Tp::Complex, Ts::Complex)\n\nCalculate vectorial field components for a dipole orientation.\n\nArguments\n\nϕ: Azimuthal angle in pupil plane\nsinθ: Sine of polar angle\ncosθ: Cosine of polar angle\ndipole: Dipole orientation vector\nTp: p-polarization transmission coefficient\nTs: s-polarization transmission coefficient\n\nReturns\n\nTuple (Ex, Ey) of complex field components\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_interface_fresnel-NTuple{4, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_interface_fresnel","text":"calculate_interface_fresnel(kr2::Real, λ::Real, \n                          n1::Real, n2::Real)\n\nCalculate Fresnel transmission coefficients for a single interface.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn1: Refractive index of first medium\nn2: Refractive index of second medium\n\nReturns\n\nTuple of (Tp, Ts): p and s polarization transmission coefficients\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_wave_vectors-NTuple{5, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_wave_vectors","text":"calculate_wave_vectors(kr2::Real, λ::Real, \n                     n_medium::Real, n_coverslip::Real, n_immersion::Real)\n\nCalculate z-components of wave vectors in all three media.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn_medium: Refractive index of the sample medium\nn_coverslip: Refractive index of the coverslip\nn_immersion: Refractive index of the immersion medium\n\nReturns\n\nTuple of (kzmedium, kzcoverslip, kz_immersion): z-components of wave vectors in each medium\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.fill_vector_pupils!","page":"API Reference","title":"MicroscopePSFs.fill_vector_pupils!","text":"fill_vector_pupils!(vpupil::VectorPupilFunction, dipole::DipoleVector,\n                  base_pupil::Union{Nothing, PupilFunction}=nothing)\n\nFill vector pupil function with field components including dipole orientation, base aberrations, and proper apodization.\n\nThis pre-calculates all position-independent factors of the pupil function.\n\nArguments\n\nvpupil: Vector pupil function to fill\ndipole: Dipole orientation vector\nbase_pupil: Optional base aberration pupil function\n\nReturns\n\nFilled and normalized vector pupil function\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.kmax-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.kmax","text":"kmax(p::PupilFunction)\n\nGet maximum spatial frequency in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kmax-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.kmax","text":"Get maximum spatial frequency in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kpixelsize-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.kpixelsize","text":"kpixelsize(p::PupilFunction)\n\nGet pupil plane sampling in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kpixelsize-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.kpixelsize","text":"Get pupil plane sampling in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.k₀-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.k₀","text":"k₀(p::PupilFunction)\n\nGet central wavevector magnitude in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.k₀-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.k₀","text":"Get central wavevector magnitude in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.normalize!-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.normalize!","text":"normalize!(p::PupilFunction)\n\nNormalize pupil function to unit energy using Parseval's theorem.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.normalize!-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.normalize!","text":"normalize!(p::VectorPupilFunction)\n\nNormalize the electric field components of the vector pupil function. Ensures total energy across both components equals 1.\n\nArguments\n\np: Vector pupil function to normalize\n\nReturns\n\nNormalized vector pupil function\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.update_pupils!-Tuple{Vector3DPSF}","page":"API Reference","title":"MicroscopePSFs.update_pupils!","text":"update_pupils!(psf::Vector3DPSF) -> Vector3DPSF\n\nUpdate the vector pupil function based on stored Zernike coefficients and/or base pupil. This is useful after modifying aberrations to regenerate the pupil fields.\n\nArguments\n\npsf: Vector3DPSF to update\n\nReturns\n\nUpdated Vector3DPSF\n\nNotes\n\nRequires either stored Zernike coefficients or a base pupil\nReturns the updated PSF for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#Zernike-Module-Internal-API","page":"API Reference","title":"Zernike Module Internal API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MicroscopePSFs.Zernike]\nPublic = false","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.add_astigmatism!-2","page":"API Reference","title":"MicroscopePSFs.Zernike.add_astigmatism!","text":"add_astigmatism!(coeffs::ZernikeCoefficients, \n                 amount::Real, \n                 angle::Real=0.0) -> ZernikeCoefficients\n\nAdd astigmatism with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_coma!-2","page":"API Reference","title":"MicroscopePSFs.Zernike.add_coma!","text":"add_coma!(coeffs::ZernikeCoefficients, \n          amount::Real, \n          angle::Real=0.0) -> ZernikeCoefficients\n\nAdd coma with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_defocus!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.add_defocus!","text":"add_defocus!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd defocus aberration (n=2, l=0).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.add_spherical!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.add_spherical!","text":"add_spherical!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd primary spherical aberration.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.build_zernike_basis-Tuple{Integer, Integer}","page":"API Reference","title":"MicroscopePSFs.Zernike.build_zernike_basis","text":"build_zernike_basis(grid_size::Integer, num_terms::Integer;\n                   indexing::ZernikeIndexing=OSA) -> Matrix{Float64}\n\nBuild a matrix of Zernike polynomials for least-squares fitting.\n\nArguments\n\ngrid_size: Size of the sampling grid\nnum_terms: Number of Zernike terms to include\nindexing: Indexing convention for polynomials\n\nReturns\n\nMatrix of size (validpoints, numterms) containing Zernike values\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.evaluate_polynomial_grid-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"MicroscopePSFs.Zernike.evaluate_polynomial_grid","text":"evaluate_polynomial_grid(n::Integer, l::Integer, grid_size::Integer) -> Matrix{Float64}\n\nGenerate a grid of Zernike polynomial values for visualization.\n\nArguments\n\nn: Radial order\nl: Azimuthal frequency\ngrid_size: Size of output grid\n\nReturns\n\nMatrix of polynomial values over [-1,1] × [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.fit_error-Tuple{AbstractMatrix{<:Complex}, ZernikeCoefficients}","page":"API Reference","title":"MicroscopePSFs.Zernike.fit_error","text":"fit_error(pupil::AbstractMatrix{<:Complex}, coeffs::ZernikeCoefficients;\n         indexing::ZernikeIndexing=OSA) -> Float64\n\nCalculate RMS error between pupil and its Zernike fit.\n\nReturns\n\nRMS error normalized to mean pupil magnitude\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.get_nl","page":"API Reference","title":"MicroscopePSFs.Zernike.get_nl","text":"get_nl(j::Integer, indexing::ZernikeIndexing=OSA) -> Tuple{Int,Int}\n\nGet (n,l) indices from either OSA or Noll index.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.merge!","page":"API Reference","title":"MicroscopePSFs.Zernike.merge!","text":"merge!(target::ZernikeCoefficients, \n       source::ZernikeCoefficients, \n       weight::Real=1.0) -> ZernikeCoefficients\n\nMerge source coefficients into target with optional weighting.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.propagate_field-Union{Tuple{T}, Tuple{ZernikeCoefficients{T}, Vararg{T, 6}}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.Zernike.propagate_field","text":"propagate_field(coeffs::ZernikeCoefficients{T},\n               λ::T, n::T, nₐ::T,\n               r::T, φ::T, z::T;\n               nk::Integer=100) where {T<:Real}\n\nPropagate field from pupil described by Zernike coefficients to point (r,φ,z).\n\nU(r,φ,z) = 2π ∫₀^kmax dkr kr e^{2πiz√(k²-kr²)} ∑{n,m} Rn^m Jm(2πkr r)[Ca cos(mφ) + Cb sin(mφ)]\n\nCa is the complex coefficient for the Zernike mode (n,m) and Cb is the complex coefficient for (n,-m).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.rms-Tuple{ZernikeCoefficients}","page":"API Reference","title":"MicroscopePSFs.Zernike.rms","text":"rms(coeffs::ZernikeCoefficients) -> Tuple{Float64,Float64}\n\nCalculate RMS values for magnitude and phase coefficients (excluding piston).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.scale!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.scale!","text":"scale!(coeffs::ZernikeCoefficients, factor::Real) -> ZernikeCoefficients\n\nScale all coefficients (except piston) by given factor.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.significant_terms-2","page":"API Reference","title":"MicroscopePSFs.Zernike.significant_terms","text":"significant_terms(coeffs::ZernikeCoefficients, \n                 threshold::Real=0.01) -> Vector{Tuple{Int,Float64,Float64}}\n\nReturn list of significant terms: (index, magnitude, phase) above threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.trim!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.trim!","text":"trim!(coeffs::ZernikeCoefficients, threshold::Real) -> ZernikeCoefficients\n\nSet coefficients below threshold (relative to RMS) to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.unwrap_phase-Tuple{AbstractVector{<:Real}}","page":"API Reference","title":"MicroscopePSFs.Zernike.unwrap_phase","text":"unwrap_phase(phase::AbstractVector{<:Real}) -> Vector{Float64}\n\nUnwrap phase values to handle 2π discontinuities.\n\n\n\n\n\n","category":"method"},{"location":"conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"This page documents the conventions used throughout MicroscopePSFs.jl.","category":"page"},{"location":"conventions/#Coordinate-System","page":"Conventions","title":"Coordinate System","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"MicroscopePSFs.jl uses the following coordinate system conventions:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Physical units: All distances are in micrometers (μm)\nOrigin: The origin (0,0,0) is at the PSF center\nAxes:\nx-axis: Lateral direction (positive right)\ny-axis: Lateral direction (positive down)\nz-axis: Axial direction (positive away from objective)","category":"page"},{"location":"conventions/#Image-Coordinates","page":"Conventions","title":"Image Coordinates","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"When generating PSF images:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Images are returned as Julia matrices with indices [row, column]\nThis corresponds to [y, x] in the coordinate system\nThe first element [1, 1] is the top-left pixel","category":"page"},{"location":"conventions/#Normalization","page":"Conventions","title":"Normalization","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"PSF models use the following normalization conventions:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Intensity: PSF intensity is normalized to integrate to 1.0 over the entire domain\nAmplitude: Complex amplitudes are normalized such that |amplitude|² gives the normalized intensity\nGenerated images: PSF images are normalized to sum to 1.0 by default, unless specified otherwise","category":"page"},{"location":"conventions/#Parameters","page":"Conventions","title":"Parameters","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Common parameters across PSF models:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in micrometers (μm)\nn: Refractive index of the sample medium\nn_i: Refractive index of the immersion medium","category":"page"},{"location":"conventions/#Aberrations","page":"Conventions","title":"Aberrations","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Aberrations are represented using Zernike polynomials:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Zernike coefficients use the Noll indexing scheme by default\nCoefficients are specified in wavelength units\nPositive z (defocus) corresponds to increasing the optical path length\nNote that this is consistent with a sample moving away from the objective","category":"page"},{"location":"conventions/#Units","page":"Conventions","title":"Units","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Parameter Unit\nWavelength Micrometers (μm)\nPosition Micrometers (μm)\nPixel size Micrometers (μm)\nSigma Micrometers (μm)\nNA Dimensionless\nRefractive index Dimensionless\nZernike coefficients Wavelengths","category":"page"},{"location":"conventions/#Performance-Considerations","page":"Conventions","title":"Performance Considerations","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Array dimensions are typically ordered as [y, x] for 2D and [y, x, z] for 3D\nFor performance-critical code, provide pre-allocated arrays whenever possible\nPSF models are designed to be thread-safe for parallel evaluation","category":"page"},{"location":"conventions/#Type-Hierarchy","page":"Conventions","title":"Type Hierarchy","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The package uses the following type hierarchy structure:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"AbstractPSF\n├── Gaussian2D\n├── Airy2D\n├── Scalar3DPSF\n├── Vector3DPSF\n└── SplinePSF","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The Gaussian2D and Airy2D types are 2D PSF models, while Scalar3DPSF and Vector3DPSF are 3D PSF models. Each implements the appropriate methods for PSF evaluation in their respective dimensions.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"MicroscopePSFs.jl provides a consistent interface across all PSF types, making it easy to switch between different models with minimal code changes.","category":"page"},{"location":"interface/#Core-Interface","page":"Interface","title":"Core Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All PSF types implement the following core interface methods:","category":"page"},{"location":"interface/#PSF-Evaluation","page":"Interface","title":"PSF Evaluation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Evaluate PSF at specified position (call operator)\n(psf::AbstractPSF)(x, y)      # 2D evaluation\n(psf::AbstractPSF)(x, y, z)   # 3D evaluation\n\n# Get complex amplitude\namplitude(psf::AbstractPSF, x, y)      # 2D amplitude\namplitude(psf::AbstractPSF, x, y, z)   # 3D amplitude","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The coordinate system uses physical units (microns) with the origin at the PSF center.","category":"page"},{"location":"interface/#Pixel-Integration","page":"Interface","title":"Pixel Integration","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Create camera and emitter\n# Using constructor with pixel edges directly\npixel_edges_x = collect(0:0.1:2.0)  # Convert to Vector\npixel_edges_y = collect(0:0.1:2.0)  # Convert to Vector\ncamera = IdealCamera(pixel_edges_x, pixel_edges_y)  # 20x20 pixels, 100nm size\nemitter = Emitter2D(1.0, 1.0, 1000.0)               # At (1μm, 1μm) with 1000 photons\n\n# Generate realistic microscope image\npixels = integrate_pixels(psf, camera, emitter)\n\n# For complex amplitude integration\npixels_amplitude = integrate_pixels_amplitude(psf, camera, emitter)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The integrate_pixels function is the primary way to generate physically realistic microscope images, accounting for:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"PSF shape\nCamera pixel geometry\nEmitter position and intensity","category":"page"},{"location":"interface/#Working-with-PSFs","page":"Interface","title":"Working with PSFs","text":"","category":"section"},{"location":"interface/#Creating-PSF-Instances","page":"Interface","title":"Creating PSF Instances","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Each PSF type has its own constructor with parameters specific to that model. For example:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Create a Gaussian2D PSF with sigma=150nm\npsf_gaussian = Gaussian2D(0.15)\n\n# Create an Airy2D PSF with NA=1.4 and wavelength=532nm\npsf_airy = Airy2D(1.4, 0.532)\n\n# Create a Vector3D PSF with more parameters\n# Note: Create a dipole vector for the orientation (z-axis in this case)\ndipole_z = DipoleVector(0.0, 0.0, 1.0)  # Dipole along z-axis\npsf_vector = Vector3DPSF(\n    1.4,                # Numerical aperture\n    0.68,               # Wavelength in microns\n    dipole_z,           # Dipole orientation (along optical axis)\n    n_medium=1.33,      # Sample medium refractive index\n    n_immersion=1.518,  # Immersion medium refractive index\n    n_coverslip=1.518   # Coverslip refractive index\n)","category":"page"},{"location":"interface/#Using-the-Same-Code-with-Different-PSF-Models","page":"Interface","title":"Using the Same Code with Different PSF Models","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The common interface allows you to write generic code that works with any PSF type:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"function analyze_psf_width(psf::AbstractPSF)\n    # Generate intensity profile\n    x = range(-1, 1, length=100)\n    intensities = [psf(xi, 0.0) for xi in x]\n    \n    # Calculate FWHM or other properties\n    # ...\n    \n    return results\nend\n\n# Works with any PSF model that implements the 2D interface\n# Note: Vector3DPSF and Scalar3DPSF only support 3D evaluation with (x,y,z)\nresults_gaussian = analyze_psf_width(Gaussian2D(0.15))\nresults_airy = analyze_psf_width(Airy2D(1.4, 0.532))","category":"page"},{"location":"interface/#Example:-Visualizing-Different-PSF-Models","page":"Interface","title":"Example: Visualizing Different PSF Models","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"using MicroscopePSFs\nusing CairoMakie\n\n# Define position and image grid\nx = range(-1, 1, length=100)\ny = range(-1, 1, length=100)\n\n# Create different PSF models - using only 2D PSFs\n# Note: Vector3DPSF requires a dipole orientation\ndipole_z = DipoleVector(0.0, 0.0, 1.0)  # Dipole along z-axis (for reference)\npsfs = [\n    Gaussian2D(0.15),\n    Airy2D(1.4, 0.532)\n    # Scalar3DPSF only supports 3D interface with (x,y,z) and isn't included here\n    # Vector3DPSF only supports 3D interface and isn't included here\n]\ntitles = [\"Gaussian2D\", \"Airy2D\"]\n\n# Compute PSF intensity values\nintensity_values = [[psf(xi, yi) for yi in y, xi in x] for psf in psfs]\n\n# Create visualization\nfig = Figure(size=(1000, 800))\nfor (i, img) in enumerate(intensity_values)\n    ax = Axis(fig[div(i-1, 2)+1, mod(i-1, 2)+1], \n              aspect=DataAspect(),\n              title=titles[i],\n              xlabel=\"x (μm)\",\n              ylabel=\"y (μm)\")\n    hm = heatmap!(ax, x, y, img, colormap=:viridis)\n    Colorbar(fig[div(i-1, 2)+1, mod(i-1, 2)+3], hm)\nend\n\n# Display or save the figure\nfig","category":"page"},{"location":"interface/#Performance-Considerations","page":"Interface","title":"Performance Considerations","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The interface is designed to be both flexible and performant. For high-performance applications, consider:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Vectorizing operations when evaluating PSFs at multiple positions\nUsing SplinePSF to pre-compute complex PSFs for faster evaluation\nUsing the appropriate PSF model for your needs (simpler models are faster)","category":"page"},{"location":"psfs/vector3d/#Vector3DPSF","page":"Vector3D","title":"Vector3DPSF","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF model implements a comprehensive three-dimensional point spread function based on vectorial diffraction theory. It accounts for polarization effects, high-NA phenomena, dipole emission patterns, and arbitrary aberrations, providing the highest level of physical accuracy among the PSF models. This model is particularly important for high-NA objectives and applications where polarization effects cannot be ignored.","category":"page"},{"location":"psfs/vector3d/#Mathematical-Model","page":"Vector3D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF implements a full vectorial diffraction model based on the Richards-Wolf vector diffraction theory, accounting for dipole emission patterns, polarization effects, refractive index interfaces, and optical aberrations.","category":"page"},{"location":"psfs/vector3d/#Complete-PSF-Formula","page":"Vector3D","title":"Complete PSF Formula","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"PSF(x - x_i y - y_i z_i z_s) = sum_m=xy sum_n=p_x p_y p_z Fh(k_x k_y)w_mnA(k_x k_y)e^iota 2pi(k_x x_i+k_y y_i+k_zmathrmmed z_i-k_zmathrmimmz_s)^2","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Where:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"(x_i y_i z_i) is the emitter position where z_i represents the depth above the coverslip\nz_s is the distance the sample stage was moved away from the nominal focal plane at the coverslip \nF denotes the Fourier transform operation \nh(k_x k_y) is the complex pupil function incorporating aberrations \nw_mn represents the electric field components at the pupil plane from a fixed dipole and incorporates Fresnel coefficients \nA(k_x k_y) is the apodization factor for energy conservation \nk_zmathrmmed and k_zmathrmimm are the z-components of the wave vectors in the sample and immersion media respectively ","category":"page"},{"location":"psfs/vector3d/#Electric-Field-Components","page":"Vector3D","title":"Electric Field Components","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The vectorial field components w_mn at the pupil plane are calculated as:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"w_xn = P_n cos(phi) - S_n sin(phi)","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"w_yn = P_n sin(phi) + S_n cos(phi)","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Where phi is the angular component in the polar coordinate of the frequency space, and P_n and S_n are electric field components in p and s polarizations relative to the incident plane at the sample space:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"beginalign\nP_px = T_p cos theta_1 cos phi \nP_py = T_p cos theta_1 sin phi \nP_pz = -T_p sin theta_1 \nS_px = -T_s sin phi \nS_py = T_s cos phi \nS_pz = 0\nendalign","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Where P_x, P_y, P_z are the cartesian components of the dipole moments.","category":"page"},{"location":"psfs/vector3d/#Fresnel-Coefficients","page":"Vector3D","title":"Fresnel Coefficients","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The total transmission coefficients T_p and T_s for p- and s-polarized light account for the interfaces between different media (sample, coverslip, and immersion medium):","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"beginalign\nT_P = tau_P12 tau_P23 \nT_S = tau_S12 tau_S23\nendalign","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"With interface-specific Fresnel transmission coefficients:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"beginalign\ntau_Pij = frac2n_icostheta_in_icostheta_j + n_jcostheta_i \ntau_Sij = frac2n_icostheta_in_icostheta_i + n_jcostheta_j\nendalign","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Where n_i and theta_i are the refractive index and the light propagation angle in medium i, and the subscriptions 1, 2, 3 denote the sample medium, the coverslip, and the immersion medium.","category":"page"},{"location":"psfs/vector3d/#Apodization-Factor","page":"Vector3D","title":"Apodization Factor","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The apodization factor A(k_x k_y) maintains energy conservation across media interfaces:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"A(k_x k_y) = fracsqrtcostheta_mathrmimmcostheta_mathrmmed","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Where:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"costheta_mathrmmed = sqrt1 - frac(k_x^2 + k_y^2)lambda^24pi^2 n_mathrmmed^2","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"costheta_mathrmimm = sqrt1 - frac(k_x^2 + k_y^2)lambda^24pi^2 n_mathrmimm^2","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"This factor accounts for the change in solid angle that occurs during refraction, critical for accurately modeling high-NA systems.","category":"page"},{"location":"psfs/vector3d/#Wave-Vectors","page":"Vector3D","title":"Wave Vectors","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The z-components of the wave vectors in the different media are:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"k_zmathrmmed = sqrtfracn^2_mathrmmedlambda^2 - fracn^2_mathrmimmlambda^2sin^2 theta_mathrmimm","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"k_zmathrmimm = fracn_mathrmimmlambdacos theta_mathrmimm","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"When theta_mathrmimm exceeds the critical angle, k_zmathrmmed becomes imaginary, resulting in evanescent waves and giving rise to supercritical angle fluorescence (SAF) effects.","category":"page"},{"location":"psfs/vector3d/#Constructor-Options","page":"Vector3D","title":"Constructor Options","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Vector3DPSF(nₐ::Real, λ::Real, dipole::DipoleVector;\n            base_pupil::Union{Nothing, PupilFunction}=nothing,\n            base_zernike::Union{Nothing, ZernikeCoefficients}=nothing,\n            n_medium::Real=1.33,\n            n_coverslip::Real=1.52,\n            n_immersion::Real=1.52,\n            z_stage::Real=0.0, \n            grid_size::Integer=128)","category":"page"},{"location":"psfs/vector3d/#Required-Parameters","page":"Vector3D","title":"Required Parameters","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"nₐ: Numerical aperture of the objective\nwavelength: Wavelength of light in microns\ndipole: Dipole orientation vector specified using DipoleVector","category":"page"},{"location":"psfs/vector3d/#Optional-Parameters","page":"Vector3D","title":"Optional Parameters","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"base_pupil: Optional base aberration pupil function (default: none)\nbase_zernike: Zernike coefficients for aberrations (default: none)\nn_medium: Refractive index of the sample medium (default: 1.33, water)\nn_immersion: Refractive index of the immersion medium (default: 1.52, oil)\nn_coverslip: Refractive index of the coverslip (default: 1.52, glass)\nz_stage: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm) (default: 0.0)\ngrid_size: Size of grid for pupil function (default: 128)","category":"page"},{"location":"psfs/vector3d/#Type-Parameters","page":"Vector3D","title":"Type Parameters","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"T: Numeric precision type, automatically determined from input","category":"page"},{"location":"psfs/vector3d/#Basic-Usage","page":"Vector3D","title":"Basic Usage","text":"","category":"section"},{"location":"psfs/vector3d/#Creating-a-PSF","page":"Vector3D","title":"Creating a PSF","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create dipole vectors for different orientations\ndipole_x = DipoleVector(1.0, 0.0, 0.0)  # X-oriented dipole\ndipole_y = DipoleVector(0.0, 1.0, 0.0)  # Y-oriented dipole\ndipole_z = DipoleVector(0.0, 0.0, 1.0)  # Z-oriented dipole\ndipole_xy = DipoleVector(0.707, 0.707, 0.0)  # 45° in XY plane\n\n# Create a basic Vector3DPSF with Z-oriented dipole\npsf = Vector3DPSF(\n    1.4,                # Numerical aperture\n    0.532,              # Wavelength in microns\n    dipole_z,           # Z-oriented dipole\n    n_medium=1.33,      # Sample is water\n    n_immersion=1.52   # Immersion oil\n)\n\n# Create a PSF with aberrations\nzc = ZernikeCoefficients(15)\nadd_spherical!(zc, 0.5)  # Add 0.5 waves of spherical aberration\npsf_aberrated = Vector3DPSF(\n    1.4,\n    0.532,\n    dipole_z,\n    n_medium=1.33,\n    base_zernike=zc\n)","category":"page"},{"location":"psfs/vector3d/#Direct-Evaluation","page":"Vector3D","title":"Direct Evaluation","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Evaluate PSF at a specific 3D position\nx = 0.1  # μm\ny = 0.2  # μm\nz = 0.5  # μm (depth above the coverslip)\nintensity = psf(x, y, z)\n\n# Get complex vector field amplitude (returns [Ex, Ey])\nE_field = amplitude(psf, x, y, z)\nEx = E_field[1]  # X-component of electric field\nEy = E_field[2]  # Y-component of electric field\n\n# Calculate intensity manually if needed\nintensity_manual = abs2(Ex) + abs2(Ey)","category":"page"},{"location":"psfs/vector3d/#Creating-PSF-Images","page":"Vector3D","title":"Creating PSF Images","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create a grid of positions for a 2D slice at a specific z\nx = range(-1, 1, length=101)  # μm\ny = range(-1, 1, length=101)  # μm\nz = 0.0  # focal plane\n\n# Compute PSF values at each position\nintensity_2d = [psf(xi, yi, z) for yi in y, xi in x]\n\n# Visualize with CairoMakie\nusing CairoMakie\nfig = Figure(size=(600, 500))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Vector3DPSF (z=0μm, z-oriented dipole)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nhm = heatmap!(ax, x, y, intensity_2d, colormap=:viridis)\nColorbar(fig[1, 2], hm)\n\n# Compare different dipole orientations\npsf_x = Vector3DPSF(1.4, 0.532, dipole_x, n_medium=1.33)\npsf_y = Vector3DPSF(1.4, 0.532, dipole_y, n_medium=1.33)\npsf_z = Vector3DPSF(1.4, 0.532, dipole_z, n_medium=1.33)\n\nfig2 = Figure(size=(900, 300))\npsfs = [psf_x, psf_y, psf_z]\ntitles = [\"X-oriented dipole\", \"Y-oriented dipole\", \"Z-oriented dipole\"]\n\nfor (i, (p, title)) in enumerate(zip(psfs, titles))\n    ax = Axis(fig2[1, i], aspect=DataAspect(),\n              title=title,\n              xlabel=\"x (μm)\", ylabel=i==1 ? \"y (μm)\" : \"\")\n    img = [p(xi, yi, 0.0) for yi in y, xi in x]\n    heatmap!(ax, x, y, img, colormap=:viridis)\nend\nfig2","category":"page"},{"location":"psfs/vector3d/#Integration-with-Camera","page":"Vector3D","title":"Integration with Camera","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create camera with 100nm pixels (20×20 pixel grid)\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:20, 1:20, pixel_size)\n\n# Create 3D emitter at position (1μm, 1μm, 0.5μm) with 1000 photons\n# Note: z=0.5μm represents the depth above the coverslip\nemitter = Emitter3D(1.0, 1.0, 0.5, 1000.0)  # x, y, z (depth above coverslip), photons\n\n# Integrate PSF over pixels with 2×2 subsampling\npixels = integrate_pixels(psf, camera, emitter, sampling=2)\n\n# For dipole emitters, you can use the DipoleEmitter3D type\ndipole_emitter = DipoleEmitter3D(1.0, 1.0, 0.5, 1000.0, 0.0, 0.0, 1.0)  # x, y, z (depth above coverslip), photons, dx, dy, dz\n\n# Visualize the camera image\nusing CairoMakie\nfig = Figure(size=(500, 400))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Integrated Camera Image (z=0.5μm)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nax.yreversed = true  # Flip y-axis to match camera convention\n\n# Get physical coordinates of pixel centers\nx_centers = (1:20) * pixel_size - pixel_size/2\ny_centers = (1:20) * pixel_size - pixel_size/2\n\nhm = heatmap!(ax, x_centers, y_centers, pixels', colormap=:viridis)\nscatter!(ax, [emitter.x], [emitter.y], color=:red, marker=:cross, markersize=15)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/vector3d/#Aberration-Modeling","page":"Vector3D","title":"Aberration Modeling","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF supports the same aberration modeling capabilities as Scalar3DPSF:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create Zernike coefficients object with up to 21 terms\nzc = ZernikeCoefficients(21)\n\n# Add common aberrations\nadd_defocus!(zc, 1.0)           # 1 wave of defocus\nadd_astigmatism!(zc, 0.5, π/4)  # 0.5 waves of astigmatism at 45°\nadd_coma!(zc, 0.3)              # 0.3 waves of coma\nadd_spherical!(zc, 0.2)         # 0.2 waves of spherical aberration\n\n# Create PSF with these aberrations\npsf = Vector3DPSF(1.4, 0.532, dipole_z, n_medium=1.33, base_zernike=zc)\n\n# Update aberrations for an existing PSF\nadd_spherical!(psf.zernike_coeffs, 0.3)  # Add more spherical aberration\nupdate_pupils!(psf)  # Update the pupil function to reflect the changes","category":"page"},{"location":"psfs/vector3d/#Dipole-Orientations-and-Polarization","page":"Vector3D","title":"Dipole Orientations and Polarization","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF model allows for simulating different dipole orientations, which is crucial for applications like single-molecule orientation studies:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create PSFs for different dipole orientations\norientations = [\n    (\"X-oriented\", DipoleVector(1.0, 0.0, 0.0)),\n    (\"Y-oriented\", DipoleVector(0.0, 1.0, 0.0)),\n    (\"Z-oriented\", DipoleVector(0.0, 0.0, 1.0)),\n    (\"XY-plane 45°\", DipoleVector(0.707, 0.707, 0.0)),\n    (\"3D 45°\", DipoleVector(0.577, 0.577, 0.577))\n]\n\n# Compare how different orientations appear at different z positions\nz_positions = [-1.0, 0.0, 1.0]  # μm\nx = y = range(-1, 1, length=51)  # μm\n\nfig = Figure(size=(1200, 800))\n\nfor (i, (name, dipole)) in enumerate(orientations)\n    psf = Vector3DPSF(1.4, 0.532, dipole, n_medium=1.33)\n    \n    for (j, z) in enumerate(z_positions)\n        ax = Axis(fig[i, j], aspect=DataAspect(),\n                 title=j==1 ? name : \"z = $(z)μm\",\n                 xlabel=i==length(orientations) ? \"x (μm)\" : \"\",\n                 ylabel=j==1 ? \"y (μm)\" : \"\")\n                 \n        img = [psf(xi, yi, z) for yi in y, xi in x]\n        heatmap!(ax, x, y, img, colormap=:viridis)\n    end\nend\n\nfig","category":"page"},{"location":"psfs/vector3d/#Refractive-Index-Interfaces","page":"Vector3D","title":"Refractive Index Interfaces","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF model accounts for refractive index mismatches at the interfaces:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Compare different refractive index configurations\nconfigs = [\n    (\"Matched (water)\", 1.33, 1.33, 1.33),     # All water\n    (\"Oil immersion\", 1.33, 1.52, 1.52),    # Water sample, oil immersion\n    (\"Glycerol immersion\", 1.33, 1.47, 1.47)  # Water sample, glycerol immersion\n]\n\nfig = Figure(size=(900, 300))\n\nfor (i, (name, n_medium, n_coverslip, n_immersion)) in enumerate(configs)\n    psf = Vector3DPSF(\n        1.4, 0.532, dipole_z,\n        n_medium=n_medium,\n        n_coverslip=n_coverslip,\n        n_immersion=n_immersion\n    )\n    \n    ax = Axis(fig[1, i], aspect=DataAspect(),\n              title=name,\n              xlabel=\"x (μm)\", ylabel=i==1 ? \"y (μm)\" : \"\")\n              \n    img = [psf(xi, yi, 0.0) for yi in y, xi in x]\n    heatmap!(ax, x, y, img, colormap=:viridis)\nend\n\nfig","category":"page"},{"location":"psfs/vector3d/#Supercritical-Angle-Fluorescence","page":"Vector3D","title":"Supercritical Angle Fluorescence","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"A notable feature of the Vector3DPSF model is its ability to accurately capture Supercritical Angle Fluorescence (SAF), which occurs when light emitted by fluorophores near the coverslip is collected at angles exceeding the critical angle:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Compare SAF effect at different depths above the coverslip\nz_positions = [0.0, 0.1, 0.3, 0.5, 1.0]  # μm above coverslip\nx = y = range(-1, 1, length=51)  # μm\n\nfig = Figure(size=(1200, 300))\n\n# Create PSF with oil immersion (favorable for SAF)\npsf = Vector3DPSF(\n    1.4, 0.532, dipole_z,\n    n_medium=1.33,   # Water\n    n_immersion=1.52  # Oil\n)\n\nfor (i, z) in enumerate(z_positions)\n    ax = Axis(fig[1, i], aspect=DataAspect(),\n             title=\"z = $(z)μm above coverslip\",\n             xlabel=\"x (μm)\", \n             ylabel=i==1 ? \"y (μm)\" : \"\")\n             \n    # Evaluate PSF with emitter at specific depth above coverslip\n    img = [psf(xi, yi, z) for yi in y, xi in x]\n    hm = heatmap!(ax, x, y, img, colormap=:viridis)\n    \n    # Add radial profile\n    r = range(0, 1, length=50)\n    intensity = [psf(ri, 0.0, z) for ri in r]\n    lines!(ax, r, intensity .* 1.5, color=:red, linewidth=2)\nend\n\nfig","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"As the emitter moves away from the coverslip, you'll observe the SAF contribution decreasing, which appears as a change in both the total intensity and the shape of the PSF.","category":"page"},{"location":"psfs/vector3d/#Performance-Considerations","page":"Vector3D","title":"Performance Considerations","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF is the most computationally intensive model in MicroscopePSFs.jl:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Significantly slower than all other PSF models\nPerformance scales with the resolution of the pupil function (grid_size parameter)\nCalculating the vector pupils is computationally intensive but only needs to be done once\nFor performance-critical applications, consider creating a SplinePSF from a Vector3DPSF:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create a SplinePSF for faster repeated evaluations\nx_range = range(-2, 2, length=81)  # μm\ny_range = range(-2, 2, length=81)  # μm\nz_range = range(-2, 2, length=41)  # μm\n\n# This step is slow but only needs to be done once\nspline_psf = SplinePSF(psf, x_range, y_range, z_range)\n\n# Now evaluations are much faster\nintensity = spline_psf(0.1, 0.2, 0.3)","category":"page"},{"location":"psfs/vector3d/#Relationship-to-Other-PSFs","page":"Vector3D","title":"Relationship to Other PSFs","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF is related to other PSF models in the following ways:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Scalar3DPSF: Vector3DPSF reduces to Scalar3DPSF when polarization effects are negligible (low NA)\nAiry2D: For z=0 and low NA, the Vector3DPSF approaches the Airy pattern\nSplinePSF: For performance-critical applications, create a SplinePSF from a Vector3DPSF","category":"page"},{"location":"psfs/vector3d/#When-to-Use-Vector3DPSF","page":"Vector3D","title":"When to Use Vector3DPSF","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF model is recommended for:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"High-NA objectives (NA > 1.2)\nPolarization-sensitive applications\nApplications requiring dipole emission pattern modeling\nSystems with significant refractive index mismatches\nResearch requiring the highest level of physical accuracy\nStudies involving near-interface fluorescence effects like SAF","category":"page"},{"location":"psfs/overview/#PSF-Types-Overview","page":"Overview","title":"PSF Types Overview","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"MicroscopePSFs.jl provides several PSF (Point Spread Function) models with varying complexity, accuracy, and computational requirements. This page gives an overview of the available models and guidance on selecting the appropriate PSF for your application.","category":"page"},{"location":"psfs/overview/#PSF-Model-Comparison","page":"Overview","title":"PSF Model Comparison","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"PSF Type Parameters 2D/3D Aberrations Polarization Relative Speed\nGaussian2D σ 2D No No Fastest\nAiry2D NA, λ 2D No No Fast\nScalar3DPSF NA, λ, n 3D Yes No Moderate\nVector3DPSF NA, λ, dipole, n_medium, etc. 3D Yes Yes Slowest\nSplinePSF any 2D/3D Via source PSF Via source PSF Fast evaluation","category":"page"},{"location":"psfs/overview/#When-to-Use-Each-PSF-Type","page":"Overview","title":"When to Use Each PSF Type","text":"","category":"section"},{"location":"psfs/overview/#Gaussian2D","page":"Overview","title":"Gaussian2D","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Rapid prototyping and initial development\nSimple fitting algorithms where computational speed is critical\nApplications where physical accuracy is less important than performance\nEducational purposes demonstrating basic PSF concepts","category":"page"},{"location":"psfs/overview/#Airy2D","page":"Overview","title":"Airy2D","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Diffraction-limited 2D imaging simulations\nMore accurate 2D fitting that accounts for diffraction rings\nCases where you need a physically accurate model but don't need 3D capabilities\nApplications requiring a good balance between accuracy and speed","category":"page"},{"location":"psfs/overview/#Scalar3DPSF","page":"Overview","title":"Scalar3DPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"3D imaging simulations with moderate accuracy requirements\nModeling defocus, spherical aberration, and other aberrations\nApplications with moderate NA objectives (typically NA < 1.2)\nWhen you need 3D capabilities but polarization effects aren't critical","category":"page"},{"location":"psfs/overview/#Vector3DPSF","page":"Overview","title":"Vector3DPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"High-NA objectives (NA > 1.2)\nApplications where polarization effects matter\nModeling complex dipole emission patterns\nResearch requiring the highest physical accuracy\nSimulations with significant refractive index mismatches\nWhen you need to account for all types of optical aberrations","category":"page"},{"location":"psfs/overview/#SplinePSF","page":"Overview","title":"SplinePSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Accelerating computationally intensive PSF models\nUsing experimental PSF measurements from calibration beads\nPerformance-critical applications like real-time fitting\nCreating fast approximations of complex physical models","category":"page"},{"location":"psfs/overview/#Standard-Usage-Pattern","page":"Overview","title":"Standard Usage Pattern","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"All PSF types follow the same core interface, making it easy to switch between models:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"# Create a PSF (example with Airy2D)\npsf = Airy2D(1.4, 0.532)  # NA=1.4, λ=532nm\n\n# Evaluate at specific position\nintensity = psf(0.1, 0.2)  # at x=0.1μm, y=0.2μm\n\n# Get complex field amplitude\namp = amplitude(psf, 0.1, 0.2)\n\n# Create image grid\nx = y = range(-1, 1, length=101)  # μm\nimg = [psf(xi, yi) for yi in y, xi in x]\n\n# Camera integration example\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:20, 1:20, pixel_size)\nemitter = Emitter2D(1.0, 1.0, 1000.0)  # x, y, photons\npixels = integrate_pixels(psf, camera, emitter)","category":"page"},{"location":"psfs/overview/#Visual-Comparison","page":"Overview","title":"Visual Comparison","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Below is a comparison of the different PSF models using the same physical parameters:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"using MicroscopePSFs\nusing CairoMakie\n\nfunction compare_psf_profiles()\n    # Common parameters\n    na = 1.4\n    wavelength = 0.532  # μm\n    n = 1.518\n    \n    # Create consistent PSF instances\n    gaussian = Gaussian2D(0.22 * wavelength / na)\n    airy = Airy2D(na, wavelength)\n    scalar = Scalar3DPSF(na, wavelength, n)\n    \n    # Dipole for vector PSF (z-oriented)\n    dipole_z = DipoleVector(0.0, 0.0, 1.0)\n    vector = Vector3DPSF(na, wavelength, dipole_z, n_medium=n)\n    \n    # Define positions for profile\n    x = range(-1, 1, length=200)  # μm\n    y = 0.0\n    z = 0.0\n    \n    # Calculate profiles\n    gaussian_profile = [gaussian(xi, y) for xi in x]\n    airy_profile = [airy(xi, y) for xi in x]\n    scalar_profile = [scalar(xi, y, z) for xi in x]\n    vector_profile = [vector(xi, y, z) for xi in x]\n    \n    # Create figure\n    fig = Figure(size=(900, 700))\n    \n    # 1D profiles\n    ax1 = Axis(fig[1, 1:2], \n              xlabel=\"Position (μm)\", \n              ylabel=\"Normalized Intensity\",\n              title=\"PSF Intensity Profiles (y=0)\")\n    \n    lines!(ax1, x, gaussian_profile, label=\"Gaussian2D\", linewidth=2, color=:blue)\n    lines!(ax1, x, airy_profile, label=\"Airy2D\", linewidth=2, color=:red)\n    lines!(ax1, x, scalar_profile, label=\"Scalar3DPSF\", linewidth=2, color=:green)\n    lines!(ax1, x, vector_profile, label=\"Vector3DPSF\", linewidth=2, color=:purple)\n    \n    axislegend(ax1, position=:rt)\n    \n    # 2D images\n    x_grid = y_grid = range(-1, 1, length=101)  # μm\n    \n    # Calculate 2D images\n    gaussian_img = [gaussian(xi, yi) for yi in y_grid, xi in x_grid]\n    airy_img = [airy(xi, yi) for yi in y_grid, xi in x_grid]\n    scalar_img = [scalar(xi, yi, 0.0) for yi in y_grid, xi in x_grid]\n    vector_img = [vector(xi, yi, 0.0) for yi in y_grid, xi in x_grid]\n    \n    # Plot 2D images\n    psf_images = [gaussian_img, airy_img, scalar_img, vector_img]\n    titles = [\"Gaussian2D\", \"Airy2D\", \"Scalar3DPSF\", \"Vector3DPSF\"]\n    \n    for (i, (img, title)) in enumerate(zip(psf_images, titles))\n        ax = Axis(fig[2, i], aspect=DataAspect(), \n                 title=title,\n                 xlabel=\"x (μm)\", \n                 ylabel=i==1 ? \"y (μm)\" : \"\")\n        \n        hm = heatmap!(ax, x_grid, y_grid, img, colormap=:viridis)\n        Colorbar(fig[2, i+4], hm, label=\"Intensity\")\n    end\n    \n    return fig\nend\n\nfig = compare_psf_profiles()\nsave(\"psf_comparison.png\", fig)","category":"page"},{"location":"psfs/overview/#PSF-Conversion","page":"Overview","title":"PSF Conversion","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"The PSF types provide methods to convert between models where appropriate:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"# Convert Airy2D to Gaussian2D approximation\nairy = Airy2D(1.4, 0.532)\ngaussian = Gaussian2D(airy)  # Automatically uses appropriate σ\n\n# Convert Gaussian2D to equivalent Airy2D\ngaussian = Gaussian2D(0.15)\nairy = Airy2D(gaussian, λ=0.532)  # Need to specify wavelength","category":"page"},{"location":"psfs/overview/#Computational-Considerations","page":"Overview","title":"Computational Considerations","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"When selecting a PSF model, consider the trade-off between accuracy and computational cost:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Gaussian2D: Closed-form expression, extremely fast\nAiry2D: Uses Bessel functions, fast but more expensive than Gaussian\nScalar3DPSF: Requires numerical integration or pre-computation, moderate speed\nVector3DPSF: Most computationally intensive, especially with aberrations\nSplinePSF: Fast evaluation but requires initial computation or measurement","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"For performance-critical applications, consider using SplinePSF to pre-compute a more complex PSF model for faster repeated evaluations.","category":"page"},{"location":"#MicroscopePSFs.jl","page":"Home","title":"MicroscopePSFs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for simulating microscope point spread functions (PSFs).","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MicroscopePSFs.jl provides a flexible and performant framework for calculating microscope point spread functions (PSFs) using various models, from simple 2D Gaussians to full 3D vectorial models. The package is designed for use in single-molecule localization microscopy (SMLM) and other fields requiring accurate optical simulations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple PSF models: Gaussian2D, Airy2D, Scalar3DPSF, Vector3DPSF, and Spline PSFs\nCommon interface for all PSF types with function-call syntax psf(x, y, z)\nRealistic camera pixel integration with integrate_pixels(psf, camera, emitter)\nSupport for optical aberrations via Zernike polynomials\nGPU acceleration (for supported models)\nOptimized for performance in single-molecule fitting applications\nInteroperability with the broader Julia ecosystem","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MicroscopePSFs\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using MicroscopePSFs\nusing CairoMakie\n\n# Create a Gaussian2D PSF\npsf = Gaussian2D(0.15)  # σ = 150nm\n\n# Evaluate at a specific position\nintensity = psf(0.1, 0.2)  # Intensity at (x,y) = (0.1μm, 0.2μm)\n\n# Generate a PSF image\nx = range(-1, 1, length=101)  # μm\ny = range(-1, 1, length=101)  # μm\nimg = [psf(xi, yi) for yi in y, xi in x]\n\n# Visualize the PSF\nfig = Figure(size=(600, 500))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Gaussian PSF (σ=150nm)\",\n          xlabel=\"x (μm)\", \n          ylabel=\"y (μm)\")\nhm = heatmap!(ax, x, y, img, colormap=:viridis)\nColorbar(fig[1, 2], hm)\n\n# Create a simulated microscope image\npixel_edges_x = collect(0:0.1:2.0)  # Convert to Vector\npixel_edges_y = collect(0:0.1:2.0)  # Convert to Vector\ncamera = IdealCamera(pixel_edges_x, pixel_edges_y)  # 20x20 pixels, 100nm size\nemitter = Emitter2D(1.0, 1.0, 1000.0)               # At (1μm, 1μm) with 1000 photons\npixels = integrate_pixels(psf, camera, emitter)\n\n# Camera physical coordinates\nx_phys = (camera.pixel_edges_x[1:end-1] + camera.pixel_edges_x[2:end]) / 2\ny_phys = (camera.pixel_edges_y[1:end-1] + camera.pixel_edges_y[2:end]) / 2\n\n# Visualize the camera image\nax2 = Axis(fig[2, 1:2], aspect=DataAspect(),\n           title=\"Integrated Camera Image\",\n           xlabel=\"x (μm)\", \n           ylabel=\"y (μm)\")\nax2.yreversed = true  # Flip y axis to match camera convention\nhm2 = heatmap!(ax2, x_phys, y_phys, pixels', colormap=:viridis)\nscatter!(ax2, [emitter.x], [emitter.y], \n         color=:red, marker=:cross, markersize=15)\n\nfig","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the navigation menu for detailed documentation on interfaces, conventions, and specific PSF types.","category":"page"},{"location":"psfs/gaussian2d/#Gaussian2D","page":"Gaussian2D","title":"Gaussian2D","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D PSF model represents the microscope point spread function as an isotropic 2D Gaussian function. While this is a mathematical approximation rather than a physical model derived from diffraction theory, it works well for many applications and is computationally very efficient, making it an excellent choice for rapid prototyping and performance-critical algorithms.","category":"page"},{"location":"psfs/gaussian2d/#Mathematical-Model","page":"Gaussian2D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D PSF is defined as:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"I(x y) = frac12pisigma^2 expleft(-fracx^2 + y^22sigma^2right)","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"where:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"x y are coordinates in physical units (microns)\nsigma is the standard deviation in the same units","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"This function is normalized to integrate to 1 over the entire domain, which ensures energy conservation.","category":"page"},{"location":"psfs/gaussian2d/#Constructor-Options","page":"Gaussian2D","title":"Constructor Options","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"Gaussian2D(σ::Real)","category":"page"},{"location":"psfs/gaussian2d/#Parameters","page":"Gaussian2D","title":"Parameters","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"σ: Standard deviation in microns","category":"page"},{"location":"psfs/gaussian2d/#Type-Parameters","page":"Gaussian2D","title":"Type Parameters","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"T: Numeric precision type, automatically determined from input","category":"page"},{"location":"psfs/gaussian2d/#Basic-Usage","page":"Gaussian2D","title":"Basic Usage","text":"","category":"section"},{"location":"psfs/gaussian2d/#Creating-a-PSF","page":"Gaussian2D","title":"Creating a PSF","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"# Create a Gaussian PSF with 150nm standard deviation\npsf = Gaussian2D(0.15)\n\n# Create a Gaussian approximation of an Airy disk\nairy_psf = Airy2D(1.4, 0.532)  # NA=1.4, wavelength=532nm\ngaussian_approximation = Gaussian2D(airy_psf)  # Automatically sets appropriate σ","category":"page"},{"location":"psfs/gaussian2d/#Direct-Evaluation","page":"Gaussian2D","title":"Direct Evaluation","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"# Evaluate PSF at a specific position\nintensity = psf(0.1, 0.2)  # At position x=0.1μm, y=0.2μm\n\n# Get complex amplitude (returns sqrt of intensity for Gaussian)\namp = amplitude(psf, 0.1, 0.2)","category":"page"},{"location":"psfs/gaussian2d/#Creating-a-PSF-Image","page":"Gaussian2D","title":"Creating a PSF Image","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"# Create a grid of positions\nx = range(-1, 1, length=101)  # μm\ny = range(-1, 1, length=101)  # μm\n\n# Compute PSF values on the grid\nintensity_values = [psf(xi, yi) for yi in y, xi in x]\n\n# Visualize with CairoMakie\nusing CairoMakie\nfig = Figure(size=(600, 500))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Gaussian PSF (σ=150nm)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nhm = heatmap!(ax, x, y, intensity_values, colormap=:viridis)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/gaussian2d/#Integration-with-Camera","page":"Gaussian2D","title":"Integration with Camera","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"# Create camera with 100nm pixels (20×20 pixel grid)\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:20, 1:20, pixel_size)\n\n# Create emitter at position (1μm, 1μm) with 1000 photons\nemitter = Emitter2D(1.0, 1.0, 1000.0)\n\n# Integrate PSF over pixels with 2×2 subsampling\npixels = integrate_pixels(psf, camera, emitter, sampling=2)\n\n# Visualize the camera image\nusing CairoMakie\nfig = Figure(size=(500, 400))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Integrated Camera Image\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nax.yreversed = true  # Flip y-axis to match camera convention\n\n# Get physical coordinates of pixel centers\nx_centers = (1:20) * pixel_size .- pixel_size/2\ny_centers = (1:20) * pixel_size .- pixel_size/2\n\nhm = heatmap!(ax, x_centers, y_centers, pixels', colormap=:viridis)\nscatter!(ax, [emitter.x], [emitter.y], color=:red, marker=:cross, markersize=15)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/gaussian2d/#Relationship-to-Airy-Function","page":"Gaussian2D","title":"Relationship to Airy Function","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D model can approximate the Airy disk pattern using the empirical relationship:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"sigma approx 022 fraclambdatextNA","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"where λ is the wavelength and NA is the numerical aperture. This approximation works best near the center of the PSF and becomes less accurate at the edges where the Airy pattern has diffraction rings.","category":"page"},{"location":"psfs/gaussian2d/#Performance-Considerations","page":"Gaussian2D","title":"Performance Considerations","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D PSF is the most computationally efficient model available in MicroscopePSFs.jl, making it ideal for:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"Large-scale simulations with many PSFs\nReal-time applications\nInitial algorithm development and testing\nSMLM fitting algorithms where speed is critical","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The model uses a simple closed-form expression that can be evaluated very efficiently, with no need for numerical integration or special functions (unlike other PSF models).","category":"page"},{"location":"psfs/gaussian2d/#Limitations","page":"Gaussian2D","title":"Limitations","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"While computationally efficient, the Gaussian2D model has several limitations:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"No Diffraction Rings: It doesn't account for the diffraction rings that appear in real microscope PSFs\nNo Defocus Modeling: It can't model the effects of defocus or 3D imaging\nNo Aberrations: It doesn't account for optical aberrations\nSimplified Physics: It's a mathematical approximation rather than a model derived from physics\nLess Accurate at Edges: It diverges from physical PSFs at larger distances from the center","category":"page"},{"location":"psfs/gaussian2d/#Relationship-to-Other-PSFs","page":"Gaussian2D","title":"Relationship to Other PSFs","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D model is related to other PSF models in the following ways:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"Airy2D: The Gaussian2D can be created from an Airy2D using Gaussian2D(airy_psf) which will set σ appropriately\nAiry2D Conversion: A Gaussian2D can be converted to an approximate Airy2D using Airy2D(gaussian_psf, λ=wavelength)\n3D Models: The Gaussian2D can be viewed as an in-focus slice of a 3D Gaussian PSF model (though not directly provided by this package)","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"For applications requiring higher physical accuracy, consider using Airy2D, Scalar3DPSF, or Vector3DPSF models instead.","category":"page"},{"location":"psfs/scalar3d/#Scalar3DPSF","page":"Scalar3D","title":"Scalar3DPSF","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The Scalar3DPSF model implements a three-dimensional point spread function based on scalar diffraction theory. This model accounts for defocus and optical aberrations using a complex pupil function approach, providing a good balance between physical accuracy and computational efficiency. It is well-suited for 3D imaging applications where polarization effects aren't critical.","category":"page"},{"location":"psfs/scalar3d/#Mathematical-Model","page":"Scalar3D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The Scalar3DPSF uses the Fourier optics approach to calculate the complex field distribution:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"U(mathbfr) = int_pupil P(boldsymbolrho) e^i k boldsymbolrho cdot mathbfr dboldsymbolrho","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"where:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"U(mathbfr) is the complex field amplitude at position mathbfr = (x y z)\nP(boldsymbolrho) is the complex pupil function at pupil coordinates boldsymbolrho\nk = 2pi  lambda is the wave number\nThe intensity is calculated as I(mathbfr) = U(mathbfr)^2","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The pupil function can incorporate various aberrations, typically represented using Zernike polynomials.","category":"page"},{"location":"psfs/scalar3d/#Constructor-Options","page":"Scalar3D","title":"Constructor Options","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"Scalar3DPSF(na::Real, wavelength::Real, n::Real; \n            pupil::Union{Nothing, PupilFunction}=nothing,\n            pupil_data::Union{Nothing, AbstractMatrix}=nothing,\n            coeffs::Union{Nothing, ZernikeCoefficients}=nothing)","category":"page"},{"location":"psfs/scalar3d/#Required-Parameters","page":"Scalar3D","title":"Required Parameters","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in microns\nn: Refractive index of the medium","category":"page"},{"location":"psfs/scalar3d/#Optional-Parameters","page":"Scalar3D","title":"Optional Parameters","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"pupil: Pre-created PupilFunction instance\npupil_data: Complex matrix to initialize the pupil function\ncoeffs: ZernikeCoefficients instance for representing aberrations","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"You should provide exactly one of the optional parameters. If none are provided, an unaberrated pupil is created.","category":"page"},{"location":"psfs/scalar3d/#Type-Parameters","page":"Scalar3D","title":"Type Parameters","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"T: Numeric precision type, automatically determined from input","category":"page"},{"location":"psfs/scalar3d/#Basic-Usage","page":"Scalar3D","title":"Basic Usage","text":"","category":"section"},{"location":"psfs/scalar3d/#Creating-a-PSF","page":"Scalar3D","title":"Creating a PSF","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"# Create a basic unaberrated 3D PSF\npsf = Scalar3DPSF(1.4, 0.532, 1.518)  # NA=1.4, λ=532nm, n=1.518\n\n# Create a PSF with spherical aberration\nzc = ZernikeCoefficients(15)  # Up to 15th Zernike polynomial\nadd_spherical!(zc, 0.5)       # Add 0.5 waves of spherical aberration\npsf_aberrated = Scalar3DPSF(1.4, 0.532, 1.518, coeffs=zc)\n\n# Create a PSF with a pre-computed pupil function\npupil = PupilFunction(1.4, 0.532, 1.518, zernike_coeffs)\npsf_from_pupil = Scalar3DPSF(1.4, 0.532, 1.518, pupil=pupil)","category":"page"},{"location":"psfs/scalar3d/#Direct-Evaluation","page":"Scalar3D","title":"Direct Evaluation","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"# Evaluate PSF at a specific 3D position\nx = 0.1  # μm\ny = 0.2  # μm\nz = 0.5  # μm (distance from focal plane)\nintensity = psf(x, y, z)\n\n# Get complex amplitude\namp = amplitude(psf, x, y, z)","category":"page"},{"location":"psfs/scalar3d/#Creating-PSF-Images","page":"Scalar3D","title":"Creating PSF Images","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"# Create a grid of positions for a 2D slice at a specific z\nx = range(-1, 1, length=101)  # μm\ny = range(-1, 1, length=101)  # μm\nz = 0.0  # focal plane\n\n# Compute PSF values at each position\nintensity_2d = [psf(xi, yi, z) for yi in y, xi in x]\n\n# Visualize with CairoMakie\nusing CairoMakie\nfig = Figure(size=(600, 500))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Scalar3DPSF (z=0μm)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nhm = heatmap!(ax, x, y, intensity_2d, colormap=:viridis)\nColorbar(fig[1, 2], hm)\n\n# Create a 3D PSF stack\nz_stack = range(-2, 2, length=5)  # z positions in microns\nintensity_3d = Array{Float64}(undef, length(y), length(x), length(z_stack))\nfor (k, zi) in enumerate(z_stack)\n    for (j, yi) in enumerate(y)\n        for (i, xi) in enumerate(x)\n            intensity_3d[j, i, k] = psf(xi, yi, zi)\n        end\n    end\nend\n\n# Visualize z-stack slices\nfig2 = Figure(size=(800, 200))\nfor (i, zi) in enumerate(z_stack)\n    ax = Axis(fig2[1, i], aspect=DataAspect(),\n              title=\"z = $(zi)μm\",\n              xlabel=i==1 ? \"x (μm)\" : \"\",\n              ylabel=i==1 ? \"y (μm)\" : \"\")\n    heatmap!(ax, x, y, intensity_3d[:,:,i], colormap=:viridis)\nend\nfig2","category":"page"},{"location":"psfs/scalar3d/#Integration-with-Camera","page":"Scalar3D","title":"Integration with Camera","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"# Create camera with 100nm pixels (20×20 pixel grid)\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:20, 1:20, pixel_size)\n\n# Create 3D emitter at position (1μm, 1μm, 0.5μm) with 1000 photons\nemitter = Emitter3D(1.0, 1.0, 0.5, 1000.0)  # x, y, z, photons\n\n# Integrate PSF over pixels with 2×2 subsampling\npixels = integrate_pixels(psf, camera, emitter, sampling=2)\n\n# Visualize the camera image\nusing CairoMakie\nfig = Figure(size=(500, 400))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Integrated Camera Image (z=0.5μm)\",\n          xlabel=\"x (μm)\", ylabel=\"y (μm)\")\nax.yreversed = true  # Flip y-axis to match camera convention\n\n# Get physical coordinates of pixel centers\nx_centers = (1:20) * pixel_size - pixel_size/2\ny_centers = (1:20) * pixel_size - pixel_size/2\n\nhm = heatmap!(ax, x_centers, y_centers, pixels', colormap=:viridis)\nscatter!(ax, [emitter.x], [emitter.y], color=:red, marker=:cross, markersize=15)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"psfs/scalar3d/#Aberration-Modeling","page":"Scalar3D","title":"Aberration Modeling","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"One of the key features of the Scalar3DPSF model is its ability to incorporate optical aberrations through Zernike polynomials:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"# Create Zernike coefficients object with up to 15th term\nzc = ZernikeCoefficients(15)\n\n# Add common aberrations\nadd_defocus!(zc, 1.0)         # 1 wave of defocus\nadd_astigmatism!(zc, 0.5)     # 0.5 waves of astigmatism\nadd_coma!(zc, 0.3)            # 0.3 waves of coma\nadd_spherical!(zc, 0.2)       # 0.2 waves of spherical aberration\n\n# Create PSF with these aberrations\npsf = Scalar3DPSF(1.4, 0.532, 1.518, coeffs=zc)\n\n# Compare aberrated and unaberrated PSFs\npsf_unaberrated = Scalar3DPSF(1.4, 0.532, 1.518)\n\n# Create comparison images at different z positions\nz_positions = [-1.0, 0.0, 1.0]  # μm\nx = y = range(-1, 1, length=101)  # μm\n\nfig = Figure(size=(900, 600))\nfor (i, z) in enumerate(z_positions)\n    # Unaberrated PSF\n    ax1 = Axis(fig[1, i], aspect=DataAspect(),\n               title=\"Unaberrated (z=$(z)μm)\",\n               xlabel=\"x (μm)\", ylabel=i==1 ? \"y (μm)\" : \"\")\n    img1 = [psf_unaberrated(xi, yi, z) for yi in y, xi in x]\n    heatmap!(ax1, x, y, img1, colormap=:viridis)\n    \n    # Aberrated PSF\n    ax2 = Axis(fig[2, i], aspect=DataAspect(),\n               title=\"Aberrated (z=$(z)μm)\",\n               xlabel=\"x (μm)\", ylabel=i==1 ? \"y (μm)\" : \"\")\n    img2 = [psf(xi, yi, z) for yi in y, xi in x]\n    heatmap!(ax2, x, y, img2, colormap=:viridis)\nend\nfig","category":"page"},{"location":"psfs/scalar3d/#Performance-Considerations","page":"Scalar3D","title":"Performance Considerations","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The Scalar3DPSF model has the following performance characteristics:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"More computationally intensive than 2D models (Gaussian2D, Airy2D)\nSignificantly faster than the full vectorial model (Vector3DPSF)\nPerformance scales with the resolution of the pupil function\nComputing many PSF values at different positions is more efficient after pre-computing the pupil function\nFor performance-critical applications, consider creating a SplinePSF from a Scalar3DPSF","category":"page"},{"location":"psfs/scalar3d/#Limitations","page":"Scalar3D","title":"Limitations","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The Scalar3DPSF model has several limitations:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"No Polarization Effects: Doesn't account for polarization, which becomes significant at high NA (>1.2)\nSimplified Refractive Index Interfaces: Simplified treatment of refractive index interfaces\nScalar Approximation: Uses scalar diffraction theory instead of full vector theory\nModerate NA Assumption: Most accurate for moderate NA values and regions near the focal plane","category":"page"},{"location":"psfs/scalar3d/#Relationship-to-Other-PSFs","page":"Scalar3D","title":"Relationship to Other PSFs","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The Scalar3DPSF is related to other PSF models in the following ways:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"Airy2D: The in-focus (z=0) slice of an unaberrated Scalar3DPSF is equivalent to the Airy pattern\nVector3DPSF: The Scalar3DPSF is a simplified version of Vector3DPSF that doesn't account for polarization effects\nSplinePSF: For performance-critical applications, a Scalar3DPSF can be converted to a SplinePSF","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"For applications requiring higher physical accuracy with high-NA objectives, consider using the Vector3DPSF model.","category":"page"}]
}
