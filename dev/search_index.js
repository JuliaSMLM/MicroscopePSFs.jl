var documenterSearchIndex = {"docs":
[{"location":"psfs/scalarpsf/#ScalarPSF","page":"ScalarPSF","title":"ScalarPSF","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"The ScalarPSF model implements a three-dimensional point spread function based on scalar diffraction theory. This model accounts for defocus and optical aberrations using a complex pupil function approach, providing a good balance between physical accuracy and computational efficiency.","category":"page"},{"location":"psfs/scalarpsf/#Mathematical-Model","page":"ScalarPSF","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"The ScalarPSF uses the Fourier optics approach to calculate the complex field distribution:","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"U(mathbfr) = int_pupil P(boldsymbolrho) e^i k boldsymbolrho cdot mathbfr dboldsymbolrho","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"where:","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"U(mathbfr) is the complex field amplitude at position mathbfr = (x y z)\nP(boldsymbolrho) is the complex pupil function at pupil coordinates boldsymbolrho\nk = 2pi  lambda is the wave number\nThe intensity is calculated as I(mathbfr) = U(mathbfr)^2","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"The pupil function can incorporate various aberrations, typically represented using Zernike polynomials.","category":"page"},{"location":"psfs/scalarpsf/#Constructor-and-Parameters","page":"ScalarPSF","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"ScalarPSF(na::Real, wavelength::Real, n::Real; \n         pupil::Union{Nothing, PupilFunction}=nothing,\n         pupil_data::Union{Nothing, AbstractMatrix}=nothing,\n         coeffs::Union{Nothing, ZernikeCoefficients}=nothing)","category":"page"},{"location":"psfs/scalarpsf/#Required-Parameters","page":"ScalarPSF","title":"Required Parameters","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in microns\nn: Refractive index of the medium","category":"page"},{"location":"psfs/scalarpsf/#Optional-Parameters","page":"ScalarPSF","title":"Optional Parameters","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"pupil: Pre-created PupilFunction instance\npupil_data: Complex matrix to initialize the pupil function\ncoeffs: ZernikeCoefficients instance for representing aberrations","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"You should provide exactly one of the optional parameters. If none are provided, an unaberrated pupil is created.","category":"page"},{"location":"psfs/scalarpsf/#Key-Features","page":"ScalarPSF","title":"Key Features","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"3D Imaging: Models PSF behavior throughout 3D space, not just in focus\nAberration Modeling: Supports arbitrary optical aberrations via Zernike polynomials\nComplex Field: Provides access to both amplitude and phase information\nPhysical Realism: Based on physical principles of scalar diffraction theory","category":"page"},{"location":"psfs/scalarpsf/#Aberration-Modeling","page":"ScalarPSF","title":"Aberration Modeling","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"A key feature of the ScalarPSF is its ability to incorporate optical aberrations:","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"# Create Zernike coefficients object\nzc = ZernikeCoefficients(15)  # Up to 15th Zernike polynomial\n\n# Add common aberrations\nadd_defocus!(zc, 1.0)         # 1 wave of defocus\nadd_astigmatism!(zc, 0.5)     # 0.5 waves of astigmatism\nadd_coma!(zc, 0.3)            # 0.3 waves of coma\nadd_spherical!(zc, 0.2)       # 0.2 waves of spherical aberration\n\n# Create PSF with these aberrations\npsf = ScalarPSF(1.4, 0.532, 1.518, coeffs=zc)","category":"page"},{"location":"psfs/scalarpsf/#Examples","page":"ScalarPSF","title":"Examples","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"Creating a Scalar3DPSF:","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"# Create a basic unaberrated 3D PSF\npsf = ScalarPSF(1.4, 0.532, 1.518)  # NA=1.4, λ=532nm, n=1.518\n\n# Create a PSF with spherical aberration\nzc = ZernikeCoefficients(15)  # Up to 15th Zernike polynomial\nadd_spherical!(zc, 0.5)       # Add 0.5 waves of spherical aberration\npsf_aberrated = ScalarPSF(1.4, 0.532, 1.518, coeffs=zc)\n\n# Create a PSF with a pre-computed pupil function\npupil = PupilFunction(1.4, 0.532, 1.518, zernike_coeffs)\npsf_from_pupil = ScalarPSF(1.4, 0.532, 1.518, pupil=pupil)","category":"page"},{"location":"psfs/scalarpsf/#Limitations","page":"ScalarPSF","title":"Limitations","text":"","category":"section"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"No Polarization Effects: Doesn't account for polarization, which becomes significant at high NA (>1.2)\nSimplified Refractive Index Interfaces: Simplified treatment of refractive index interfaces\nScalar Approximation: Uses scalar diffraction theory instead of full vector theory\nModerate NA Assumption: Most accurate for moderate NA values and regions near the focal plane","category":"page"},{"location":"psfs/scalarpsf/","page":"ScalarPSF","title":"ScalarPSF","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"MicroscopePSFs.jl provides a consistent interface across all PSF types, making it easy to switch between different models with minimal code changes.","category":"page"},{"location":"interface/#Core-Interface","page":"Interface","title":"Core Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All PSF types implement the following core interface methods:","category":"page"},{"location":"interface/#PSF-Evaluation","page":"Interface","title":"PSF Evaluation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Evaluate PSF at specified position (call operator)\n(psf::AbstractPSF)(x, y)      # 2D evaluation\n(psf::AbstractPSF)(x, y, z)   # 3D evaluation\n\n# Get complex amplitude\namplitude(psf::AbstractPSF, x, y)      # 2D amplitude\namplitude(psf::AbstractPSF, x, y, z)   # 3D amplitude","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The coordinate system uses physical units (microns) with the origin at the PSF center.","category":"page"},{"location":"interface/#Pixel-Integration","page":"Interface","title":"Pixel Integration","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Create camera and emitter\ncamera = IdealCamera(20, 20, 0.1)  # 20x20 pixels, 100nm pixel size\nemitter = Emitter2D(1.0, 1.0, 1000.0)  # At (1μm, 1μm) with 1000 photons\n\n# Generate realistic microscope image\npixels = integrate_pixels(psf, camera, emitter)\n\n# For complex amplitude integration\npixels_amplitude = integrate_pixels_amplitude(psf, camera, emitter)\n\n# Optional parameters\npixels = integrate_pixels(psf, camera, emitter; \n                         support=0.5,    # 0.5μm radius around emitter\n                         sampling=2,     # 2×2 subpixel sampling\n                         threaded=true)  # Use multithreading","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The integrate_pixels function is the primary way to generate physically realistic microscope images, accounting for:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"PSF shape\nCamera pixel geometry\nEmitter position and intensity","category":"page"},{"location":"interface/#Optional-Parameters","page":"Interface","title":"Optional Parameters","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All integration functions accept these optional parameters:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Support Region (support): Limits calculations to regions where the PSF has significant contribution\n# Calculate only within a radius of 0.5μm around the emitter\npixels = integrate_pixels(psf, camera, emitter, support=0.5)\n\n# Or specify an explicit region\nregion = (-1.0, 1.0, -1.0, 1.0)  # (x_min, x_max, y_min, y_max) in μm\npixels = integrate_pixels(psf, camera, emitter, support=region)\nSub-pixel Sampling (sampling): Controls integration accuracy\n# Use 4×4 sampling grid within each pixel for higher accuracy\npixels = integrate_pixels(psf, camera, emitter, sampling=4)\nThreading (threaded): Controls parallelization\n# Disable multithreading (necessary for automatic differentiation)\npixels = integrate_pixels(psf, camera, emitter, threaded=false)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The support parameter optimization is particularly valuable for multi-emitter simulations. The threading parameter is important when using these functions with automatic differentiation frameworks.","category":"page"},{"location":"interface/#Multi-Emitter-Simulation","page":"Interface","title":"Multi-Emitter Simulation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All PSF types support simulating images with multiple emitters:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Create multiple emitters\nemitters = [\n    Emitter2D(1.0, 1.0, 1000.0),\n    Emitter2D(1.5, 1.2, 800.0)\n]\n\n# Generate camera image with all emitters\npixels = integrate_pixels(psf, camera, emitters)\n\n# Use support region for efficiency\npixels = integrate_pixels(psf, camera, emitters, support=0.5)\n\n# Disable threading if using with automatic differentiation\npixels = integrate_pixels(psf, camera, emitters, threaded=false)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"For incoherent emitters (typical fluorescence), intensities are summed. For coherent simulations, use integrate_pixels_amplitude.","category":"page"},{"location":"interface/#Working-with-PSFs","page":"Interface","title":"Working with PSFs","text":"","category":"section"},{"location":"interface/#Creating-PSF-Instances","page":"Interface","title":"Creating PSF Instances","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Each PSF type has its own constructor with parameters specific to that model. For example:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Create a GaussianPSF with sigma=150nm\npsf_gaussian = GaussianPSF(0.15)\n\n# Create an AiryPSF with NA=1.4 and wavelength=532nm\npsf_airy = AiryPSF(1.4, 0.532)\n\n# Create a VectorPSF with more parameters\n# Note: Create a dipole vector for the orientation (z-axis in this case)\ndipole_z = DipoleVector(0.0, 0.0, 1.0)  # Dipole along z-axis\npsf_vector = VectorPSF(\n    1.4,                # Numerical aperture\n    0.68,               # Wavelength in microns\n    dipole_z,           # Dipole orientation (along optical axis)\n    n_medium=1.33,      # Sample medium refractive index\n    n_immersion=1.518,  # Immersion medium refractive index\n    n_coverslip=1.518   # Coverslip refractive index\n)","category":"page"},{"location":"interface/#Using-the-Same-Code-with-Different-PSF-Models","page":"Interface","title":"Using the Same Code with Different PSF Models","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The common interface allows you to write generic code that works with any PSF type:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"function analyze_psf_width(psf::AbstractPSF)\n    # Generate intensity profile\n    x = range(-1, 1, length=100)\n    intensities = [psf(xi, 0.0) for xi in x]\n    \n    # Calculate FWHM or other properties\n    # ...\n    \n    return results\nend\n\n# Works with any PSF model that implements the 2D interface\n# Note: VectorPSF and ScalarPSF only support 3D evaluation with (x,y,z)\nresults_gaussian = analyze_psf_width(GaussianPSF(0.15))\nresults_airy = analyze_psf_width(AiryPSF(1.4, 0.532))","category":"page"},{"location":"interface/#Performance-Considerations","page":"Interface","title":"Performance Considerations","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The interface is designed to be both flexible and performant. For high-performance applications, consider:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Using the support parameter to limit calculations to relevant regions\nUsing SplinePSF to pre-compute complex PSFs for faster evaluation \nSelecting the appropriate PSF model for your needs (simpler models are faster)","category":"page"},{"location":"interface/#Automatic-Differentiation-Compatibility","page":"Interface","title":"Automatic Differentiation Compatibility","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"When using MicroscopePSFs.jl with automatic differentiation (AD) frameworks like Zygote or ForwardDiff:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Disable threading for AD compatibility\npixels = integrate_pixels(psf, camera, emitter, threaded=false)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Most AD frameworks do not support multithreading, so this parameter allows you to disable it when needed while maintaining threading performance in standard use cases.","category":"page"},{"location":"zernike/#Zernike-Polynomials","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"The Zernike module provides tools for working with Zernike polynomials, which are commonly used to represent optical aberrations in microscopy PSF models.","category":"page"},{"location":"zernike/#Conventions","page":"Zernike Polynomials","title":"Conventions","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"This module uses the following conventions:","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"Noll Indexing: All functions use the Noll single-index scheme, starting from 1\nRMS Normalization: Polynomials are normalized to have RMS = 1 over the unit circle\nUnits: Coefficients typically represent wavefront error in units of wavelength","category":"page"},{"location":"zernike/#Core-Types","page":"Zernike Polynomials","title":"Core Types","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"The ZernikeCoefficients type is the main container for Zernike polynomial coefficients, used to represent both phase and amplitude aberrations:","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"# Create coefficients for 15 Zernike terms\nzc = ZernikeCoefficients(15)\n\n# Access and modify directly using Noll indices\nzc.phase[4] = 0.5  # Add 0.5λ RMS of defocus\nzc.phase[11] = 0.2  # Add 0.2λ RMS of spherical aberration","category":"page"},{"location":"zernike/#Core-Functions","page":"Zernike Polynomials","title":"Core Functions","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"The Zernike module provides several core functions for working with Zernike polynomials:","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"zernikepolynomial(n, l, ρ, θ): Compute the Zernike polynomial with radial order n and azimuthal frequency l at polar coordinates (ρ, θ)\nradialpolynomial(n, m, ρ): Compute just the radial component of a Zernike polynomial\nevaluate_pupil(coeffs, grid_size): Generate a complex pupil function from Zernike coefficients","category":"page"},{"location":"zernike/#Analysis-Functions","page":"Zernike Polynomials","title":"Analysis Functions","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"Additional utility functions for analyzing Zernike coefficients include:","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"rms(coeffs): Calculate RMS values for magnitude and phase coefficients (excluding piston)\nsignificant_terms(coeffs, threshold): Return list of significant terms above a threshold","category":"page"},{"location":"zernike/#Index-Conversion","page":"Zernike Polynomials","title":"Index Conversion","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"Functions for converting between different Zernike indexing schemes:","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"noll2nl(j): Convert from Noll single index to (n,l) indices\nnl2noll(n, l): Convert from (n,l) indices to Noll single index\nnoll2osa(j): Convert from Noll to OSA/ANSI index\nosa2noll(j): Convert from OSA/ANSI to Noll index\nnl2osa(n, l): Convert from (n,l) indices to OSA/ANSI single index\nosa2nl(j): Convert from OSA/ANSI single index to (n,l) indices","category":"page"},{"location":"zernike/#Common-Zernike-Polynomials","page":"Zernike Polynomials","title":"Common Zernike Polynomials","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"The table below shows the relationship between Noll indices, (n,l) pairs, and common aberration names:","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"Noll (j) Radial (n) Azimuthal (l) Common Name\n1 0 0 Piston\n2 1 1 Tip (X-Tilt)\n3 1 -1 Tilt (Y-Tilt)\n4 2 0 Defocus\n5 2 -2 Oblique Astigmatism\n6 2 2 Vertical Astigmatism\n7 3 -1 Vertical Coma\n8 3 1 Horizontal Coma\n9 3 -3 Vertical Trefoil\n10 3 3 Oblique Trefoil\n11 4 0 Primary Spherical\n12 4 2 Vertical Secondary Astigmatism\n13 4 -2 Oblique Secondary Astigmatism\n14 4 4 Vertical Quadrafoil\n15 4 -4 Oblique Quadrafoil","category":"page"},{"location":"zernike/#Visualizing-Zernike-Polynomials","page":"Zernike Polynomials","title":"Visualizing Zernike Polynomials","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"using MicroscopePSFs.Zernike\nusing CairoMakie\nfunction evaluate_polynomial_grid_nl(n::Integer, l::Integer, grid_size::Integer=201)\n    j = nl2noll(n, l)\n    coeffs = ZernikeCoefficients(j)\n    coeffs.mag[1] = 0.0 # was set to 1 by default\n    coeffs.mag[j] = 1.0\n    field = evaluate_pupil(coeffs, grid_size)\n    result = real.(field)\n    return result\nend\n\nfunction plot_zernike_nl_grid(max_n::Integer=4)\n    fig = Figure(size=(1000, 180 * max_n))\n    burd = reverse(cgrad(:RdBu))\n\n    for n in 0:max_n\n        l_start = -n + (mod(-n, 2) != mod(n, 2) ? 1 : 0)\n        l_values = l_start:2:n\n        row = n + 1\n        for (col_idx, l) in enumerate(l_values)\n            j = nl2noll(n, l)\n            ax = Axis(fig[row, col_idx],\n                aspect=DataAspect(),\n                title=\"j=$j, (n=$n, l=$l)\",\n                xticklabelsize=0,\n                yticklabelsize=0,\n                yreversed=false)\n            z_data = evaluate_polynomial_grid_nl(n, l, 201)\n            max_val = maximum(abs.(z_data))\n            min_val = -max_val\n            heatmap!(ax, range(-1, 1, length=size(z_data, 1)),\n                range(-1, 1, length=size(z_data, 2)),\n                z_data',\n                colorrange=(min_val, max_val),\n                colormap=burd)\n            hidedecorations!(ax)\n        end\n    end\n    return fig\nend\nfig = plot_zernike_nl_grid(5)\nsave(\"zernike_polys.png\",fig)","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"(Image: )","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"This visualization shows the first 21 Zernike polynomials laid out in a grid. Each plot is labeled with both its Noll index j and the corresponding (n,l) indices. Red regions represent positive values, blue regions represent negative values, and white represents zero. Posiive y axis is up to match Wikipedia. ","category":"page"},{"location":"zernike/#Usage-in-PSF-Models","page":"Zernike Polynomials","title":"Usage in PSF Models","text":"","category":"section"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"The Zernike module is primarily used for representing aberrations in PSF models:","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"# Create Zernike coefficients with 15 terms\nzc = ZernikeCoefficients(15)\n\n# Add some aberrations\nzc.phase[4] = 0.5  # 0.5λ RMS of defocus\nzc.phase[11] = 0.2  # 0.2λ RMS of spherical aberration\n\n# Create a ScalarPSF with these aberrations\npsf = ScalarPSF(1.4, 0.532, 1.518, coeffs=zc)\n\n# Create a VectorPSF with these aberrations\nvector_psf = VectorPSF(1.4, 0.532, base_zernike=zc, n_medium=1.33)","category":"page"},{"location":"zernike/","page":"Zernike Polynomials","title":"Zernike Polynomials","text":"For a full API reference and details on all available functions, see the API Reference section.","category":"page"},{"location":"psfs/splinepsf/#SplinePSF","page":"SplinePSF","title":"SplinePSF","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"The SplinePSF model provides an efficient representation of point spread functions using B-spline interpolation. Unlike other PSF models that are based on physical principles, SplinePSF is a computational acceleration technique that can significantly speed up PSF evaluations for complex models, or represent experimentally measured PSFs.","category":"page"},{"location":"psfs/splinepsf/#Mathematical-Model","page":"SplinePSF","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"The SplinePSF uses B-spline interpolation to rapidly evaluate a pre-computed PSF grid:","category":"page"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"I(x y z) = sum_ijk c_ijk beta^n(x - x_i) beta^n(y - y_j) beta^n(z - z_k)","category":"page"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"where:","category":"page"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"c_ijk are the B-spline coefficients\nbeta^n is the B-spline basis function of order n (typically cubic, n=3)\nx_i y_j z_k are the knot points of the spline","category":"page"},{"location":"psfs/splinepsf/#Constructor-Options","page":"SplinePSF","title":"Constructor Options","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"SplinePSF offers several constructor methods for different use cases:","category":"page"},{"location":"psfs/splinepsf/#From-Another-PSF-Model-(Most-Common)","page":"SplinePSF","title":"From Another PSF Model (Most Common)","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"# 3D PSF\nSplinePSF(psf::AbstractPSF, \n          x_range::AbstractRange,\n          y_range::AbstractRange,\n          z_range::AbstractRange;\n          order::Integer=3)\n\n# 2D PSF\nSplinePSF(psf::AbstractPSF, \n          x_range::AbstractRange,\n          y_range::AbstractRange;\n          order::Integer=3)","category":"page"},{"location":"psfs/splinepsf/#From-Pre-computed-PSF-Data","page":"SplinePSF","title":"From Pre-computed PSF Data","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"# From 3D PSF stack\nSplinePSF(psf_stack::AbstractArray{<:Real,3}, \n          x_range::AbstractRange,\n          y_range::AbstractRange,\n          z_range::AbstractRange;\n          order::Integer=3)\n\n# From 2D PSF image\nSplinePSF(psf_image::AbstractArray{<:Real,2}, \n          x_range::AbstractRange,\n          y_range::AbstractRange;\n          order::Integer=3)","category":"page"},{"location":"psfs/splinepsf/#Convenience-Constructor-with-Auto-ranges","page":"SplinePSF","title":"Convenience Constructor with Auto-ranges","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"SplinePSF(psf::AbstractPSF; \n          lateral_range::Float64=2.0,\n          axial_range::Float64=1.0,\n          lateral_step::Float64=0.05,\n          axial_step::Float64=0.1,\n          order::Integer=3)","category":"page"},{"location":"psfs/splinepsf/#Parameters","page":"SplinePSF","title":"Parameters","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"psf: Source PSF to sample or pre-computed PSF data\nx_range, y_range, z_range: Coordinate ranges for the grid points\norder: Interpolation order (default: 3 for cubic B-splines)\nlateral_range: Half-width of lateral (xy) sampling range in microns\naxial_range: Half-width of axial (z) sampling range in microns\nlateral_step: Step size in microns for lateral sampling\naxial_step: Step size in microns for axial sampling","category":"page"},{"location":"psfs/splinepsf/#Key-Features","page":"SplinePSF","title":"Key Features","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"Performance Acceleration: Significantly faster evaluation of complex PSFs\nExperimental PSF Support: Can represent measured PSF data from calibration beads\nSmooth Interpolation: Cubic splines provide continuous second derivatives\nFlexible Precision: Trade-off between accuracy and speed via grid density","category":"page"},{"location":"psfs/splinepsf/#B-Spline-Interpolation-Orders","page":"SplinePSF","title":"B-Spline Interpolation Orders","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"The SplinePSF uses different interpolation orders with specific trade-offs:","category":"page"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"Order Name Properties Use Case\n0 Constant Simple nearest neighbor, no continuity Very fast, low accuracy\n1 Linear Continuous function, discontinuous derivatives Good compromise\n3 Cubic Continuous second derivatives Best accuracy (default)","category":"page"},{"location":"psfs/splinepsf/#Examples","page":"SplinePSF","title":"Examples","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"Creating a SplinePSF:","category":"page"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"# Create a source PSF to accelerate\nscalar_psf = ScalarPSF(1.4, 0.532, 1.518)\n\n# Define coordinate sampling grid\nx_range = y_range = range(-2.0, 2.0, step=0.1)  # μm, 0.1μm step size\nz_range = range(-2.0, 2.0, step=0.2)  # μm, 0.2μm step size\n\n# Create a spline representation (this step may take time)\nspline_psf = SplinePSF(scalar_psf, x_range, y_range, z_range)\n\n# Alternative: use the convenience constructor with auto-ranges\nspline_psf_auto = SplinePSF(scalar_psf, \n                           lateral_range=2.0, \n                           axial_range=1.0,\n                           lateral_step=0.1, \n                           axial_step=0.2)","category":"page"},{"location":"psfs/splinepsf/#Performance-Considerations","page":"SplinePSF","title":"Performance Considerations","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"Initial Construction: Creating the SplinePSF can be slow for complex source PSFs\nEvaluation Speed: Once created, evaluation is very fast (typically 10-100× faster than source PSF)\nMemory Usage: Memory scales with grid size (O(nx×ny×nz))\nInterpolation Order: Higher order provides more accuracy at slight computational cost\nBoundary Handling: Returns 0 for positions outside the grid boundaries","category":"page"},{"location":"psfs/splinepsf/#Working-with-Experimental-PSFs","page":"SplinePSF","title":"Working with Experimental PSFs","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"SplinePSF can be used with experimentally measured PSF data:","category":"page"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"# Define physical coordinates for the experimental PSF\npixel_size = 0.1  # μm in the image\nz_step = 0.2      # μm between z-planes\nmeasured_psf = load_experimental_psf(\"path/to/measured_psf.h5\")\n\n# Create coordinate ranges\nnx, ny, nz = size(measured_psf)\nx_center = nx ÷ 2\ny_center = ny ÷ 2\nz_center = nz ÷ 2\n\nx_range = range(-(x_center) * pixel_size, (nx-x_center-1) * pixel_size, length=nx)\ny_range = range(-(y_center) * pixel_size, (ny-y_center-1) * pixel_size, length=ny)\nz_range = range(-(z_center) * z_step, (nz-z_center-1) * z_step, length=nz)\n\n# Create the SplinePSF\nexperimental_psf = SplinePSF(measured_psf, x_range, y_range, z_range)","category":"page"},{"location":"psfs/splinepsf/#Limitations","page":"SplinePSF","title":"Limitations","text":"","category":"section"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"Sampling Range: Limited to positions within the sampled grid range\nMemory Requirements: Can use significant memory for large, dense grids\nInitial Computation: Requires upfront computation time to create\nNo Physics Propagation: Cannot directly model physical effects not in the source PSF\nPhase Information: Limited phase accuracy in complex field representation","category":"page"},{"location":"psfs/splinepsf/","page":"SplinePSF","title":"SplinePSF","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page provides a comprehensive reference of the types and functions in MicroscopePSFs.jl.","category":"page"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These types and functions form the core public API of MicroscopePSFs.jl.","category":"page"},{"location":"api/#PSF-Types","page":"API Reference","title":"PSF Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractPSF","category":"page"},{"location":"api/#MicroscopePSFs.AbstractPSF","page":"API Reference","title":"MicroscopePSFs.AbstractPSF","text":"AbstractPSF\n\nAbstract base type for all Point Spread Functions\n\n\n\n\n\n","category":"type"},{"location":"api/#2D-PSF-Models","page":"API Reference","title":"2D PSF Models","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"GaussianPSF\nAiryPSF","category":"page"},{"location":"api/#MicroscopePSFs.GaussianPSF","page":"API Reference","title":"MicroscopePSFs.GaussianPSF","text":"GaussianPSF{T<:AbstractFloat} <: Abstract2DPSF{T}\n\nIsotropic 2D Gaussian PSF.\n\nFields\n\nσ: Standard deviation in physical units (typically microns)\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.AiryPSF","page":"API Reference","title":"MicroscopePSFs.AiryPSF","text":"AiryPSF{T<:AbstractFloat} <: Abstract2DPSF{T}\n\n2D Airy pattern PSF using paraxial, scalar model.\n\nField amplitude for a circular aperture is given by:     A(r) = ν/√(4π) * (2J₁(νr)/(νr)) where:     ν = 2π*nₐ/λ     J₁ is the Bessel function of first kind, order 1     r is the radial distance from optical axis\n\nFields\n\nnₐ: Numerical aperture\nλ: Wavelength in microns\nν: Optical parameter = 2π*nₐ/λ\n\n\n\n\n\n","category":"type"},{"location":"api/#3D-PSF-Models","page":"API Reference","title":"3D PSF Models","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ScalarPSF\nVectorPSF","category":"page"},{"location":"api/#MicroscopePSFs.ScalarPSF","page":"API Reference","title":"MicroscopePSFs.ScalarPSF","text":"ScalarPSF{T} <: Abstract3DPSF{T}\n\nScalar 3D PSF using explicit pupil function representation.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in microns\nn::T: Refractive index\npupil::PupilFunction{T}: Complex pupil function\nzernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}: Zernike coefficients used to create this PSF (if applicable)\n\nNotes\n\nCan be initialized with either a PupilFunction or ZernikeCoefficients using the ScalarPSF factory function.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.VectorPSF","page":"API Reference","title":"MicroscopePSFs.VectorPSF","text":"VectorPSF{T<:AbstractFloat} <: Abstract3DPSF{T}\n\nVector PSF model using explicit pupil function representation. Allows direct manipulation of pupil function for custom aberrations.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in microns\nn_medium::T: Sample medium refractive index\nn_coverslip::T: Cover slip refractive index\nn_immersion::T: Immersion medium refractive index\ndipole::DipoleVector{T}: Dipole orientation\nz_stage::T: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)\nvector_pupils::Vector{VectorPupilFunction{T}}: Vector of pupil functions containing field components. For a single dipole, this contains one pupil. For a rotating dipole, it contains three pupils for x, y, and z orientations.\nbase_pupil::Union{Nothing, PupilFunction{T}}: Base pupil function representing system aberrations\nzernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}: Zernike coefficients used to create this PSF (if applicable)\n\n\n\n\n\n","category":"type"},{"location":"api/#PSF-Acceleration","page":"API Reference","title":"PSF Acceleration","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SplinePSF","category":"page"},{"location":"api/#MicroscopePSFs.SplinePSF","page":"API Reference","title":"MicroscopePSFs.SplinePSF","text":"SplinePSF{T<:AbstractFloat, IT<:AbstractInterpolation} <: AbstractPSF\n\nA point spread function (PSF) represented as a B-spline interpolation.\n\nFields\n\nspline: The B-spline interpolation object \nx_range: Range of x-coordinates used for uniform grid interpolation\ny_range: Range of y-coordinates used for uniform grid interpolation  \nz_range: Range of z-coordinates for 3D PSFs, or nothing for 2D PSFs\noriginal_grid: Original grid data used to create the interpolation\ninterp_order: Interpolation order used (0=constant, 1=linear, 3=cubic)\n\nNotes\n\nCoordinates and ranges are in physical units (typically microns)\nPSF values are preserved from the original PSF that was sampled\nFull implementation is in spline_psf.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-Interface-Functions","page":"API Reference","title":"Core Interface Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"amplitude\nintegrate_pixels\nintegrate_pixels_amplitude","category":"page"},{"location":"api/#MicroscopePSFs.amplitude","page":"API Reference","title":"MicroscopePSFs.amplitude","text":"amplitude(p::PupilFunction, x::Real, y::Real, z::Real)\n\nCalculate complex amplitude from pupil function integration.\n\nArguments\n\np::PupilFunction: Pupil function\nx::Real: X position in μm\ny::Real: Y position in μm\nz::Real: Z position in μm\n\n\n\n\n\namplitude(psf::AbstractPSF, x::Real, y::Real)\n\nEvaluate complex field amplitude at position (x,y) relative to PSF center.\n\nArguments\n\nx, y: Position in microns relative to PSF center\n\nReturns\n\nComplex amplitude normalized such that |amplitude|² gives normalized intensity\n\nCoordinates\n\nInput coordinates (x,y) are in physical units (microns) relative to PSF center.\n\nExamples\n\npsf = AiryPSF(1.4, 0.532)\namp = amplitude(psf, 0.1, 0.2)\nintensity = abs2(amp)  # Convert to intensity\n\n\n\n\n\namplitude(psf::AbstractPSF, x::Real, y::Real, z::Real)\n\nEvaluate complex field amplitude in 3D. z is axial distance from focus in microns.\n\n\n\n\n\namplitude(psf::ScalarPSF{T}, x::Real, y::Real, z::Real) where {T}\n\nCalculate complex amplitude at a 3D position using scalar diffraction theory.\n\nArguments\n\npsf: ScalarPSF instance\nx, y, z: Position in microns relative to PSF center\n\nReturns\n\nComplex amplitude at the specified position\n\nNotes\n\nUses Fourier optics to propagate from pupil to image space\nAccounts for defocus and aberrations encoded in the pupil function\n\n\n\n\n\namplitude(psf::VectorPSF, x::Real, y::Real, z::Real)\n\nCompute complex vector amplitude at given position.\n\nArguments\n\npsf: Vector PSF instance\nx, y: Lateral position in microns relative to PSF center\nz: Axial position in microns representing depth above the coverslip\n\nReturns\n\nVector [Ex, Ey] of complex field amplitudes\n\nNotes\n\nz coordinate represents the depth above the coverslip\nz_stage in the PSF indicates the distance the stage was moved away from the nominal focal plane\nIncludes both UAF and SAF contributions automatically\nNot meaningful for rotating dipoles (throws an error if PSF has multiple pupils)\n\n\n\n\n\namplitude(psf::SplinePSF, x::Real, y::Real, z::Real)\n\nCalculate the complex amplitude of the 3D PSF at position (x, y, z).\n\nArguments\n\npsf: SplinePSF instance\nx, y, z: Coordinates in microns relative to PSF center\n\nReturns\n\nComplex amplitude = sqrt(intensity) with zero phase\n\nNotes\n\nReturns sqrt(intensity) as Complex to match the interface of other PSFs\nThe SplinePSF does not model phase information\n\n\n\n\n\namplitude(psf::SplinePSF, x::Real, y::Real)\n\nCalculate the complex amplitude of the PSF at position (x, y) with z=0.\n\nArguments\n\npsf: SplinePSF instance\nx, y: Coordinates in microns relative to PSF center\n\nReturns\n\nComplex amplitude = sqrt(intensity) with zero phase\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.integrate_pixels","page":"API Reference","title":"MicroscopePSFs.integrate_pixels","text":"integrate_pixels(\n    psf::AbstractPSF, \n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter; \n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF intensity over camera pixels with optional support region optimization.\n\nFor each pixel in the specified region, numerically integrates the PSF intensity using the specified  sampling density. Physical coordinates are relative to camera with (0,0) at top-left corner. Automatically handles z-coordinate if both PSF and emitter support it.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\npixel_edges_x::AbstractVector: X-coordinate edges of pixels in microns\npixel_edges_y::AbstractVector: Y-coordinate edges of pixels in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\nthreaded::Bool=true: Whether to use multi-threading for integration Set to false when using with automatic differentiation frameworks\n\nReturns\n\nMatrix{T}: Integrated intensities where T matches emitter.photons type\nArray is indexed as [y,x] with [1,1] at top-left pixel\nValues represent actual photon counts in each pixel based on emitter's photon value\n\nExamples\n\n# Create pixel edges for a 20x20 camera with 100nm pixels\npixel_edges_x = pixel_edges_y = 0:0.1:2.0\nemitter = Emitter2D(1.0, 1.0, 1000.0)  # Emitter at (1μm, 1μm) with 1000 photons\npsf = GaussianPSF(0.15)  # σ = 150nm\n\n# Calculate over full image\npixels = integrate_pixels(psf, pixel_edges_x, pixel_edges_y, emitter)\n\n# Calculate only within a 0.5μm radius of the emitter\npixels_roi = integrate_pixels(psf, pixel_edges_x, pixel_edges_y, emitter, support=0.5)\n\nSee also: integrate_pixels_amplitude, AbstractPSF\n\n\n\n\n\nintegrate_pixels(\n    psf::AbstractPSF, \n    camera::AbstractCamera, \n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF intensity over camera pixels with optional support region optimization.\n\nThis version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\ncamera::AbstractCamera: Camera geometry defining pixel edges in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\nthreaded::Bool=true: Whether to use multi-threading for integration\n\nReturns\n\nArray of pixel values with dimensions y, x\nValues are normalized to sum to 1\nArray indices start at [1,1] for top-left pixel\n\nSee also: integrate_pixels_amplitude, AbstractPSF\n\n\n\n\n\nintegrate_pixels(\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF intensity over camera pixels for multiple emitters with optional support region optimization.\n\nArguments\n\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nIf Real: radius in microns around each emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns (fixed region for all emitters)\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true) Set to false when using with automatic differentiation frameworks\n\nReturns\n\nArray of integrated PSF intensities with dimensions matching the camera\nValues represent actual photon counts from all emitters\n\nNotes\n\nResults are the sum of individual emitter contributions (incoherent addition)\nFor coherent addition, use integrate_pixels_amplitude and sum complex amplitudes\n\n\n\n\n\nintegrate_pixels(\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF intensity over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray of integrated PSF intensities with dimensions matching the camera\nValues represent actual photon counts from all emitters\n\n\n\n\n\nintegrate_pixels(\n    psf::SplinePSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF over camera pixels using interpolation.\n\nArguments\n\npsf: SplinePSF instance\ncamera: Camera geometry\nemitter: Emitter with position information\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling: Subpixel sampling density for integration accuracy\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray of integrated PSF intensities with dimensions [ny, nx]\nValues represent actual photon counts based on emitter's photon value\n\nNotes\n\nFor 3D SplinePSFs (when z_range is defined), requires an emitter with a z-coordinate\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude","text":"integrate_pixels_amplitude(\n    psf::AbstractPSF, \n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter; \n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF complex amplitude over camera pixels with optional support region optimization.\n\nFor each pixel in the specified region, numerically integrates the PSF amplitude using the specified sampling density. Unlike intensity integration, returns unnormalized complex amplitudes which can be used for coherent calculations. Automatically handles z-coordinate if both PSF and emitter support it.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\npixel_edges_x::AbstractVector: X-coordinate edges of pixels in microns\npixel_edges_y::AbstractVector: Y-coordinate edges of pixels in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\nthreaded::Bool=true: Whether to use multi-threading for integration\n\nReturns\n\nMatrix{Complex{T}}: Integrated complex amplitudes where T matches emitter.photons type\nArray is indexed as [y,x] with [1,1] at top-left pixel\nValues are not normalized to preserve complex amplitude relationships\n\nNotes\n\nFor coherent calculations, use this function instead of integrate_pixels\nReturn type is complex to support PSFs with phase information\nTo get intensity from amplitude: abs2.(integrate_pixels_amplitude(...))\n\nSee also: integrate_pixels, AbstractPSF\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::AbstractPSF, \n    camera::AbstractCamera, \n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF complex amplitude over camera pixels with optional support region optimization.\n\nThis version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\ncamera::AbstractCamera: Camera geometry defining pixel edges in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\nthreaded::Bool=true: Whether to use multi-threading for integration\n\nReturns\n\nMatrix of complex amplitudes\nArray indices start at [1,1] for top-left pixel\n\nSee also: integrate_pixels, AbstractPSF\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization.\n\nArguments\n\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray of integrated complex amplitudes\nValues represent coherently summed field contributions\n\nNotes\n\nResults are the coherent sum of individual emitter field contributions\nFor incoherent addition, use abs2.(integrate_pixels_amplitude(...)) or use integrate_pixels\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray of integrated complex amplitudes\nValues represent coherently summed field contributions\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::VectorPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nSpecialized version of amplitude integration for VectorPSF that preserves polarization components.\n\nArguments\n\npsf: VectorPSF instance\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\n3D array of integrated complex amplitudes with dimensions [y, x, pol] where pol index 1 = Ex and pol index 2 = Ey\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::VectorPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF complex amplitude over camera pixels for multiple emitters. Special version for VectorPSF that preserves polarization components.\n\nArguments\n\npsf: VectorPSF instance\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\n3D array of integrated complex amplitudes with dimensions [y, x, pol] where pol index 1 = Ex and pol index 2 = Ey\n\nNotes\n\nResults are the coherent sum of individual emitter field contributions\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::SplinePSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF amplitude (complex) over camera pixels.\n\nArguments\n\npsf: SplinePSF instance\ncamera: Camera geometry\nemitter: Emitter with position information\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling: Subpixel sampling density for integration accuracy\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray of integrated PSF complex amplitudes with dimensions [ny, nx]\n\nNotes\n\nFor 3D SplinePSFs (when z_range is defined), requires an emitter with a z-coordinate\n\n\n\n\n\n","category":"function"},{"location":"api/#Multi-Emitter-Integration","page":"API Reference","title":"Multi-Emitter Integration","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The following functions support integrating PSFs for multiple emitters:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"integrate_pixels(psf::AbstractPSF, camera::AbstractCamera, emitters::Vector{<:AbstractEmitter}; support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}}=Inf, sampling::Integer=2, threaded::Bool=true)\nintegrate_pixels_amplitude(psf::AbstractPSF, camera::AbstractCamera, emitters::Vector{<:AbstractEmitter}; support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}}=Inf, sampling::Integer=2, threaded::Bool=true)","category":"page"},{"location":"api/#MicroscopePSFs.integrate_pixels-Tuple{AbstractPSF, AbstractCamera, Vector{<:AbstractEmitter}}","page":"API Reference","title":"MicroscopePSFs.integrate_pixels","text":"integrate_pixels(\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF intensity over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray of integrated PSF intensities with dimensions matching the camera\nValues represent actual photon counts from all emitters\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude-Tuple{AbstractPSF, AbstractCamera, Vector{<:AbstractEmitter}}","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude","text":"integrate_pixels_amplitude(\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nIntegrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray of integrated complex amplitudes\nValues represent coherently summed field contributions\n\n\n\n\n\n","category":"method"},{"location":"api/#Pupil-Functions","page":"API Reference","title":"Pupil Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PupilFunction\nVectorPupilFunction","category":"page"},{"location":"api/#MicroscopePSFs.PupilFunction","page":"API Reference","title":"MicroscopePSFs.PupilFunction","text":"PupilFunction{T}\n\nRepresents a pupil function with physical parameters.\n\nFields\n\nnₐ: Numerical aperture\nλ: Wavelength in μm\nn: Refractive index\nfield: Complex-valued pupil function array\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.VectorPupilFunction","page":"API Reference","title":"MicroscopePSFs.VectorPupilFunction","text":"VectorPupilFunction{T}\n\nVector pupil function storing Ex,Ey field components as PupilFunctions.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in μm\nn_medium::T: Refractive index of the sample medium\nn_coverslip::T: Refractive index of the coverslip\nn_immersion::T: Refractive index of the immersion medium\nEx::PupilFunction{T}: x-component of electric field\nEy::PupilFunction{T}: y-component of electric field\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike-Module","page":"API Reference","title":"Zernike Module","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"MicroscopePSFs.Zernike.ZernikeCoefficients","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.ZernikeCoefficients","page":"API Reference","title":"MicroscopePSFs.Zernike.ZernikeCoefficients","text":"ZernikeCoefficients{T<:Real}\n\nMutable structure to hold Zernike coefficients for both magnitude and phase of a pupil function. Uses Noll indexing convention starting at index 1.\n\nFields\n\nmag::Vector{T}: Coefficients for magnitude (1-indexed per Noll convention)\nphase::Vector{T}: Coefficients for phase (1-indexed per Noll convention)\n\nNotes\n\nFirst coefficient (index 1) typically represents piston\nMagnitude coefficients are typically normalized with mag[1] = 1\nPhase coefficients represent phase in radians\nRMS normalization (Noll convention) is used so coefficients directly represent RMS wavefront error\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike-Polynomial-Functions","page":"API Reference","title":"Zernike Polynomial Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"MicroscopePSFs.Zernike.zernikepolynomial\nMicroscopePSFs.Zernike.radialpolynomial\nMicroscopePSFs.Zernike.max_radial_order\nMicroscopePSFs.Zernike.evaluate_pupil","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.zernikepolynomial","page":"API Reference","title":"MicroscopePSFs.Zernike.zernikepolynomial","text":"zernikepolynomial(n::Integer, l::Integer, ρ::Real, ϕ::Real) -> Real\n\nCompute the complete Zernike polynomial Z_n^l(ρ,ϕ) with Noll normalization (RMS=1).\n\nArguments\n\nn: Radial order\nl: Azimuthal frequency (signed)\nρ: Radial coordinate (0 ≤ ρ ≤ 1)\nϕ: Azimuthal angle in radians\n\nNotes\n\nUses Noll normalization where RMS=1 over unit circle\nCombines radial polynomial with appropriate trigonometric function\n\n\n\n\n\nzernikepolynomial(j::Integer, ρ::Real, ϕ::Real) -> Real\n\nCompute Zernike polynomial using Noll index.\n\nArguments\n\nj: Polynomial index using Noll convention\nρ: Radial coordinate\nϕ: Azimuthal angle\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.radialpolynomial","page":"API Reference","title":"MicroscopePSFs.Zernike.radialpolynomial","text":"radialpolynomial(n::Integer, m::Integer, ρ::Real) -> Real\n\nCompute the unnormalized radial component R_n^m(ρ) of the Zernike polynomial.\n\nArguments\n\nn: Radial order\nm: Azimuthal order (absolute value of azimuthal frequency)\nρ: Radial coordinate (0 ≤ ρ ≤ 1)\n\nNotes\n\nReturns 0 for ρ > 1\nNo normalization applied - returns the standard mathematical form\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.max_radial_order","page":"API Reference","title":"MicroscopePSFs.Zernike.max_radial_order","text":"max_radial_order(num_coeffs::Integer)\n\nCalculate maximum radial order N given number of coefficients L. Solves (N+1)(N+2)/2 = L\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.evaluate_pupil","page":"API Reference","title":"MicroscopePSFs.Zernike.evaluate_pupil","text":"evaluate_pupil(coeffs::ZernikeCoefficients, grid_size::Integer) -> Matrix{Complex{Float64}}\n\nGenerate complex pupil function from Zernike coefficients.\n\nArguments\n\ncoeffs: ZernikeCoefficients containing magnitude and phase coefficients\ngrid_size: Size of the output grid (gridsize × gridsize)\n\nReturns\n\nComplex-valued matrix representing the pupil function\n\nNotes\n\nOutput grid is normalized to unit circle\nPoints outside unit circle are set to zero\nPhase is applied as exp(iϕ)\nUses Noll indexing throughout\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike-Analysis-Functions","page":"API Reference","title":"Zernike Analysis Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"MicroscopePSFs.Zernike.rms\nMicroscopePSFs.Zernike.significant_terms","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.rms","page":"API Reference","title":"MicroscopePSFs.Zernike.rms","text":"rms(coeffs::ZernikeCoefficients) -> Tuple{Float64,Float64}\n\nCalculate RMS values for magnitude and phase coefficients (excluding piston).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.significant_terms","page":"API Reference","title":"MicroscopePSFs.Zernike.significant_terms","text":"significant_terms(coeffs::ZernikeCoefficients, \n                 threshold::Real=0.01) -> Vector{Tuple{Int,Float64,Float64}}\n\nReturn list of significant terms: (index, magnitude, phase) above threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index-Conversion","page":"API Reference","title":"Index Conversion","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"MicroscopePSFs.Zernike.nl2osa\nMicroscopePSFs.Zernike.osa2nl\nMicroscopePSFs.Zernike.nl2noll\nMicroscopePSFs.Zernike.noll2nl\nMicroscopePSFs.Zernike.osa2noll\nMicroscopePSFs.Zernike.noll2osa","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.nl2osa","page":"API Reference","title":"MicroscopePSFs.Zernike.nl2osa","text":"nl2osa(n::Integer, l::Integer) -> Int\n\nConvert from (n,l) indices to OSA/ANSI single index.\n\nArguments\n\nn: Radial order (≥ 0)\nl: Azimuthal frequency, must satisfy:\n|l| ≤ n\nn - |l| must be even\n\nReturns\n\nOSA/ANSI single index j = (n(n+2) + l)/2\n\nExamples\n\njulia> nl2osa(4, 2)\n15\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.osa2nl","page":"API Reference","title":"MicroscopePSFs.Zernike.osa2nl","text":"osa2nl(j::Integer) -> Tuple{Int,Int}\n\nConvert from OSA/ANSI single index to (n,l) indices.\n\nArguments\n\nj: OSA/ANSI index (≥ 0)\n\nReturns\n\nTuple of (n,l) indices\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.nl2noll","page":"API Reference","title":"MicroscopePSFs.Zernike.nl2noll","text":"nl2noll(n::Integer, l::Integer) -> Int\n\nConvert from (n,l) indices to Noll single index.\n\nArguments\n\nn: Radial order (≥ 0)\nl: Azimuthal frequency, must satisfy:\n|l| ≤ n\nn - |l| must be even\n\nReturns\n\nNoll single index\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.noll2nl","page":"API Reference","title":"MicroscopePSFs.Zernike.noll2nl","text":"noll2nl(j::Integer) -> Tuple{Int,Int}\n\nConvert from Noll single index to (n,l) indices.\n\nArguments\n\nj: Noll index (> 0)\n\nReturns\n\nTuple of (n,l) indices\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.osa2noll","page":"API Reference","title":"MicroscopePSFs.Zernike.osa2noll","text":"osa2noll(j::Integer) -> Int\n\nConvert from OSA/ANSI to Noll index.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.noll2osa","page":"API Reference","title":"MicroscopePSFs.Zernike.noll2osa","text":"noll2osa(j::Integer) -> Int\n\nConvert from Noll to OSA/ANSI index.\n\n\n\n\n\n","category":"function"},{"location":"api/#Emitters","page":"API Reference","title":"Emitters","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"DipoleVector\nDipoleEmitter3D","category":"page"},{"location":"api/#MicroscopePSFs.DipoleVector","page":"API Reference","title":"MicroscopePSFs.DipoleVector","text":"DipoleVector{T} <: Real\n\nA 3D vector representing the dipole orientation.\n\nFields\n\npx::T: x component of the dipole vector\npy::T: y component of the dipole vector\npz::T: z component of the dipole vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.DipoleEmitter3D","page":"API Reference","title":"MicroscopePSFs.DipoleEmitter3D","text":"DipoleEmitter3D{T} <: AbstractEmitter\n\n3D dipole emitter with position, orientation and optical properties.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns \nz::T: z-coordinate in microns\nphotons::T: number of photons\ndipole::DipoleVector{T}: dipole orientation vector\n\n\n\n\n\n","category":"type"},{"location":"api/#I/O-Functions","page":"API Reference","title":"I/O Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"save_psf\nload_psf","category":"page"},{"location":"api/#MicroscopePSFs.save_psf","page":"API Reference","title":"MicroscopePSFs.save_psf","text":"save_psf(filename::String, object; metadata::Dict=Dict())\n\nSave a PSF or related object (e.g., ZernikeCoefficients, PupilFunction) to an HDF5 file.\n\nArguments\n\nfilename: Path where the PSF will be saved\nobject: Object to save (PSF, ZernikeCoefficients, PupilFunction, etc.)\nmetadata: Optional dictionary of additional metadata to include\n\nReturns\n\nfilename for chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#Complete-API-(All-Documented-Functions)","page":"API Reference","title":"Complete API (All Documented Functions)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section lists additional internal functions and types that are documented but not part of the public API.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MicroscopePSFs]\nPublic = false","category":"page"},{"location":"api/#MicroscopePSFs.Abstract2DPSF","page":"API Reference","title":"MicroscopePSFs.Abstract2DPSF","text":"Abstract2DPSF{T<:AbstractFloat}\n\nAbstract type for all 2D point spread functions. Parameterized by numeric type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Abstract3DPSF","page":"API Reference","title":"MicroscopePSFs.Abstract3DPSF","text":"Abstract3DPSF{T<:AbstractFloat}\n\nAbstract type for all 3D point spread functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs._calculate_field_amplitude-Tuple{VectorPupilFunction, Vararg{Real, 9}}","page":"API Reference","title":"MicroscopePSFs._calculate_field_amplitude","text":"_calculate_field_amplitude(\n    pupil::VectorPupilFunction,\n    nₐ::Real, λ::Real, n_medium::Real, n_coverslip::Real, n_immersion::Real, z_stage::Real,\n    x::Real, y::Real, z::Real)\n\nInternal helper function to compute complex vector amplitude at given position.\n\nArguments\n\npupil: Vector pupil function containing Ex and Ey fields\nnₐ, λ, n_medium, n_coverslip, n_immersion: Optical parameters \nz_stage: Distance the sample stage was moved away from the nominal focal plane\nx, y, z: Position in microns\n\nReturns\n\nVector [Ex, Ey] of complex field amplitudes\n\nNotes\n\nThis is a helper function used by both amplitude() and the PSF evaluation function\nImplements the core field calculation for a single pupil\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._check_normalization-Tuple{Any}","page":"API Reference","title":"MicroscopePSFs._check_normalization","text":"_check_normalization(values; tol=1e-6)\n\nInternal function to verify array sums to 1 within tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._integrate_pixels_core!-Tuple{AbstractArray, AbstractVector, AbstractVector, Function, Real, Real}","page":"API Reference","title":"MicroscopePSFs._integrate_pixels_core!","text":"_integrate_pixels_core!(\n    result::AbstractArray,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    func::Function,\n    emitter_x::Real,\n    emitter_y::Real;\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nInternal function implementing the core pixel integration logic. Supports both scalar and vector/tensor return types from the function.\n\nArguments\n\nresult: Pre-allocated array where integration results will be stored\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nfunc: Function to evaluate at PSF coordinates - can return scalar, vector, or tensor\nemitter_x, emitter_y: Emitter coordinates in same units as pixel edges\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true) Set to false when using with automatic differentiation frameworks\n\nReturns\n\nresult array filled with integration values\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._integrate_pixels_generic!-Tuple{AbstractArray, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function}","page":"API Reference","title":"MicroscopePSFs._integrate_pixels_generic!","text":"_integrate_pixels_generic!(\n    result::AbstractArray,\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter,\n    f::Function;\n    sampling::Integer=2,\n    threaded::Bool=true\n)\n\nGeneric wrapper for PSF integration that handles coordinate systems and validation. Automatically handles z-coordinates when both PSF and emitter support them. Supports functions that return either scalars or vectors/tensors.\n\nArguments\n\nresult: Pre-allocated array where results will be stored\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nf: Function to evaluate (e.g., (p,x,y) -> p(x,y) for intensity)\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nresult array filled with integration values\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._integrate_pixels_generic-Union{Tuple{T}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}, Any}} where T","page":"API Reference","title":"MicroscopePSFs._integrate_pixels_generic","text":"_integrate_pixels_generic(\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter,\n    f::Function,\n    ::Type{T},\n    output_dims=();\n    sampling::Integer=2,\n    threaded::Bool=true\n) where T\n\nInternal generic integration routine used by both intensity and amplitude integration. Creates a new result array and delegates to the in-place version. Supports both scalar and vector/tensor return types.\n\nArguments\n\noutput_dims: Additional dimensions for the result array beyond the basic [y,x] dimensions. For vector returns (e.g., [Ex, Ey]), set output_dims=(2,) for a [y,x,2] result array.\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nArray with dimensions [y,x] or [y,x,output_dims...] depending on the function's return type\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_check_required_fields-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_check_required_fields","text":"_io_check_required_fields(group, fields)\n\nCheck if all required fields exist in an HDF5 group. Throws an error if any required field is missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_complex_array-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_load_complex_array","text":"_io_load_complex_array(group, name)\n\nLoad a complex array from an HDF5 group by combining real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_range-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_load_range","text":"_io_load_range(group, name)\n\nLoad a range from an HDF5 group by reconstructing from start, step, and length.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_zernike_coeffs-Tuple{Any}","page":"API Reference","title":"MicroscopePSFs._io_load_zernike_coeffs","text":"_io_load_zernike_coeffs(file; group_name=\"zernike_coefficients\")\n\nLoad ZernikeCoefficients from an HDF5 file from a specified group. Returns nothing if the group doesn't exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_complex_array-Tuple{Any, Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_complex_array","text":"_io_save_complex_array(group, name, array)\n\nSave a complex array to an HDF5 group by splitting into real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_pupil_params-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_pupil_params","text":"_io_save_pupil_params(params, pupil)\n\nSave common pupil parameters to an HDF5 group.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_range-Tuple{Any, Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_range","text":"_io_save_range(group, name, range)\n\nSave a range to an HDF5 group by storing start, step, and length.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_zernike_coeffs-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_zernike_coeffs","text":"_io_save_zernike_coeffs(file, coeffs; group_name=\"zernike_coefficients\")\n\nSave ZernikeCoefficients to an HDF5 file in a specified group. Does nothing if coeffs is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{AiryPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{AiryPSF})\n\nLoad an AiryPSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{GaussianPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{GaussianPSF})\n\nLoad a GaussianPSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{PupilFunction}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{PupilFunction})\n\nLoad a PupilFunction from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ScalarPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{ScalarPSF})\n\nLoad a ScalarPSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{SplinePSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{SplinePSF})\n\nLoad a SplinePSF from an HDF5 file, reconstructing it using the standard constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{VectorPSF})\n\nLoad a VectorPSF from an HDF5 file, reconstructing all components.\n\nArguments\n\nfile: Open HDF5 file handle\n::Type{VectorPSF}: Type to load\n\nReturns\n\nVectorPSF reconstructed from stored data\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPupilFunction}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{VectorPupilFunction})\n\nLoad a VectorPupilFunction from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ZernikeCoefficients}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{ZernikeCoefficients})\n\nLoad ZernikeCoefficients from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._sample_psf_2d-Tuple{AbstractPSF, AbstractRange, AbstractRange}","page":"API Reference","title":"MicroscopePSFs._sample_psf_2d","text":"_sample_psf_2d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange)\n\nInternal helper function to sample a 2D PSF on a regular grid. Returns an array with dimensions [y, x] containing raw PSF values.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._sample_psf_3d-Tuple{AbstractPSF, AbstractRange, AbstractRange, AbstractRange}","page":"API Reference","title":"MicroscopePSFs._sample_psf_3d","text":"_sample_psf_3d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange, z_range::AbstractRange)\n\nInternal helper function to sample a 3D PSF on a regular grid. Returns an array with dimensions [y, x, z] containing raw PSF values.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, AiryPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::AiryPSF)\n\nSave an AiryPSF to an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, GaussianPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::GaussianPSF)\n\nSave a GaussianPSF to an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, PupilFunction}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, pupil::PupilFunction)\n\nSave a PupilFunction to an HDF5 file, including physical parameters and complex field.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ScalarPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::ScalarPSF)\n\nSave a ScalarPSF to an HDF5 file, including pupil function and any Zernike coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, SplinePSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::SplinePSF)\n\nSave a SplinePSF to an HDF5 file, including the original grid data used to create the spline interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::VectorPSF)\n\nSave a VectorPSF to an HDF5 file, including all optical parameters, dipole orientation, and vector pupil fields.\n\nArguments\n\nfile: Open HDF5 file handle\npsf: VectorPSF to save\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, pupil::VectorPupilFunction)\n\nSave a VectorPupilFunction to an HDF5 file, including all physical parameters and both Ex and Ey field components.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ZernikeCoefficients}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, zc::ZernikeCoefficients)\n\nSave ZernikeCoefficients to an HDF5 file, storing magnitude and phase arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.apply_aperture!","page":"API Reference","title":"MicroscopePSFs.apply_aperture!","text":"apply_aperture!(p::PupilFunction, radius::Real=1.0)\n\nApply circular aperture to pupil function. Radius is relative to NA.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.apply_defocus!-Tuple{PupilFunction, Real}","page":"API Reference","title":"MicroscopePSFs.apply_defocus!","text":"apply_defocus!(p::PupilFunction, z::Real)\n\nApply defocus phase to pupil function for propagation distance z.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_apodization-NTuple{4, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_apodization","text":"calculate_apodization(kr2::Real, λ::Real, \n                    n_medium::Real, n_immersion::Real)\n\nCalculate apodization factor for energy conservation.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn_medium: Refractive index of the sample medium\nn_immersion: Refractive index of the immersion medium\n\nReturns\n\nApodization factor for energy conservation\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_axial_phase","page":"API Reference","title":"MicroscopePSFs.calculate_axial_phase","text":"calculate_axial_phase(z::Real, z_stage::Real, kz_medium::Complex, \n                     kz_coverslip::Complex, kz_immersion::Complex,\n                     coverslip_thickness::Real=0.17)\n\nCalculate total axial phase from defocus.\n\nArguments\n\nz: Emitter position relative to the coverslip (depth above the coverslip in μm)\nz_stage: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)\nkz_medium: z-component of wave vector in sample medium\nkz_coverslip: z-component of wave vector in coverslip\nkz_immersion: z-component of wave vector in immersion medium\ncoverslip_thickness: Thickness of coverslip in mm (default: 0.17mm)\n\nReturns\n\nDefocus phase\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.calculate_dipole_field_components-Tuple{Complex, Complex, Complex, DipoleVector, Complex, Complex}","page":"API Reference","title":"MicroscopePSFs.calculate_dipole_field_components","text":"calculate_dipole_field_components(ϕ::Complex, sinθ::Complex, cosθ::Complex,\n                                dipole::DipoleVector, Tp::Complex, Ts::Complex)\n\nCalculate vectorial field components for a dipole orientation.\n\nArguments\n\nϕ: Azimuthal angle in pupil plane\nsinθ: Sine of polar angle\ncosθ: Cosine of polar angle\ndipole: Dipole orientation vector\nTp: p-polarization transmission coefficient\nTs: s-polarization transmission coefficient\n\nReturns\n\nTuple (Ex, Ey) of complex field components\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_interface_fresnel-NTuple{4, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_interface_fresnel","text":"calculate_interface_fresnel(kr2::Real, λ::Real, \n                          n1::Real, n2::Real)\n\nCalculate Fresnel transmission coefficients for a single interface.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn1: Refractive index of first medium\nn2: Refractive index of second medium\n\nReturns\n\nTuple of (Tp, Ts): p and s polarization transmission coefficients\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_wave_vectors-NTuple{5, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_wave_vectors","text":"calculate_wave_vectors(kr2::Real, λ::Real, \n                     n_medium::Real, n_coverslip::Real, n_immersion::Real)\n\nCalculate z-components of wave vectors in all three media.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn_medium: Refractive index of the sample medium\nn_coverslip: Refractive index of the coverslip\nn_immersion: Refractive index of the immersion medium\n\nReturns\n\nTuple of (kzmedium, kzcoverslip, kz_immersion): z-components of wave vectors in each medium\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.fill_vector_pupils!","page":"API Reference","title":"MicroscopePSFs.fill_vector_pupils!","text":"fill_vector_pupils!(vpupil::VectorPupilFunction, dipole::DipoleVector,\n                  base_pupil::Union{Nothing, PupilFunction}=nothing)\n\nFill vector pupil function with field components including dipole orientation, base aberrations, and proper apodization.\n\nThis pre-calculates all position-independent factors of the pupil function.\n\nArguments\n\nvpupil: Vector pupil function to fill\ndipole: Dipole orientation vector\nbase_pupil: Optional base aberration pupil function\n\nReturns\n\nFilled and normalized vector pupil function\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.get_pixel_indices-Tuple{AbstractVector, AbstractVector, AbstractEmitter, Union{Real, NTuple{4, Real}}}","page":"API Reference","title":"MicroscopePSFs.get_pixel_indices","text":"get_pixel_indices(\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter,\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}}\n) -> Tuple{UnitRange{Int},UnitRange{Int}}\n\nGet the pixel indices that overlap with the support region.\n\nArguments\n\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nsupport: Region of interest, either a radius or explicit bounds (xmin, xmax, ymin, ymax)\n\nReturns\n\nTuple of (irange, jrange) with pixel indices that cover the support region If the support region doesn't overlap with the camera, returns empty ranges\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels!","text":"integrate_pixels!(\n    result::AbstractMatrix{T},\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2,\n    threaded::Bool=true\n) where T <: Real\n\nIntegrate PSF intensity over camera pixels using camera object, storing the result in a pre-allocated matrix.\n\nArguments\n\nresult: Pre-allocated array where results will be stored\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nThe result array, now filled with integrated intensities\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels!","text":"integrate_pixels!(\n    result::AbstractMatrix{T},\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter;\n    sampling::Integer=2,\n    threaded::Bool=true\n) where T <: Real\n\nIntegrate PSF intensity over camera pixels, storing the result in a pre-allocated matrix. Automatically uses z-coordinate if both PSF and emitter support it.\n\nArguments\n\nresult: Pre-allocated array where results will be stored\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true) Set to false when using with automatic differentiation frameworks\n\nReturns\n\nThe result array, now filled with integrated intensities scaled by emitter.photons\n\nNotes\n\nArray is indexed as [y,x] with [1,1] at top-left pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude!","text":"integrate_pixels_amplitude!(\n    result::AbstractMatrix{Complex{T}},\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2,\n    threaded::Bool=true\n) where T <: Real\n\nIntegrate PSF complex amplitude over camera pixels using camera object, storing the result in a pre-allocated matrix.\n\nArguments\n\nresult: Pre-allocated complex array where results will be stored\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nThe result array, now filled with integrated complex amplitudes\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude!","text":"integrate_pixels_amplitude!(\n    result::AbstractMatrix{Complex{T}},\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter;\n    sampling::Integer=2,\n    threaded::Bool=true\n) where T <: Real\n\nIntegrate PSF complex amplitude over camera pixels, storing the result in a pre-allocated matrix. Automatically uses z-coordinate if both PSF and emitter support it.\n\nArguments\n\nresult: Pre-allocated complex array where results will be stored\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nThe result array, now filled with integrated complex amplitudes\n\nNotes\n\nArray is indexed as [y,x] with [1,1] at top-left pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 3}, VectorPSF, AbstractCamera, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude!","text":"integrate_pixels_amplitude!(\n    result::AbstractArray{Complex{T},3},\n    psf::VectorPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2,\n    threaded::Bool=true\n) where T <: Real\n\nSpecial version of amplitude integration for VectorPSF that preserves polarization components. Uses the flexible core integration function that handles vector returns.\n\nArguments\n\nresult: Pre-allocated 3D complex array where results will be stored, dimensions [y, x, pol]\npsf: VectorPSF instance\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\nthreaded: Whether to use multi-threading for integration (default: true)\n\nReturns\n\nThe result array, filled with integrated complex amplitudes for each polarization\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kmax-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.kmax","text":"kmax(p::PupilFunction)\n\nGet maximum spatial frequency in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kmax-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.kmax","text":"Get maximum spatial frequency in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kpixelsize-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.kpixelsize","text":"kpixelsize(p::PupilFunction)\n\nGet pupil plane sampling in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kpixelsize-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.kpixelsize","text":"Get pupil plane sampling in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.k₀-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.k₀","text":"k₀(p::PupilFunction)\n\nGet central wavevector magnitude in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.k₀-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.k₀","text":"Get central wavevector magnitude in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.normalize!-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.normalize!","text":"normalize!(p::PupilFunction)\n\nNormalize pupil function to unit energy using Parseval's theorem.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.normalize!-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.normalize!","text":"normalize!(p::VectorPupilFunction)\n\nNormalize the electric field components of the vector pupil function. Ensures total energy across both components equals 1.\n\nArguments\n\np: Vector pupil function to normalize\n\nReturns\n\nNormalized vector pupil function\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.supports_3d-Tuple{Type{<:AbstractPSF}}","page":"API Reference","title":"MicroscopePSFs.supports_3d","text":"supports_3d(psf_type::Type{<:AbstractPSF}) -> Bool\n\nCheck if a PSF type supports 3D evaluation via psf(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.update_pupils!-Tuple{VectorPSF}","page":"API Reference","title":"MicroscopePSFs.update_pupils!","text":"update_pupils!(psf::VectorPSF) -> VectorPSF\n\nUpdate the vector pupil functions based on stored Zernike coefficients and/or base pupil. This is useful after modifying aberrations to regenerate the pupil fields.\n\nArguments\n\npsf: VectorPSF to update\n\nReturns\n\nUpdated VectorPSF\n\nNotes\n\nRequires either stored Zernike coefficients or a base pupil\nFor rotating dipoles (multiple pupils), updates each pupil with the appropriate dipole orientation\nReturns the updated PSF for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#Zernike-Module-Internal-API","page":"API Reference","title":"Zernike Module Internal API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MicroscopePSFs.Zernike]\nPublic = false","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.get_nl-Tuple{Integer}","page":"API Reference","title":"MicroscopePSFs.Zernike.get_nl","text":"get_nl(j::Integer) -> Tuple{Int,Int}\n\nGet (n,l) indices from Noll index.\n\n\n\n\n\n","category":"method"},{"location":"conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"This page documents the conventions used throughout MicroscopePSFs.jl.","category":"page"},{"location":"conventions/#Coordinate-System","page":"Conventions","title":"Coordinate System","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"MicroscopePSFs.jl uses the following coordinate system conventions:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Physical units: All distances are in micrometers (μm)\nOrigin: For PSF evaluation, the origin (0,0,0) is at the PSF center\nAxes:\nx-axis: Lateral direction (positive right)\ny-axis: Lateral direction (positive down)\nz-axis: Axial direction (positive away from objective)","category":"page"},{"location":"conventions/#Image-and-Camera-Coordinates","page":"Conventions","title":"Image and Camera Coordinates","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"When generating PSF images with integrate_pixels:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Camera coordinates have (0,0) at the top-left corner of the top-left pixel\nImages are returned as Julia matrices with indices [row, column]\nThis corresponds to [y, x] in the coordinate system\nThe first element [1, 1] is the top-left pixel","category":"page"},{"location":"conventions/#Normalization","page":"Conventions","title":"Normalization","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"PSF models use the following normalization conventions:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"PSF evaluation: PSF intensity is normalized to integrate to 1.0 over the entire xy plane\nAmplitude: Complex amplitudes are normalized such that |amplitude|² gives the normalized intensity\nCamera images: Images generated with integrate_pixels contain actual photon counts based on emitter.photons","category":"page"},{"location":"conventions/#Aberrations","page":"Conventions","title":"Aberrations","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Aberrations are represented using Zernike polynomials:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Zernike polynomials are normalized to give an RMS of 1.0\nCoefficients can be set directly via indexing: zc[5] = 0.5\nThe OSA indexing scheme is used by default\nPositive z (defocus) corresponds to the emitter moving away from the objective","category":"page"},{"location":"conventions/#Units","page":"Conventions","title":"Units","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Parameter Unit\nWavelength Micrometers (μm)\nPosition Micrometers (μm)\nPixel size Micrometers (μm)\nSigma Micrometers (μm)\nNA Dimensionless\nRefractive index Dimensionless\nZernike coefficients Normalized (RMS=1)","category":"page"},{"location":"conventions/#Type-Hierarchy","page":"Conventions","title":"Type Hierarchy","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The package uses the following type hierarchy structure:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"AbstractPSF\n├── Abstract2DPSF\n│   ├── GaussianPSF\n│   └── AiryPSF\n├── Abstract3DPSF\n│   ├── ScalarPSF\n│   └── VectorPSF\n└── SplinePSF","category":"page"},{"location":"conventions/#Performance-Considerations","page":"Conventions","title":"Performance Considerations","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"For multi-emitter simulations, use the support parameter to limit computation to relevant regions\nUse SplinePSF to accelerate complex PSF models\nThe package automatically uses multithreading in the integrate_pixels methods by default\nFor automatic differentiation, you can disable threading with the threaded=false parameter\nDisabling threading is required for compatibility with most automatic differentiation frameworks","category":"page"},{"location":"psfs/gaussianpsf/#GaussianPSF","page":"GaussianPSF","title":"GaussianPSF","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"The GaussianPSF model represents the microscope point spread function as an isotropic 2D Gaussian function. While this is a mathematical approximation rather than a physical model derived from diffraction theory, it provides excellent computational efficiency for rapid prototyping and performance-critical algorithms.","category":"page"},{"location":"psfs/gaussianpsf/#Mathematical-Model","page":"GaussianPSF","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"The GaussianPSF is defined as:","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"I(x y) = frac12pisigma^2 expleft(-fracx^2 + y^22sigma^2right)","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"where:","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"x y are coordinates in physical units (microns)\nsigma is the standard deviation in the same units","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"This function is normalized to integrate to 1 over the entire domain, ensuring energy conservation.","category":"page"},{"location":"psfs/gaussianpsf/#Constructor-and-Parameters","page":"GaussianPSF","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"GaussianPSF(σ::Real)","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"σ: Standard deviation in microns, representing the width of the PSF","category":"page"},{"location":"psfs/gaussianpsf/#Alternative-Constructor","page":"GaussianPSF","title":"Alternative Constructor","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"GaussianPSF(psf::AiryPSF)  # Create from an Airy PSF","category":"page"},{"location":"psfs/gaussianpsf/#Key-Features","page":"GaussianPSF","title":"Key Features","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"Computational Efficiency: Fastest PSF model in the package, using a simple closed-form expression\nSimplicity: Simple mathematical form makes it ideal for prototyping\nApproximation: Provides a reasonable approximation of the central peak of diffraction-limited PSFs","category":"page"},{"location":"psfs/gaussianpsf/#Examples","page":"GaussianPSF","title":"Examples","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"Creating a Gaussian PSF:","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"# Create a PSF with 150nm standard deviation\npsf = GaussianPSF(0.15)\n\n# Create a Gaussian approximation of an Airy disk\nairy_psf = AiryPSF(1.4, 0.532)  # NA=1.4, wavelength=532nm\ngaussian_approximation = GaussianPSF(airy_psf)  # Automatically sets appropriate σ","category":"page"},{"location":"psfs/gaussianpsf/#Relationship-to-Airy-Function","page":"GaussianPSF","title":"Relationship to Airy Function","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"The Gaussian2D model can approximate the Airy disk pattern using the empirical relationship:","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"sigma approx 022 fraclambdatextNA","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"where λ is the wavelength and NA is the numerical aperture. This approximation works best near the center of the PSF.","category":"page"},{"location":"psfs/gaussianpsf/#Limitations","page":"GaussianPSF","title":"Limitations","text":"","category":"section"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"No Diffraction Rings: Doesn't capture the diffraction rings present in real microscope PSFs\nNo Defocus Modeling: Can't model effects of defocus or 3D imaging\nNo Aberrations: Doesn't account for optical aberrations\nSimplified Physics: Mathematical approximation rather than physically derived model\nLess Accurate at Edges: Diverges from physical PSFs at larger distances from the center","category":"page"},{"location":"psfs/gaussianpsf/","page":"GaussianPSF","title":"GaussianPSF","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"psfs/vectorpsf/#VectorPSF","page":"VectorPSF","title":"VectorPSF","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"The VectorPSF model implements a comprehensive three-dimensional point spread function based on vectorial diffraction theory. It accounts for polarization effects, high-NA phenomena, dipole emission patterns, refractive index interfaces, and arbitrary aberrations, providing the highest level of physical accuracy among the PSF models.","category":"page"},{"location":"psfs/vectorpsf/#Mathematical-Model","page":"VectorPSF","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"The VectorPSF implements the full Richards-Wolf vector diffraction theory, accounting for the vectorial nature of light. The key formula for the electric field at the image plane is:","category":"page"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"PSF(x - x_i y - y_i z_i z_s) = sum_m=xy sum_n=p_x p_y p_z Fh(k_x k_y)w_mnA(k_x k_y)e^iota 2pi(k_x x_i+k_y y_i+k_zmathrmmed z_i-k_zmathrmimmz_s)^2","category":"page"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"Where:","category":"page"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"(x_i y_i z_i) is the emitter position where z_i represents the depth above the coverslip\nz_s is the distance the sample stage was moved from nominal focus\nF denotes the Fourier transform operation \nh(k_x k_y) is the complex pupil function incorporating aberrations \nw_mn represents electric field components at the pupil plane\nA(k_x k_y) is the apodization factor for energy conservation \nk_zmathrmmed and k_zmathrmimm are z-components of wave vectors in the sample and immersion media","category":"page"},{"location":"psfs/vectorpsf/#Constructor-and-Parameters","page":"VectorPSF","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"VectorPSF(nₐ::Real, λ::Real, dipole::DipoleVector;\n         base_pupil::Union{Nothing, PupilFunction}=nothing,\n         base_zernike::Union{Nothing, ZernikeCoefficients}=nothing,\n         n_medium::Real=1.33,\n         n_coverslip::Real=1.52,\n         n_immersion::Real=1.52,\n         z_stage::Real=0.0, \n         grid_size::Integer=128)","category":"page"},{"location":"psfs/vectorpsf/#Required-Parameters","page":"VectorPSF","title":"Required Parameters","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"nₐ: Numerical aperture of the objective\nλ: Wavelength of light in microns\ndipole: Dipole orientation vector specified using DipoleVector","category":"page"},{"location":"psfs/vectorpsf/#Optional-Parameters","page":"VectorPSF","title":"Optional Parameters","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"base_pupil: Optional base aberration pupil function (default: none)\nbase_zernike: Zernike coefficients for aberrations (default: none)\nn_medium: Refractive index of the sample medium (default: 1.33, water)\nn_immersion: Refractive index of the immersion medium (default: 1.52, oil)\nn_coverslip: Refractive index of the coverslip (default: 1.52, glass)\nz_stage: Distance the sample stage was moved (μm) (default: 0.0)\ngrid_size: Size of grid for pupil function (default: 128)","category":"page"},{"location":"psfs/vectorpsf/#Dipole-Orientation-Options","page":"VectorPSF","title":"Dipole Orientation Options","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"The VectorPSF supports both fixed and rotating dipole orientations:","category":"page"},{"location":"psfs/vectorpsf/#Fixed-Dipole","page":"VectorPSF","title":"Fixed Dipole","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"# Create a VectorPSF with specific dipole orientation\ndipole_xy = DipoleVector(0.707, 0.707, 0.0)  # 45° in XY plane\npsf = VectorPSF(1.4, 0.532, dipole_xy, n_medium=1.33)","category":"page"},{"location":"psfs/vectorpsf/#Rotating-Dipole-(Isotropic-Emission)","page":"VectorPSF","title":"Rotating Dipole (Isotropic Emission)","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"# No dipole specification required - uses incoherent average of x, y, z dipoles\npsf = VectorPSF(1.4, 0.532, n_medium=1.33)","category":"page"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"The rotating dipole model represents a freely rotating fluorophore by calculating the incoherent sum of three orthogonal dipole orientations.","category":"page"},{"location":"psfs/vectorpsf/#Key-Features","page":"VectorPSF","title":"Key Features","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"Polarization Effects: Models the vectorial nature of light propagation\nDipole Emission Patterns: Accounts for the orientation of fluorescent dipoles\nHigh-NA Accuracy: Correctly handles the optical physics at high numerical apertures\nRefractive Index Interfaces: Models light propagation across media interfaces\nSupercritical Angle Fluorescence: Captures SAF effects for emitters near coverslip","category":"page"},{"location":"psfs/vectorpsf/#Refractive-Index-Interfaces","page":"VectorPSF","title":"Refractive Index Interfaces","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"The VectorPSF accounts for refractive index mismatches:","category":"page"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"# Water sample with oil immersion objective\npsf = VectorPSF(\n    1.4, 0.532, dipole_z,\n    n_medium=1.33,   # Water sample\n    n_immersion=1.52  # Oil immersion\n)","category":"page"},{"location":"psfs/vectorpsf/#Supercritical-Angle-Fluorescence","page":"VectorPSF","title":"Supercritical Angle Fluorescence","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"A notable feature of the VectorPSF model is its ability to accurately capture Supercritical Angle Fluorescence (SAF), which occurs when light emitted by fluorophores near the coverslip is collected at angles exceeding the critical angle. SAF contribution decreases as the emitter moves away from the coverslip.","category":"page"},{"location":"psfs/vectorpsf/#Examples","page":"VectorPSF","title":"Examples","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"# Create a basic VectorPSF with Z-oriented dipole\ndipole_z = DipoleVector(0.0, 0.0, 1.0)\npsf = VectorPSF(\n    1.4,                # Numerical aperture\n    0.532,              # Wavelength in microns\n    dipole_z,           # Z-oriented dipole\n    n_medium=1.33,      # Sample is water\n    n_immersion=1.52   # Immersion oil\n)\n\n# Create a PSF with aberrations\nzc = ZernikeCoefficients(15)\nzc[11] = 0.5  # Add spherical aberration (normalized to rms = 1.0)\npsf_aberrated = VectorPSF(\n    1.4, 0.532, dipole_z,\n    n_medium=1.33,\n    base_zernike=zc\n)","category":"page"},{"location":"psfs/vectorpsf/#Limitations","page":"VectorPSF","title":"Limitations","text":"","category":"section"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"Computational Intensity: Most computationally demanding PSF model\nParameter Complexity: Requires understanding of multiple physical parameters\nSpeed: Significantly slower than other PSF models, especially with fine grid sizes","category":"page"},{"location":"psfs/vectorpsf/","page":"VectorPSF","title":"VectorPSF","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"psfs/airypsf/#AiryPSF","page":"AiryPSF","title":"AiryPSF","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"The AiryPSF model represents the diffraction-limited point spread function for a circular aperture under the paraxial approximation. Unlike the simpler Gaussian approximation, this model accurately captures the characteristic diffraction rings that appear in real microscope images.","category":"page"},{"location":"psfs/airypsf/#Mathematical-Model","page":"AiryPSF","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"The Airy pattern is defined in terms of its field amplitude:","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"A(r) = fracnusqrt4pi cdot frac2J_1(nu r)nu r","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"where:","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"r = sqrtx^2 + y^2 is the radial distance from the optical axis in microns\nnu = frac2pi cdot textNAlambda is the optical parameter\nJ_1 is the Bessel function of the first kind, order 1\ntextNA is the numerical aperture\nlambda is the wavelength in microns","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"The intensity is given by the squared magnitude of the amplitude:","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"I(r) = A(r)^2","category":"page"},{"location":"psfs/airypsf/#Constructor-and-Parameters","page":"AiryPSF","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"AiryPSF(na::Real, wavelength::Real)","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in microns","category":"page"},{"location":"psfs/airypsf/#Alternative-Constructor","page":"AiryPSF","title":"Alternative Constructor","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"AiryPSF(psf::GaussianPSF; λ::Real=0.532)","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"Creates an AiryPSF that approximates the provided GaussianPSF, using the specified wavelength.","category":"page"},{"location":"psfs/airypsf/#Key-Features","page":"AiryPSF","title":"Key Features","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"Physical Accuracy: Correctly models the diffraction pattern from a circular aperture\nDiffraction Rings: Captures the characteristic rings in real microscope images\nRayleigh Criterion: Naturally demonstrates the Rayleigh resolution criterion\nComputational Efficiency: More physically accurate than Gaussian while still being computationally efficient","category":"page"},{"location":"psfs/airypsf/#Properties-of-the-Airy-Pattern","page":"AiryPSF","title":"Properties of the Airy Pattern","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"The Airy pattern has several notable physical properties:","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"Central Maximum: Contains 83.8% of the total intensity\nFirst Minimum: Occurs at a radius of 1.22λ/NA (the Rayleigh criterion)\nFirst Ring: Contains 7.2% of the total intensity\nSubsequent Rings: Contain decreasing fractions of the intensity","category":"page"},{"location":"psfs/airypsf/#Examples","page":"AiryPSF","title":"Examples","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"Creating and using an Airy PSF:","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"# Create an Airy PSF for a high-NA objective with green light\npsf = AiryPSF(1.4, 0.532)  # NA=1.4, wavelength=532nm\n\n# Create from a GaussianPSF\ngaussian_psf = GaussianPSF(0.15)\nairy_equivalent = AiryPSF(gaussian_psf, λ=0.532)","category":"page"},{"location":"psfs/airypsf/#Limitations","page":"AiryPSF","title":"Limitations","text":"","category":"section"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"2D Only: Only valid for in-focus imaging (no defocus modeling)\nParaxial Approximation: Less accurate for very high-NA objectives (> 1.4)\nNo Aberrations: Doesn't account for optical aberrations\nNo Polarization: Doesn't model polarization effects\nNo Refractive Index Mismatches: Assumes uniform media","category":"page"},{"location":"psfs/airypsf/","page":"AiryPSF","title":"AiryPSF","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page provides practical examples demonstrating common use cases of MicroscopePSFs.jl.","category":"page"},{"location":"examples/#Rendering-a-Camera-Image-as-a-Heatmap","page":"Examples","title":"Rendering a Camera Image as a Heatmap","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To render an image so that it matches the coordinate system used by cameras, we need to place the (1,1) pixel at the top left corner and have the y axis descend. Note the deliberate use of a non-square camera pixel array to demonstrate the coordinate system.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MicroscopePSFs\nusing CairoMakie\nusing Enzyme \n\n# Create a psf \npsf = AiryPSF(1.4, 0.532)\n\n# Setup camera \nnx, ny, pixel_size = 20, 10, 0.05  # 100 nm pixels\ncamera = IdealCamera(nx, ny, pixel_size)\n\n# Render an image with a single emitter\nx_microns, y_microns, photons = 0.5, 0.25, 1000.0  # Emitter position and brightness\nimage = integrate_pixels(psf, camera, Emitter2D(x_microns, y_microns, photons))\n\n# Show image as a heatmap with pixel (1,1) at top left and y axis descending\nfig = Figure()\nax = Axis(fig[1, 1], yreversed=true, aspect=DataAspect())\nheatmap!(ax, image', colormap=:inferno)\ndisplay(fig)\nsave(\"camera_heatmap.png\", fig)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Generate-a-Simulation-with-Multiple-Emitters","page":"Examples","title":"Generate a Simulation with Multiple Emitters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates how to simulate an image with multiple emitters very quickly. This could be used to simulate large data sets of SMLM data. It makes use of the SplinePSF and finite support regions. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MicroscopePSFs\nusing CairoMakie\nusing Enzyme \n\n# Create a psf with astigmatism\nzc = ZernikeCoefficients(15)\nzc.phase[6] = 0.5  # Add vertical astigmatism \npsf = ScalarPSF(1.4, 0.532, 1.52; zernike_coeffs=zc)\n\n# Create SplinePSF for speed. This is the slowest part of the simulation.\nxy_sampling, z_sampling = 0.05, 0.1\nx_range = y_range = -1.0:xy_sampling:1.0\nz_range = -1.0:xy_sampling:1.0\npsf_spline = SplinePSF(psf, x_range, y_range, z_range)\n\n# Setup camera\nnx, ny, pixel_size = 128, 128, 0.1  # 100 nm pixels\ncamera = IdealCamera(nx, ny, pixel_size)\n\n# Create emitters\nn_emitters = 5.0 * (nx * ny * pixel_size^2)  # 5 μm^-2 of emitter density\nemitters = [Emitter3D(nx * pixel_size * rand(), ny * pixel_size * rand(), rand()-0.5, 1000.0) \n    for _ in 1:n_emitters]\n\n# Render the image using region of support option\nimage = integrate_pixels(psf_spline, camera, emitters; support=0.5)\n  \n\nfig = Figure()\nax = Axis(fig[1, 1], yreversed=true, aspect=DataAspect())\nheatmap!(ax, image', colormap=:inferno)\nhidedecorations!(ax)\ndisplay(fig)\nsave(\"camera_multi_emitters.png\", fig)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Model-a-PSF-Measurement-with-Stage-Movement","page":"Examples","title":"Model a PSF Measurement with Stage Movement","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the VectorPSF model, moving the stage and moving the emitter are not equivalent. This example demonstrates how to simulate a series of images with the stage moving in the z direction, while the emitter stays fixed on the coverslip.  This is a common experimental prodecure to measure microscope PSFs.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MicroscopePSFs\nusing CairoMakie\nusing Enzyme \n\n# Create a Vector PSF with x-dipole \ndipole = DipoleVector(1.0, 0.0, 0.0)  # x-dipole\nemitter = Emitter3D(0.5, 0.5, 0.0, 1000.0)  # Emitter on coverslip\n\n# Setup camera\nnx, ny, pixel_size = 20, 20, 0.05  # 100 nm pixels\ncamera = IdealCamera(nx, ny, pixel_size)\n\nz_stack = Vector{Array{Float64}}()\n\n# Loop over z_stage positions\nstage_positions = -1.0:0.5:1.0  # Z stage positions in microns\nfor z_stage in stage_positions\n    # Create a VectorPSF with the current z_stage position\n    psf = VectorPSF(1.4, 0.690, dipole; z_stage=z_stage)\n    \n    # Integrate over the camera pixels\n    image = integrate_pixels(psf, camera, emitter)\n    \n    # Store the image in the z_stack\n    push!(z_stack, image)\nend\n\nfig = Figure()\nfor (i, image) in enumerate(z_stack)\n    ax = Axis(fig[1, i], yreversed=true, aspect=DataAspect(), title=\"$(stage_positions[i]) μm\")\n    heatmap!(ax, image', colormap=:inferno)\n    hidedecorations!(ax)\nend\ndisplay(fig)\nsave(\"camera_z_stack_stage.png\", fig)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Example-of-Using-Enzyme-to-Differentiate-a-PSF","page":"Examples","title":"Example of Using Enzyme to Differentiate a PSF","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can differentiate both the psf(x, y, z) and the integrate_pixels(psf, camera, emitter) functions using Enzyme.jl.  ","category":"page"},{"location":"examples/#PSF-Derivatives","page":"Examples","title":"PSF Derivatives","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MicroscopePSFs\nusing CairoMakie\nusing Enzyme \n\n# Camera setup\nnx, ny, pixel_size = 20, 20, 0.1  # 100 nm pixels\ncamera = IdealCamera(nx, ny, pixel_size)\ncamera = IdealCamera(nx, ny, pixel_size)\n\n# Create PSF with astigmatism\nzc = ZernikeCoefficients(15)\nzc.phase[6] = 0.5  # Add vertical astigmatism\npsf = ScalarPSF(1.2, 0.6, 1.33; zernike_coeffs=zc)\n\n# Calc derivative image \nx_range = y_range = range(-0.5, 0.5, 40)  # PSF field coordinates\n\n# Calculate the PSF and its derivatives using Enzyme\ndx_values = [Enzyme.autodiff(Enzyme.Reverse, x -> psf(x, y, 0.0), Active, Active(x))[1][1] for x in x_range, y in y_range]\ndy_values = [Enzyme.autodiff(Enzyme.Reverse, y -> psf(x, y, 0.0), Active, Active(y))[1][1] for x in x_range, y in y_range]\ndz_values = [Enzyme.autodiff(Enzyme.Reverse, z -> psf(x, y, z), Active, Active(0.0))[1][1] for x in x_range, y in y_range]\npsf_arr = [psf(x, y, 0.0) for x in x_range, y in y_range]\n\n# Plot with CairoMakie\nfig = Figure()\nax = Axis(fig[1, 1], title = \"PSF\", yreversed=true, aspect=DataAspect())\nheatmap!(ax, psf_arr')\nax2 = Axis(fig[1, 2], title = \"dPSF/dx\", yreversed=true, aspect=DataAspect())\nheatmap!(ax2, dx_values')\nax3 = Axis(fig[1, 3], title = \"dPSF/dy\", yreversed=true, aspect=DataAspect())\nheatmap!(ax3, dy_values')\nax4 = Axis(fig[1, 4], title = \"dPSF/dz\", yreversed=true, aspect=DataAspect())\nheatmap!(ax4, dz_values')\ndisplay(fig)\nsave(\"psf_derivatives.png\", fig)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Integrated-PSF-Derivatives","page":"Examples","title":"Integrated PSF Derivatives","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MicroscopePSFs\nusing CairoMakie\nusing Enzyme \n\n# Setup camera\nnx, ny, pixel_size = 20, 20, 0.1  # 100 nm pixels\ncamera = IdealCamera(nx, ny, pixel_size)\n\n# Create PSF with astigmatism\nzc = ZernikeCoefficients(15)\nzc.phase[6] = 0.5  # Add vertical astigmatism\npsf = ScalarPSF(1.2, 0.6, 1.33; zernike_coeffs=zc)\n\nx_emitter = y_emitter = nx / 2 * pixel_size\nz_emitter, photons = 0.0, 1000.0\n\n# Use jacobian since our output is a 2D image\ndx_image = Enzyme.jacobian(set_runtime_activity(Enzyme.Forward),\n    x -> integrate_pixels(psf, camera, Emitter3D(x, y_emitter, z_emitter, photons)), \n    x_emitter)[1]\ndy_image = Enzyme.jacobian(set_runtime_activity(Enzyme.Forward),\n    y -> integrate_pixels(psf, camera, Emitter3D(x_emitter, y, z_emitter, photons)), \n    y_emitter)[1]\ndz_image = Enzyme.jacobian(set_runtime_activity(Enzyme.Forward),\n    z -> integrate_pixels(psf, camera, Emitter3D(x_emitter, y_emitter, z, photons)), \n    z_emitter)[1]\npsf_image = integrate_pixels(psf, camera, Emitter3D(x_emitter, y_emitter, z_emitter, photons))\n\n# Plot with CairoMakie\nfig2 = Figure()\nax5 = Axis(fig2[1, 1], title = \"Integrated PSF\", yreversed=true, aspect=DataAspect())\nheatmap!(ax5, psf_image')\nax6 = Axis(fig2[1, 2], title = \"dPSF/dx\", yreversed=true, aspect=DataAspect())\nheatmap!(ax6, dx_image')\nax7 = Axis(fig2[1, 3], title = \"dPSF/dy\", yreversed=true, aspect=DataAspect())\nheatmap!(ax7, dy_image')\nax8 = Axis(fig2[1, 4], title = \"dPSF/dz\", yreversed=true, aspect=DataAspect())\nheatmap!(ax8, dz_image')\ndisplay(fig2)\nsave(\"psf_integrated_derivatives.png\", fig2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"psfs/overview/#PSF-Types-Overview","page":"Overview","title":"PSF Types Overview","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"MicroscopePSFs.jl provides several PSF (Point Spread Function) models with varying complexity, accuracy, and computational requirements. This page gives an overview of the available models and guidance on selecting the appropriate PSF for your application.","category":"page"},{"location":"psfs/overview/#PSF-Model-Comparison","page":"Overview","title":"PSF Model Comparison","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"PSF Type Parameters 2D/3D Aberrations Polarization Relative Speed\nGaussianPSF σ 2D No No Fastest\nAiryPSF NA, λ 2D No No Fast\nScalarPSF NA, λ, n 3D Yes No Moderate\nVectorPSF NA, λ, dipole, n_medium, etc. 3D Yes Yes Slowest\nSplinePSF any 2D/3D Via source PSF Via source PSF Fast evaluation","category":"page"},{"location":"psfs/overview/#When-to-Use-Each-PSF-Type","page":"Overview","title":"When to Use Each PSF Type","text":"","category":"section"},{"location":"psfs/overview/#GaussianPSF","page":"Overview","title":"GaussianPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Rapid prototyping and initial development\nSimple fitting algorithms where computational speed is critical\nApplications where physical accuracy is less important than performance\nEducational purposes demonstrating basic PSF concepts","category":"page"},{"location":"psfs/overview/#AiryPSF","page":"Overview","title":"AiryPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Diffraction-limited 2D imaging simulations\nMore accurate 2D fitting that accounts for diffraction rings\nCases where you need a physically accurate model but don't need 3D capabilities\nApplications requiring a good balance between accuracy and speed","category":"page"},{"location":"psfs/overview/#ScalarPSF","page":"Overview","title":"ScalarPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"3D imaging simulations with moderate accuracy requirements\nModeling defocus, spherical aberration, and other aberrations\nApplications with moderate NA objectives (typically NA < 1.2)\nWhen you need 3D capabilities but polarization effects aren't critical","category":"page"},{"location":"psfs/overview/#VectorPSF","page":"Overview","title":"VectorPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"High-NA objectives (NA > 1.2)\nApplications where polarization effects matter\nModeling complex dipole emission patterns\nResearch requiring the highest physical accuracy\nSimulations with significant refractive index mismatches\nWhen you need to account for all types of optical aberrations","category":"page"},{"location":"psfs/overview/#SplinePSF","page":"Overview","title":"SplinePSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Accelerating computationally intensive PSF models\nUsing experimental PSF measurements from calibration beads\nPerformance-critical applications like real-time fitting\nCreating fast approximations of complex physical models","category":"page"},{"location":"psfs/overview/#Standard-Usage-Pattern","page":"Overview","title":"Standard Usage Pattern","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"All PSF types follow the same core interface, making it easy to switch between models:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"# Create a PSF (example with AiryPSF)\npsf = AiryPSF(1.4, 0.532)  # NA=1.4, λ=532nm\n\n# Evaluate at specific position\nintensity = psf(0.1, 0.2)  # at x=0.1μm, y=0.2μm\n\n# Get complex field amplitude\namp = amplitude(psf, 0.1, 0.2)\n\n# Create image grid\nx = y = range(-1, 1, length=101)  # μm\nimg = [psf(xi, yi) for yi in y, xi in x]\n\n# Camera integration example\npixel_size = 0.1  # μm\ncamera = IdealCamera(20, 20, pixel_size)\nemitter = Emitter2D(1.0, 1.0, 1000.0)  # x, y, photons\npixels = integrate_pixels(psf, camera, emitter)\n\n# Optional parameters for integration\npixels = integrate_pixels(psf, camera, emitter;\n                        support=0.5,    # Limit to 0.5μm radius\n                        sampling=3,     # 3×3 subpixel sampling\n                        threaded=true)  # Use multithreading","category":"page"},{"location":"psfs/overview/#Performance-and-Automatic-Differentiation","page":"Overview","title":"Performance and Automatic Differentiation","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"For performance optimization:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"# Standard use with multithreading (default)\npixels = integrate_pixels(psf, camera, emitter)\n\n# For automatic differentiation compatibility, disable threading\npixels = integrate_pixels(psf, camera, emitter, threaded=false)","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Most automatic differentiation frameworks don't support multithreading, so the threaded parameter allows toggling this feature when needed.","category":"page"},{"location":"psfs/overview/#Visual-Comparison","page":"Overview","title":"Visual Comparison","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Below is a comparison of the different PSF models using the same physical parameters:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"using MicroscopePSFs\nusing CairoMakie\n\nfunction compare_psf_profiles()\n    # Common parameters\n    na = 1.4\n    wavelength = 0.532  # μm\n    n = 1.518\n    \n    # Create consistent PSF instances\n    gaussian = GaussianPSF(0.22 * wavelength / na)\n    airy = AiryPSF(na, wavelength)\n    scalar = ScalarPSF(na, wavelength, n)\n    \n    # Dipole for vector PSF (z-oriented)\n    dipole_z = DipoleVector(1.0, 0.0, 0.0)\n    vector = VectorPSF(na, wavelength, dipole_z, n_medium=n)\n    \n    # Define positions for profile\n    x = range(-1, 1, length=200)  # μm\n    y = 0.0\n    z = 0.0\n    \n    # Calculate profiles\n    gaussian_profile = [gaussian(xi, y) for xi in x]\n    airy_profile = [airy(xi, y) for xi in x]\n    scalar_profile = [scalar(xi, y, z) for xi in x]\n    vector_profile = [vector(xi, y, z) for xi in x]\n    \n    # Create figure\n    fig = Figure(size=(900, 700))\n    \n    # 1D profiles\n    ax1 = Axis(fig[1, 1:2], \n              xlabel=\"Position (μm)\", \n              ylabel=\"Normalized Intensity\",\n              title=\"PSF Intensity Profiles (y=0)\")\n    \n    lines!(ax1, x, gaussian_profile, label=\"GaussianPSF\", linewidth=2, color=:blue)\n    lines!(ax1, x, airy_profile, label=\"AiryPSF\", linewidth=2, color=:red)\n    lines!(ax1, x, scalar_profile, label=\"ScalarPSF\", linewidth=2, color=:green)\n    lines!(ax1, x, vector_profile, label=\"VectorPSF\", linewidth=2, color=:purple)\n    \n    axislegend(ax1, position=:rt)\n    \n    # 2D images\n    x_grid = y_grid = range(-1, 1, length=101)  # μm\n    \n    # Calculate 2D images\n    gaussian_img = [gaussian(xi, yi) for yi in y_grid, xi in x_grid]\n    airy_img = [airy(xi, yi) for yi in y_grid, xi in x_grid]\n    scalar_img = [scalar(xi, yi, 0.0) for yi in y_grid, xi in x_grid]\n    vector_img = [vector(xi, yi, 0.0) for yi in y_grid, xi in x_grid]\n    \n    # Plot 2D images\n    psf_images = [gaussian_img, airy_img, scalar_img, vector_img]\n    titles = [\"GaussianPSF\", \"AiryPSF\", \"ScalarPSF\", \"VectorPSF\"]\n    \n    for (i, (img, title)) in enumerate(zip(psf_images, titles))\n        ax = Axis(fig[2, i], aspect=DataAspect(), \n                 title=title,\n                 xlabel=\"x (μm)\", \n                 ylabel=i==1 ? \"y (μm)\" : \"\")\n        \n        hm = heatmap!(ax, x_grid, y_grid, img, colormap=:viridis)\n    end\n    \n    return fig\nend\n\nfig = compare_psf_profiles()","category":"page"},{"location":"psfs/overview/#PSF-Conversion","page":"Overview","title":"PSF Conversion","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"The PSF types provide methods to convert between models where appropriate:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"# Convert AiryPSF to GaussianPSF approximation\nairy = AiryPSF(1.4, 0.532)\ngaussian = GaussianPSF(airy)  # Automatically uses appropriate σ\n\n# Convert GaussianPSF to equivalent AiryPSF\ngaussian = GaussianPSF(0.15)\nairy = AiryPSF(gaussian, λ=0.532)  # Need to specify wavelength","category":"page"},{"location":"psfs/overview/#Computational-Considerations","page":"Overview","title":"Computational Considerations","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"When selecting a PSF model, consider the trade-off between accuracy and computational cost:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"GaussianPSF: Closed-form expression, extremely fast\nAiryPSF: Uses Bessel functions, fast but more expensive than Gaussian\nScalarPSF: Requires numerical integration or pre-computation, moderate speed\nVectorPSF: Most computationally intensive, especially with aberrations\nSplinePSF: Fast evaluation but requires initial computation or measurement","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"For performance-critical applications, consider using SplinePSF to pre-compute a more complex PSF model for faster repeated evaluations.","category":"page"},{"location":"#MicroscopePSFs.jl","page":"Home","title":"MicroscopePSFs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for simulating microscope point spread functions (PSFs).","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MicroscopePSFs.jl provides a flexible and performant framework for calculating microscope point spread functions (PSFs) using various models, from simple 2D Gaussians to full 3D vectorial models. The package is designed for use in single-molecule localization microscopy (SMLM) and other fields requiring accurate optical simulations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple PSF models: GaussianPSF, AiryPSF, ScalarPSF, VectorPSF, and SplinePSF\nCommon interface for all PSF types with function-call syntax psf(x, y, z)\nRealistic camera pixel integration with integrate_pixels(psf, camera, emitter)\nSupport for optical aberrations via Zernike polynomials","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MicroscopePSFs\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using MicroscopePSFs\n\n# Create a GaussianPSF\npsf = GaussianPSF(0.15)  # σ = 150nm\n\n# Evaluate at a specific position\nintensity = psf(0.1, 0.2)  # Intensity at (x,y) = (0.1μm, 0.2μm)\n\n# Generate a PSF image\nx = range(-1, 1, length=101)  # μm\ny = range(-1, 1, length=101)  # μm\nimg = [psf(xi, yi) for yi in y, xi in x]\n\n# Create a simulated microscope image\nnx = 20\nny = 20\npixel_size = 0.1 # micron\ncamera = IdealCamera(nx, ny, pixel_size)  # 20x20 pixels, 100nm size\nemitter = Emitter2D(1.0, 1.0, 1000.0)               # At (1μm, 1μm) with 1000 photons\npixels = integrate_pixels(psf, camera, emitter)","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the navigation menu for detailed documentation on interfaces, conventions, and specific PSF types.","category":"page"}]
}
