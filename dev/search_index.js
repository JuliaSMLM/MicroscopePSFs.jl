var documenterSearchIndex = {"docs":
[{"location":"psfs/airy2d/#Airy2D","page":"Airy2D","title":"Airy2D","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy2D PSF model represents the diffraction-limited point spread function for a circular aperture under the paraxial approximation. Unlike the simpler Gaussian approximation, this model accurately captures the characteristic diffraction rings that appear in real microscope images.","category":"page"},{"location":"psfs/airy2d/#Mathematical-Model","page":"Airy2D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy pattern is defined in terms of its field amplitude:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"A(r) = fracnusqrt4pi cdot frac2J_1(nu r)nu r","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"where:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"r = sqrtx^2 + y^2 is the radial distance from the optical axis in microns\nnu = frac2pi cdot textNAlambda is the optical parameter\nJ_1 is the Bessel function of the first kind, order 1\ntextNA is the numerical aperture\nlambda is the wavelength in microns","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The intensity is given by the squared magnitude of the amplitude:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"I(r) = A(r)^2","category":"page"},{"location":"psfs/airy2d/#Constructor-and-Parameters","page":"Airy2D","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Airy2D(na::Real, wavelength::Real)","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in microns","category":"page"},{"location":"psfs/airy2d/#Alternative-Constructor","page":"Airy2D","title":"Alternative Constructor","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Airy2D(psf::Gaussian2D; λ::Real=0.532)","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Creates an Airy2D PSF that approximates the provided Gaussian2D PSF, using the specified wavelength.","category":"page"},{"location":"psfs/airy2d/#Key-Features","page":"Airy2D","title":"Key Features","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Physical Accuracy: Correctly models the diffraction pattern from a circular aperture\nDiffraction Rings: Captures the characteristic rings in real microscope images\nRayleigh Criterion: Naturally demonstrates the Rayleigh resolution criterion\nComputational Efficiency: More physically accurate than Gaussian while still being computationally efficient","category":"page"},{"location":"psfs/airy2d/#Properties-of-the-Airy-Pattern","page":"Airy2D","title":"Properties of the Airy Pattern","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"The Airy pattern has several notable physical properties:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Central Maximum: Contains 83.8% of the total intensity\nFirst Minimum: Occurs at a radius of 1.22λ/NA (the Rayleigh criterion)\nFirst Ring: Contains 7.2% of the total intensity\nSubsequent Rings: Contain decreasing fractions of the intensity","category":"page"},{"location":"psfs/airy2d/#Examples","page":"Airy2D","title":"Examples","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"Creating and using an Airy PSF:","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"# Create an Airy PSF for a high-NA objective with green light\npsf = Airy2D(1.4, 0.532)  # NA=1.4, wavelength=532nm\n\n# Create from a Gaussian2D PSF\ngaussian_psf = Gaussian2D(0.15)\nairy_equivalent = Airy2D(gaussian_psf, λ=0.532)","category":"page"},{"location":"psfs/airy2d/#Limitations","page":"Airy2D","title":"Limitations","text":"","category":"section"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"2D Only: Only valid for in-focus imaging (no defocus modeling)\nParaxial Approximation: Less accurate for very high-NA objectives (> 1.4)\nNo Aberrations: Doesn't account for optical aberrations\nNo Polarization: Doesn't model polarization effects\nNo Refractive Index Mismatches: Assumes uniform media","category":"page"},{"location":"psfs/airy2d/","page":"Airy2D","title":"Airy2D","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"psfs/spline_psf/#SplinePSF","page":"Spline PSF","title":"SplinePSF","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The SplinePSF model provides an efficient representation of point spread functions using B-spline interpolation. Unlike other PSF models that are based on physical principles, SplinePSF is a computational acceleration technique that can significantly speed up PSF evaluations for complex models, or represent experimentally measured PSFs.","category":"page"},{"location":"psfs/spline_psf/#Mathematical-Model","page":"Spline PSF","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The SplinePSF uses B-spline interpolation to rapidly evaluate a pre-computed PSF grid:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"I(x y z) = sum_ijk c_ijk beta^n(x - x_i) beta^n(y - y_j) beta^n(z - z_k)","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"where:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"c_ijk are the B-spline coefficients\nbeta^n is the B-spline basis function of order n (typically cubic, n=3)\nx_i y_j z_k are the knot points of the spline","category":"page"},{"location":"psfs/spline_psf/#Constructor-Options","page":"Spline PSF","title":"Constructor Options","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"SplinePSF offers several constructor methods for different use cases:","category":"page"},{"location":"psfs/spline_psf/#From-Another-PSF-Model-(Most-Common)","page":"Spline PSF","title":"From Another PSF Model (Most Common)","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# 3D PSF\nSplinePSF(psf::AbstractPSF, \n          x_range::AbstractRange,\n          y_range::AbstractRange,\n          z_range::AbstractRange;\n          order::Integer=3)\n\n# 2D PSF\nSplinePSF(psf::AbstractPSF, \n          x_range::AbstractRange,\n          y_range::AbstractRange;\n          order::Integer=3)","category":"page"},{"location":"psfs/spline_psf/#From-Pre-computed-PSF-Data","page":"Spline PSF","title":"From Pre-computed PSF Data","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# From 3D PSF stack\nSplinePSF(psf_stack::AbstractArray{<:Real,3}, \n          x_range::AbstractRange,\n          y_range::AbstractRange,\n          z_range::AbstractRange;\n          order::Integer=3)\n\n# From 2D PSF image\nSplinePSF(psf_image::AbstractArray{<:Real,2}, \n          x_range::AbstractRange,\n          y_range::AbstractRange;\n          order::Integer=3)","category":"page"},{"location":"psfs/spline_psf/#Convenience-Constructor-with-Auto-ranges","page":"Spline PSF","title":"Convenience Constructor with Auto-ranges","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"SplinePSF(psf::AbstractPSF; \n          lateral_range::Float64=2.0,\n          axial_range::Float64=1.0,\n          lateral_step::Float64=0.05,\n          axial_step::Float64=0.1,\n          order::Integer=3)","category":"page"},{"location":"psfs/spline_psf/#Parameters","page":"Spline PSF","title":"Parameters","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"psf: Source PSF to sample or pre-computed PSF data\nx_range, y_range, z_range: Coordinate ranges for the grid points\norder: Interpolation order (default: 3 for cubic B-splines)\nlateral_range: Half-width of lateral (xy) sampling range in microns\naxial_range: Half-width of axial (z) sampling range in microns\nlateral_step: Step size in microns for lateral sampling\naxial_step: Step size in microns for axial sampling","category":"page"},{"location":"psfs/spline_psf/#Key-Features","page":"Spline PSF","title":"Key Features","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Performance Acceleration: Significantly faster evaluation of complex PSFs\nExperimental PSF Support: Can represent measured PSF data from calibration beads\nSmooth Interpolation: Cubic splines provide continuous second derivatives\nFlexible Precision: Trade-off between accuracy and speed via grid density","category":"page"},{"location":"psfs/spline_psf/#B-Spline-Interpolation-Orders","page":"Spline PSF","title":"B-Spline Interpolation Orders","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"The SplinePSF uses different interpolation orders with specific trade-offs:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Order Name Properties Use Case\n0 Constant Simple nearest neighbor, no continuity Very fast, low accuracy\n1 Linear Continuous function, discontinuous derivatives Good compromise\n3 Cubic Continuous second derivatives Best accuracy (default)","category":"page"},{"location":"psfs/spline_psf/#Examples","page":"Spline PSF","title":"Examples","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Creating a SplinePSF:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# Create a source PSF to accelerate\nscalar_psf = Scalar3DPSF(1.4, 0.532, 1.518)\n\n# Define coordinate sampling grid\nx_range = y_range = range(-2.0, 2.0, step=0.1)  # μm, 0.1μm step size\nz_range = range(-2.0, 2.0, step=0.2)  # μm, 0.2μm step size\n\n# Create a spline representation (this step may take time)\nspline_psf = SplinePSF(scalar_psf, x_range, y_range, z_range)\n\n# Alternative: use the convenience constructor with auto-ranges\nspline_psf_auto = SplinePSF(scalar_psf, \n                           lateral_range=2.0, \n                           axial_range=1.0,\n                           lateral_step=0.1, \n                           axial_step=0.2)","category":"page"},{"location":"psfs/spline_psf/#Performance-Considerations","page":"Spline PSF","title":"Performance Considerations","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Initial Construction: Creating the SplinePSF can be slow for complex source PSFs\nEvaluation Speed: Once created, evaluation is very fast (typically 10-100× faster than source PSF)\nMemory Usage: Memory scales with grid size (O(nx×ny×nz))\nInterpolation Order: Higher order provides more accuracy at slight computational cost\nBoundary Handling: Returns 0 for positions outside the grid boundaries","category":"page"},{"location":"psfs/spline_psf/#Working-with-Experimental-PSFs","page":"Spline PSF","title":"Working with Experimental PSFs","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"SplinePSF can be used with experimentally measured PSF data:","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"# Define physical coordinates for the experimental PSF\npixel_size = 0.1  # μm in the image\nz_step = 0.2      # μm between z-planes\nmeasured_psf = load_experimental_psf(\"path/to/measured_psf.h5\")\n\n# Create coordinate ranges\nnx, ny, nz = size(measured_psf)\nx_center = nx ÷ 2\ny_center = ny ÷ 2\nz_center = nz ÷ 2\n\nx_range = range(-(x_center) * pixel_size, (nx-x_center-1) * pixel_size, length=nx)\ny_range = range(-(y_center) * pixel_size, (ny-y_center-1) * pixel_size, length=ny)\nz_range = range(-(z_center) * z_step, (nz-z_center-1) * z_step, length=nz)\n\n# Create the SplinePSF\nexperimental_psf = SplinePSF(measured_psf, x_range, y_range, z_range)","category":"page"},{"location":"psfs/spline_psf/#Limitations","page":"Spline PSF","title":"Limitations","text":"","category":"section"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"Sampling Range: Limited to positions within the sampled grid range\nMemory Requirements: Can use significant memory for large, dense grids\nInitial Computation: Requires upfront computation time to create\nNo Physics Propagation: Cannot directly model physical effects not in the source PSF\nPhase Information: Limited phase accuracy in complex field representation","category":"page"},{"location":"psfs/spline_psf/","page":"Spline PSF","title":"Spline PSF","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page provides a comprehensive reference of the types and functions in MicroscopePSFs.jl.","category":"page"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These types and functions form the core public API of MicroscopePSFs.jl.","category":"page"},{"location":"api/#PSF-Types","page":"API Reference","title":"PSF Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractPSF","category":"page"},{"location":"api/#MicroscopePSFs.AbstractPSF","page":"API Reference","title":"MicroscopePSFs.AbstractPSF","text":"AbstractPSF\n\nAbstract base type for all Point Spread Functions\n\n\n\n\n\n","category":"type"},{"location":"api/#2D-PSF-Models","page":"API Reference","title":"2D PSF Models","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Gaussian2D\nAiry2D","category":"page"},{"location":"api/#MicroscopePSFs.Gaussian2D","page":"API Reference","title":"MicroscopePSFs.Gaussian2D","text":"Gaussian2D{T<:AbstractFloat} <: Abstract2DPSF{T}\n\nIsotropic 2D Gaussian PSF.\n\nFields\n\nσ: Standard deviation in physical units (typically microns)\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Airy2D","page":"API Reference","title":"MicroscopePSFs.Airy2D","text":"Airy2D{T<:AbstractFloat} <: Abstract2DPSF{T}\n\n2D Airy pattern PSF using paraxial, scalar model.\n\nField amplitude for a circular aperture is given by:     A(r) = ν/√(4π) * (2J₁(νr)/(νr)) where:     ν = 2π*nₐ/λ     J₁ is the Bessel function of first kind, order 1     r is the radial distance from optical axis\n\nFields\n\nnₐ: Numerical aperture\nλ: Wavelength in microns\nν: Optical parameter = 2π*nₐ/λ\n\n\n\n\n\n","category":"type"},{"location":"api/#3D-PSF-Models","page":"API Reference","title":"3D PSF Models","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Scalar3DPSF\nVector3DPSF","category":"page"},{"location":"api/#MicroscopePSFs.Scalar3DPSF","page":"API Reference","title":"MicroscopePSFs.Scalar3DPSF","text":"Scalar3DPSF{T} <: Abstract3DPSF{T}\n\nScalar 3D PSF using explicit pupil function representation.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in microns\nn::T: Refractive index\npupil::PupilFunction{T}: Complex pupil function\nzernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}: Zernike coefficients used to create this PSF (if applicable)\n\nNotes\n\nCan be initialized with either a PupilFunction or ZernikeCoefficients using the Scalar3DPSF factory function.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Vector3DPSF","page":"API Reference","title":"MicroscopePSFs.Vector3DPSF","text":"Vector3DPSF{T<:AbstractFloat} <: Abstract3DPSF{T}\n\nVector PSF model using explicit pupil function representation. Allows direct manipulation of pupil function for custom aberrations.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in microns\nn_medium::T: Sample medium refractive index\nn_coverslip::T: Cover slip refractive index\nn_immersion::T: Immersion medium refractive index\ndipole::DipoleVector{T}: Dipole orientation\nz_stage::T: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)\nvector_pupils::VectorPupilFunction{T}: Pre-calculated pupil functions containing vector field components (Ex,Ey), dipole orientation effects, base aberrations, apodization, and all position-independent factors\nbase_pupil::Union{Nothing, PupilFunction{T}}: Base pupil function representing system aberrations\nzernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}: Zernike coefficients used to create this PSF (if applicable)\n\n\n\n\n\n","category":"type"},{"location":"api/#Data-driven-PSF","page":"API Reference","title":"Data-driven PSF","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SplinePSF","category":"page"},{"location":"api/#MicroscopePSFs.SplinePSF","page":"API Reference","title":"MicroscopePSFs.SplinePSF","text":"SplinePSF{T<:AbstractFloat, IT<:AbstractInterpolation} <: AbstractPSF\n\nA point spread function (PSF) represented as a B-spline interpolation.\n\nFields\n\nspline: The B-spline interpolation object \nx_range: Range of x-coordinates used for uniform grid interpolation\ny_range: Range of y-coordinates used for uniform grid interpolation  \nz_range: Range of z-coordinates for 3D PSFs, or nothing for 2D PSFs\noriginal_grid: Original grid data used to create the interpolation\ninterp_order: Interpolation order used (0=constant, 1=linear, 3=cubic)\n\nNotes\n\nCoordinates and ranges are in physical units (typically microns)\nPSF values are preserved from the original PSF that was sampled\nFull implementation is in spline_psf.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-Interface-Functions","page":"API Reference","title":"Core Interface Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"amplitude\nintegrate_pixels\nintegrate_pixels_amplitude","category":"page"},{"location":"api/#MicroscopePSFs.amplitude","page":"API Reference","title":"MicroscopePSFs.amplitude","text":"amplitude(p::PupilFunction, x::Real, y::Real, z::Real)\n\nCalculate complex amplitude from pupil function integration.\n\nArguments\n\np::PupilFunction: Pupil function\nx::Real: X position in μm\ny::Real: Y position in μm\nz::Real: Z position in μm\n\n\n\n\n\namplitude(psf::AbstractPSF, x::Real, y::Real)\n\nEvaluate complex field amplitude at position (x,y) relative to PSF center.\n\nArguments\n\nx, y: Position in microns relative to PSF center\n\nReturns\n\nComplex amplitude normalized such that |amplitude|² gives normalized intensity\n\nCoordinates\n\nInput coordinates (x,y) are in physical units (microns) relative to PSF center.\n\nExamples\n\npsf = Airy2D(1.4, 0.532)\namp = amplitude(psf, 0.1, 0.2)\nintensity = abs2(amp)  # Convert to intensity\n\n\n\n\n\namplitude(psf::AbstractPSF, x::Real, y::Real, z::Real)\n\nEvaluate complex field amplitude in 3D. z is axial distance from focus in microns.\n\n\n\n\n\namplitude(psf::Scalar3DPSF{T}, x::Real, y::Real, z::Real) where {T}\n\nCalculate complex amplitude at a 3D position using scalar diffraction theory.\n\nArguments\n\npsf: Scalar3DPSF instance\nx, y, z: Position in microns relative to PSF center\n\nReturns\n\nComplex amplitude at the specified position\n\nNotes\n\nUses Fourier optics to propagate from pupil to image space\nAccounts for defocus and aberrations encoded in the pupil function\n\n\n\n\n\namplitude(psf::Vector3DPSF, x::Real, y::Real, z::Real)\n\nCompute complex vector amplitude at given position.\n\nArguments\n\npsf: Vector PSF instance\nx, y: Lateral position in microns relative to PSF center\nz: Axial position in microns representing depth above the coverslip\n\nReturns\n\nVector [Ex, Ey] of complex field amplitudes\n\nNotes\n\nz coordinate represents the depth above the coverslip\nz_stage in the PSF indicates the distance the stage was moved away from the nominal focal plane\nIncludes both UAF and SAF contributions automatically\n\n\n\n\n\namplitude(psf::SplinePSF, x::Real, y::Real, z::Real)\n\nCalculate the complex amplitude of the 3D PSF at position (x, y, z).\n\nArguments\n\npsf: SplinePSF instance\nx, y, z: Coordinates in microns relative to PSF center\n\nReturns\n\nComplex amplitude = sqrt(intensity) with zero phase\n\nNotes\n\nReturns sqrt(intensity) as Complex to match the interface of other PSFs\nThe SplinePSF does not model phase information\n\n\n\n\n\namplitude(psf::SplinePSF, x::Real, y::Real)\n\nCalculate the complex amplitude of the PSF at position (x, y) with z=0.\n\nArguments\n\npsf: SplinePSF instance\nx, y: Coordinates in microns relative to PSF center\n\nReturns\n\nComplex amplitude = sqrt(intensity) with zero phase\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.integrate_pixels","page":"API Reference","title":"MicroscopePSFs.integrate_pixels","text":"integrate_pixels(\n    psf::AbstractPSF, \n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter; \n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF intensity over camera pixels with optional support region optimization.\n\nFor each pixel in the specified region, numerically integrates the PSF intensity using the specified  sampling density. Physical coordinates are relative to camera with (0,0) at top-left corner. Automatically handles z-coordinate if both PSF and emitter support it.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\npixel_edges_x::AbstractVector: X-coordinate edges of pixels in microns\npixel_edges_y::AbstractVector: Y-coordinate edges of pixels in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\n\nReturns\n\nMatrix{T}: Integrated intensities where T matches emitter.photons type\nArray is indexed as [y,x] with [1,1] at top-left pixel\nValues represent actual photon counts in each pixel based on emitter's photon value\n\nExamples\n\n# Create pixel edges for a 20x20 camera with 100nm pixels\npixel_edges_x = pixel_edges_y = 0:0.1:2.0\nemitter = Emitter2D(1.0, 1.0, 1000.0)  # Emitter at (1μm, 1μm) with 1000 photons\npsf = Gaussian2D(0.15)  # σ = 150nm\n\n# Calculate over full image\npixels = integrate_pixels(psf, pixel_edges_x, pixel_edges_y, emitter)\n\n# Calculate only within a 0.5μm radius of the emitter\npixels_roi = integrate_pixels(psf, pixel_edges_x, pixel_edges_y, emitter, support=0.5)\n\nSee also: integrate_pixels_amplitude, AbstractPSF\n\n\n\n\n\nintegrate_pixels(\n    psf::AbstractPSF, \n    camera::AbstractCamera, \n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF intensity over camera pixels with optional support region optimization.\n\nThis version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\ncamera::AbstractCamera: Camera geometry defining pixel edges in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\n\nReturns\n\nArray of pixel values with dimensions y,x\nValues are normalized to sum to 1\nArray indices start at [1,1] for top-left pixel\n\nSee also: integrate_pixels_amplitude, AbstractPSF\n\n\n\n\n\nintegrate_pixels(\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF intensity over camera pixels for multiple emitters with optional support region optimization.\n\nArguments\n\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nIf Real: radius in microns around each emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns (fixed region for all emitters)\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nArray of integrated PSF intensities with dimensions matching the camera\nValues represent actual photon counts from all emitters\n\nNotes\n\nResults are the sum of individual emitter contributions (incoherent addition)\nFor coherent addition, use integrate_pixels_amplitude and sum complex amplitudes\n\n\n\n\n\nintegrate_pixels(\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF intensity over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nArray of integrated PSF intensities with dimensions matching the camera\nValues represent actual photon counts from all emitters\n\n\n\n\n\nintegrate_pixels(\n    psf::SplinePSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF over camera pixels using interpolation.\n\nArguments\n\npsf: SplinePSF instance\ncamera: Camera geometry\nemitter: Emitter with position information\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling: Subpixel sampling density for integration accuracy\n\nReturns\n\nArray of integrated PSF intensities with dimensions [ny, nx]\nValues represent actual photon counts based on emitter's photon value\n\nNotes\n\nFor 3D SplinePSFs (when z_range is defined), requires an emitter with a z-coordinate\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude","text":"integrate_pixels_amplitude(\n    psf::AbstractPSF, \n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter; \n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF complex amplitude over camera pixels with optional support region optimization.\n\nFor each pixel in the specified region, numerically integrates the PSF amplitude using the specified sampling density. Unlike intensity integration, returns unnormalized complex amplitudes which can be used for coherent calculations. Automatically handles z-coordinate if both PSF and emitter support it.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\npixel_edges_x::AbstractVector: X-coordinate edges of pixels in microns\npixel_edges_y::AbstractVector: Y-coordinate edges of pixels in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\n\nReturns\n\nMatrix{Complex{T}}: Integrated complex amplitudes where T matches emitter.photons type\nArray is indexed as [y,x] with [1,1] at top-left pixel\nValues are not normalized to preserve complex amplitude relationships\n\nNotes\n\nFor coherent calculations, use this function instead of integrate_pixels\nReturn type is complex to support PSFs with phase information\nTo get intensity from amplitude: abs2.(integrate_pixels_amplitude(...))\n\nSee also: integrate_pixels, AbstractPSF\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::AbstractPSF, \n    camera::AbstractCamera, \n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF complex amplitude over camera pixels with optional support region optimization.\n\nThis version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf::AbstractPSF: Point spread function to integrate\ncamera::AbstractCamera: Camera geometry defining pixel edges in microns\nemitter::AbstractEmitter: Emitter with position in microns relative to camera\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling::Integer=2: Number of samples per pixel in each dimension\n\nReturns\n\nMatrix of complex amplitudes\nArray indices start at [1,1] for top-left pixel\n\nSee also: integrate_pixels, AbstractPSF\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization.\n\nArguments\n\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nArray of integrated complex amplitudes\nValues represent coherently summed field contributions\n\nNotes\n\nResults are the coherent sum of individual emitter field contributions\nFor incoherent addition, use abs2.(integrate_pixels_amplitude(...)) or use integrate_pixels\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.\n\nArguments\n\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsupport: Region to calculate for each emitter (default: Inf = full image)\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nArray of integrated complex amplitudes\nValues represent coherently summed field contributions\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::Vector3DPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2\n)\n\nSpecialized version of amplitude integration for Vector3DPSF that preserves polarization components.\n\nArguments\n\npsf: Vector3DPSF instance\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\n3D array of integrated complex amplitudes with dimensions [y, x, pol] where pol index 1 = Ex and pol index 2 = Ey\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::Vector3DPSF,\n    camera::AbstractCamera,\n    emitters::Vector{<:AbstractEmitter};\n    sampling::Integer=2\n)\n\nIntegrate PSF complex amplitude over camera pixels for multiple emitters. Special version for Vector3DPSF that preserves polarization components.\n\nArguments\n\npsf: Vector3DPSF instance\ncamera: Camera geometry defining pixel edges\nemitters: Vector of emitters with position information\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\n3D array of integrated complex amplitudes with dimensions [y, x, pol] where pol index 1 = Ex and pol index 2 = Ey\n\nNotes\n\nResults are the coherent sum of individual emitter field contributions\n\n\n\n\n\nintegrate_pixels_amplitude(\n    psf::SplinePSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}} = Inf,\n    sampling::Integer=2\n)\n\nIntegrate PSF amplitude (complex) over camera pixels.\n\nArguments\n\npsf: SplinePSF instance\ncamera: Camera geometry\nemitter: Emitter with position information\nsupport: Region to calculate (default: Inf = full image)\nIf Real: radius in microns around emitter\nIf Tuple: explicit (xmin, xmax, ymin, ymax) in microns\nsampling: Subpixel sampling density for integration accuracy\n\nReturns\n\nArray of integrated PSF complex amplitudes with dimensions [ny, nx]\n\nNotes\n\nFor 3D SplinePSFs (when z_range is defined), requires an emitter with a z-coordinate\n\n\n\n\n\n","category":"function"},{"location":"api/#Pupil-Functions","page":"API Reference","title":"Pupil Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PupilFunction\nVectorPupilFunction","category":"page"},{"location":"api/#MicroscopePSFs.PupilFunction","page":"API Reference","title":"MicroscopePSFs.PupilFunction","text":"PupilFunction{T}\n\nRepresents a pupil function with physical parameters.\n\nFields\n\nnₐ: Numerical aperture\nλ: Wavelength in μm\nn: Refractive index\nfield: Complex-valued pupil function array\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.VectorPupilFunction","page":"API Reference","title":"MicroscopePSFs.VectorPupilFunction","text":"VectorPupilFunction{T}\n\nVector pupil function storing Ex,Ey field components as PupilFunctions.\n\nFields\n\nnₐ::T: Numerical aperture\nλ::T: Wavelength in μm\nn_medium::T: Refractive index of the sample medium\nn_coverslip::T: Refractive index of the coverslip\nn_immersion::T: Refractive index of the immersion medium\nEx::PupilFunction{T}: x-component of electric field\nEy::PupilFunction{T}: y-component of electric field\n\n\n\n\n\n","category":"type"},{"location":"api/#Zernike-Module","page":"API Reference","title":"Zernike Module","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ZernikeCoefficients\nZernikeIndexing\nOSA\nNoll","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.ZernikeCoefficients","page":"API Reference","title":"MicroscopePSFs.Zernike.ZernikeCoefficients","text":"ZernikeCoefficients{T<:Real}\n\nMutable structure to hold Zernike coefficients for both magnitude and phase of a pupil function.\n\nFields\n\nmag::Vector{T}: Coefficients for magnitude\nphase::Vector{T}: Coefficients for phase\n\nNotes\n\nFirst coefficient (index 1) typically represents piston\nMagnitude coefficients are typically normalized with mag[1] = 1\nPhase coefficients represent phase in radians\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Zernike.ZernikeIndexing","page":"API Reference","title":"MicroscopePSFs.Zernike.ZernikeIndexing","text":"ZernikeIndexing\n\nEnum type for different Zernike polynomial indexing conventions. Used to specify which indexing scheme to use in calculations.\n\nValues\n\nOSA: OSA/ANSI standard indexing\nNoll: Noll indexing scheme\n\n\n\n\n\n","category":"type"},{"location":"api/#Aberration-Functions","page":"API Reference","title":"Aberration Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"add_aberration!\nadd_defocus!\nadd_astigmatism!\nadd_coma!\nadd_spherical!\nreset!\nscale!\nmerge!\nrms\ntrim!\nsignificant_terms","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.add_aberration!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_aberration!","text":"add_aberration!(coeffs::ZernikeCoefficients, \n               index::Integer, \n               mag_value::Real=0, \n               phase_value::Real=0;\n               indexing::ZernikeIndexing=OSA) -> ZernikeCoefficients\n\nAdd aberration terms to existing coefficients.\n\nArguments\n\ncoeffs: ZernikeCoefficients to modify\nindex: Index of Zernike term (starting at 0)\nmag_value: Value to add to magnitude coefficient\nphase_value: Value to add to phase coefficient\nindexing: Indexing convention for the index\n\nNotes\n\nIndex is 0-based to match standard Zernike notation\nReturns the modified coefficients for chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_defocus!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_defocus!","text":"add_defocus!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd defocus aberration (n=2, l=0).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_astigmatism!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_astigmatism!","text":"add_astigmatism!(coeffs::ZernikeCoefficients, \n                 amount::Real, \n                 angle::Real=0.0) -> ZernikeCoefficients\n\nAdd astigmatism with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_coma!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_coma!","text":"add_coma!(coeffs::ZernikeCoefficients, \n          amount::Real, \n          angle::Real=0.0) -> ZernikeCoefficients\n\nAdd coma with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_spherical!","page":"API Reference","title":"MicroscopePSFs.Zernike.add_spherical!","text":"add_spherical!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd primary spherical aberration.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.reset!","page":"API Reference","title":"MicroscopePSFs.Zernike.reset!","text":"reset!(coeffs::ZernikeCoefficients) -> ZernikeCoefficients\n\nReset coefficients to default state (mag[1]=1, all others zero).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.scale!","page":"API Reference","title":"MicroscopePSFs.Zernike.scale!","text":"scale!(coeffs::ZernikeCoefficients, factor::Real) -> ZernikeCoefficients\n\nScale all coefficients (except piston) by given factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.rms","page":"API Reference","title":"MicroscopePSFs.Zernike.rms","text":"rms(coeffs::ZernikeCoefficients) -> Tuple{Float64,Float64}\n\nCalculate RMS values for magnitude and phase coefficients (excluding piston).\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.trim!","page":"API Reference","title":"MicroscopePSFs.Zernike.trim!","text":"trim!(coeffs::ZernikeCoefficients, threshold::Real) -> ZernikeCoefficients\n\nSet coefficients below threshold (relative to RMS) to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.significant_terms","page":"API Reference","title":"MicroscopePSFs.Zernike.significant_terms","text":"significant_terms(coeffs::ZernikeCoefficients, \n                 threshold::Real=0.01) -> Vector{Tuple{Int,Float64,Float64}}\n\nReturn list of significant terms: (index, magnitude, phase) above threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zernike-Polynomial-Functions","page":"API Reference","title":"Zernike Polynomial Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"zernikepolynomial\nradialpolynomial\nmax_radial_order\nevaluate_pupil","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.zernikepolynomial","page":"API Reference","title":"MicroscopePSFs.Zernike.zernikepolynomial","text":"zernikepolynomial(n::Integer, l::Integer, ρ::Real, ϕ::Real) -> Real\n\nCompute the complete Zernike polynomial Z_n^l(ρ,ϕ).\n\nArguments\n\nn: Radial order\nl: Azimuthal frequency (signed)\nρ: Radial coordinate (0 ≤ ρ ≤ 1)\nϕ: Azimuthal angle in radians\n\nNotes\n\nUses born-wolf normalization\nCombines radial polynomial with appropriate trigonometric function\n\n\n\n\n\nzernikepolynomial(j::Integer, ρ::Real, ϕ::Real, indexing::ZernikeIndexing=OSA) -> Real\n\nCompute Zernike polynomial using single-index notation.\n\nArguments\n\nj: Polynomial index (OSA or Noll)\nρ: Radial coordinate\nϕ: Azimuthal angle\nindexing: Index convention to use (OSA or Noll)\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.radialpolynomial","page":"API Reference","title":"MicroscopePSFs.Zernike.radialpolynomial","text":"radialpolynomial(n::Integer, m::Integer, ρ::Real) -> Real\n\nCompute the radial component R_n^m(ρ) of the Zernike polynomial.\n\nArguments\n\nn: Radial order\nm: Azimuthal order (absolute value of azimuthal frequency)\nρ: Radial coordinate (0 ≤ ρ ≤ 1)\n\nNotes\n\nReturns 0 for ρ > 1\nNormalizes according to born-wolf convention\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.evaluate_pupil","page":"API Reference","title":"MicroscopePSFs.Zernike.evaluate_pupil","text":"evaluate_pupil(coeffs::ZernikeCoefficients, grid_size::Integer;\n              indexing::ZernikeIndexing=OSA) -> Matrix{Complex{Float64}}\n\nGenerate complex pupil function from Zernike coefficients.\n\nArguments\n\ncoeffs: ZernikeCoefficients containing magnitude and phase coefficients\ngrid_size: Size of the output grid (gridsize × gridsize)\nindexing: Indexing convention for coefficients (OSA or Noll)\n\nReturns\n\nComplex-valued matrix representing the pupil function\n\nNotes\n\nOutput grid is normalized to unit circle\nPoints outside unit circle are set to zero\nPhase is applied as exp(iϕ)\n\n\n\n\n\n","category":"function"},{"location":"api/#Index-Conversion","page":"API Reference","title":"Index Conversion","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"nl2osa\nosa2nl\nnl2noll\nnoll2nl\nosa2noll\nnoll2osa\nconvert_index","category":"page"},{"location":"api/#Emitters","page":"API Reference","title":"Emitters","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"DipoleVector\nDipoleEmitter3D","category":"page"},{"location":"api/#MicroscopePSFs.DipoleVector","page":"API Reference","title":"MicroscopePSFs.DipoleVector","text":"DipoleVector{T} <: Real\n\nA 3D vector representing the dipole orientation.\n\nFields\n\npx::T: x component of the dipole vector\npy::T: y component of the dipole vector\npz::T: z component of the dipole vector\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.DipoleEmitter3D","page":"API Reference","title":"MicroscopePSFs.DipoleEmitter3D","text":"DipoleEmitter3D{T} <: AbstractEmitter\n\n3D dipole emitter with position, orientation and optical properties.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns \nz::T: z-coordinate in microns\nphotons::T: number of photons\ndipole::DipoleVector{T}: dipole orientation vector\n\n\n\n\n\n","category":"type"},{"location":"api/#I/O-Functions","page":"API Reference","title":"I/O Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"save_psf\nload_psf","category":"page"},{"location":"api/#MicroscopePSFs.save_psf","page":"API Reference","title":"MicroscopePSFs.save_psf","text":"save_psf(filename::String, object; metadata::Dict=Dict())\n\nSave a PSF or related object (e.g., ZernikeCoefficients, PupilFunction) to an HDF5 file.\n\nArguments\n\nfilename: Path where the PSF will be saved\nobject: Object to save (PSF, ZernikeCoefficients, PupilFunction, etc.)\nmetadata: Optional dictionary of additional metadata to include\n\nReturns\n\nfilename for chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#Complete-API-(All-Documented-Functions)","page":"API Reference","title":"Complete API (All Documented Functions)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section lists additional internal functions and types that are documented but not part of the public API.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MicroscopePSFs]\nPublic = false","category":"page"},{"location":"api/#MicroscopePSFs.Abstract2DPSF","page":"API Reference","title":"MicroscopePSFs.Abstract2DPSF","text":"Abstract2DPSF{T<:AbstractFloat}\n\nAbstract type for all 2D point spread functions. Parameterized by numeric type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs.Abstract3DPSF","page":"API Reference","title":"MicroscopePSFs.Abstract3DPSF","text":"Abstract3DPSF{T<:AbstractFloat}\n\nAbstract type for all 3D point spread functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MicroscopePSFs._check_normalization-Tuple{Any}","page":"API Reference","title":"MicroscopePSFs._check_normalization","text":"_check_normalization(values; tol=1e-6)\n\nInternal function to verify array sums to 1 within tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._integrate_pixels_core!-Tuple{AbstractArray, AbstractVector, AbstractVector, Function, Real, Real}","page":"API Reference","title":"MicroscopePSFs._integrate_pixels_core!","text":"_integrate_pixels_core!(\n    result::AbstractArray,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    func::Function,\n    emitter_x::Real,\n    emitter_y::Real;\n    sampling::Integer=2\n)\n\nInternal function implementing the core pixel integration logic. Supports both scalar and vector/tensor return types from the function.\n\nArguments\n\nresult: Pre-allocated array where integration results will be stored\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nfunc: Function to evaluate at PSF coordinates - can return scalar, vector, or tensor\nemitter_x, emitter_y: Emitter coordinates in same units as pixel edges\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nresult array filled with integration values\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._integrate_pixels_generic!-Tuple{AbstractArray, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function}","page":"API Reference","title":"MicroscopePSFs._integrate_pixels_generic!","text":"_integrate_pixels_generic!(\n    result::AbstractArray,\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter,\n    f::Function;\n    sampling::Integer=2\n)\n\nGeneric wrapper for PSF integration that handles coordinate systems and validation. Automatically handles z-coordinates when both PSF and emitter support them. Supports functions that return either scalars or vectors/tensors.\n\nArguments\n\nresult: Pre-allocated array where results will be stored\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nf: Function to evaluate (e.g., (p,x,y) -> p(x,y) for intensity)\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nresult array filled with integration values\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._integrate_pixels_generic-Union{Tuple{T}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}, Any}} where T","page":"API Reference","title":"MicroscopePSFs._integrate_pixels_generic","text":"_integrate_pixels_generic(\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter,\n    f::Function,\n    ::Type{T},\n    output_dims=();\n    sampling::Integer=2\n) where T\n\nInternal generic integration routine used by both intensity and amplitude integration. Creates a new result array and delegates to the in-place version. Supports both scalar and vector/tensor return types.\n\nArguments\n\noutput_dims: Additional dimensions for the result array beyond the basic [y,x] dimensions. For vector returns (e.g., [Ex, Ey]), set output_dims=(2,) for a [y,x,2] result array.\n\nReturns\n\nArray with dimensions [y,x] or [y,x,output_dims...] depending on the function's return type\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_check_required_fields-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_check_required_fields","text":"_io_check_required_fields(group, fields)\n\nCheck if all required fields exist in an HDF5 group. Throws an error if any required field is missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_complex_array-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_load_complex_array","text":"_io_load_complex_array(group, name)\n\nLoad a complex array from an HDF5 group by combining real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_range-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_load_range","text":"_io_load_range(group, name)\n\nLoad a range from an HDF5 group by reconstructing from start, step, and length.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_load_zernike_coeffs-Tuple{Any}","page":"API Reference","title":"MicroscopePSFs._io_load_zernike_coeffs","text":"_io_load_zernike_coeffs(file; group_name=\"zernike_coefficients\")\n\nLoad ZernikeCoefficients from an HDF5 file from a specified group. Returns nothing if the group doesn't exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_complex_array-Tuple{Any, Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_complex_array","text":"_io_save_complex_array(group, name, array)\n\nSave a complex array to an HDF5 group by splitting into real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_pupil_params-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_pupil_params","text":"_io_save_pupil_params(params, pupil)\n\nSave common pupil parameters to an HDF5 group.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_range-Tuple{Any, Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_range","text":"_io_save_range(group, name, range)\n\nSave a range to an HDF5 group by storing start, step, and length.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._io_save_zernike_coeffs-Tuple{Any, Any}","page":"API Reference","title":"MicroscopePSFs._io_save_zernike_coeffs","text":"_io_save_zernike_coeffs(file, coeffs; group_name=\"zernike_coefficients\")\n\nSave ZernikeCoefficients to an HDF5 file in a specified group. Does nothing if coeffs is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Airy2D}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Airy2D})\n\nLoad an Airy2D PSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Gaussian2D}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Gaussian2D})\n\nLoad a Gaussian2D PSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{PupilFunction}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{PupilFunction})\n\nLoad a PupilFunction from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Scalar3DPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Scalar3DPSF})\n\nLoad a Scalar3DPSF from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{SplinePSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{SplinePSF})\n\nLoad a SplinePSF from an HDF5 file, reconstructing it using the standard constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{Vector3DPSF}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{Vector3DPSF})\n\nLoad a Vector3DPSF from an HDF5 file, reconstructing all components.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPupilFunction}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{VectorPupilFunction})\n\nLoad a VectorPupilFunction from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ZernikeCoefficients}}","page":"API Reference","title":"MicroscopePSFs._load_psf_impl","text":"_load_psf_impl(file::HDF5.File, ::Type{ZernikeCoefficients})\n\nLoad ZernikeCoefficients from an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._sample_psf_2d-Tuple{AbstractPSF, AbstractRange, AbstractRange}","page":"API Reference","title":"MicroscopePSFs._sample_psf_2d","text":"_sample_psf_2d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange)\n\nInternal helper function to sample a 2D PSF on a regular grid. Returns an array with dimensions [y, x] containing raw PSF values.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._sample_psf_3d-Tuple{AbstractPSF, AbstractRange, AbstractRange, AbstractRange}","page":"API Reference","title":"MicroscopePSFs._sample_psf_3d","text":"_sample_psf_3d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange, z_range::AbstractRange)\n\nInternal helper function to sample a 3D PSF on a regular grid. Returns an array with dimensions [y, x, z] containing raw PSF values.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Airy2D}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Airy2D)\n\nSave an Airy2D PSF to an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Gaussian2D}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Gaussian2D)\n\nSave a Gaussian2D PSF to an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, PupilFunction}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, pupil::PupilFunction)\n\nSave a PupilFunction to an HDF5 file, including physical parameters and complex field.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Scalar3DPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Scalar3DPSF)\n\nSave a Scalar3DPSF to an HDF5 file, including pupil function and any Zernike coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, SplinePSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::SplinePSF)\n\nSave a SplinePSF to an HDF5 file, including the original grid data used to create the spline interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, Vector3DPSF}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, psf::Vector3DPSF)\n\nSave a Vector3DPSF to an HDF5 file, including all optical parameters, dipole orientation, and vector pupil fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, pupil::VectorPupilFunction)\n\nSave a VectorPupilFunction to an HDF5 file, including all physical parameters and both Ex and Ey field components.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ZernikeCoefficients}","page":"API Reference","title":"MicroscopePSFs._save_psf_impl","text":"_save_psf_impl(file::HDF5.File, zc::ZernikeCoefficients)\n\nSave ZernikeCoefficients to an HDF5 file, storing magnitude and phase arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.apply_aperture!","page":"API Reference","title":"MicroscopePSFs.apply_aperture!","text":"apply_aperture!(p::PupilFunction, radius::Real=1.0)\n\nApply circular aperture to pupil function. Radius is relative to NA.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.apply_defocus!-Tuple{PupilFunction, Real}","page":"API Reference","title":"MicroscopePSFs.apply_defocus!","text":"apply_defocus!(p::PupilFunction, z::Real)\n\nApply defocus phase to pupil function for propagation distance z.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_apodization-NTuple{4, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_apodization","text":"calculate_apodization(kr2::Real, λ::Real, \n                    n_medium::Real, n_immersion::Real)\n\nCalculate apodization factor for energy conservation.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn_medium: Refractive index of the sample medium\nn_immersion: Refractive index of the immersion medium\n\nReturns\n\nApodization factor for energy conservation\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_axial_phase","page":"API Reference","title":"MicroscopePSFs.calculate_axial_phase","text":"calculate_axial_phase(z::Real, z_stage::Real, kz_medium::Complex, \n                     kz_coverslip::Complex, kz_immersion::Complex,\n                     coverslip_thickness::Real=0.17)\n\nCalculate total axial phase from defocus.\n\nArguments\n\nz: Emitter position relative to the coverslip (depth above the coverslip in μm)\nz_stage: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)\nkz_medium: z-component of wave vector in sample medium\nkz_coverslip: z-component of wave vector in coverslip\nkz_immersion: z-component of wave vector in immersion medium\ncoverslip_thickness: Thickness of coverslip in mm (default: 0.17mm)\n\nReturns\n\nDefocus phase\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.calculate_dipole_field_components-Tuple{Complex, Complex, Complex, DipoleVector, Complex, Complex}","page":"API Reference","title":"MicroscopePSFs.calculate_dipole_field_components","text":"calculate_dipole_field_components(ϕ::Complex, sinθ::Complex, cosθ::Complex,\n                                dipole::DipoleVector, Tp::Complex, Ts::Complex)\n\nCalculate vectorial field components for a dipole orientation.\n\nArguments\n\nϕ: Azimuthal angle in pupil plane\nsinθ: Sine of polar angle\ncosθ: Cosine of polar angle\ndipole: Dipole orientation vector\nTp: p-polarization transmission coefficient\nTs: s-polarization transmission coefficient\n\nReturns\n\nTuple (Ex, Ey) of complex field components\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_interface_fresnel-NTuple{4, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_interface_fresnel","text":"calculate_interface_fresnel(kr2::Real, λ::Real, \n                          n1::Real, n2::Real)\n\nCalculate Fresnel transmission coefficients for a single interface.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn1: Refractive index of first medium\nn2: Refractive index of second medium\n\nReturns\n\nTuple of (Tp, Ts): p and s polarization transmission coefficients\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.calculate_wave_vectors-NTuple{5, Real}","page":"API Reference","title":"MicroscopePSFs.calculate_wave_vectors","text":"calculate_wave_vectors(kr2::Real, λ::Real, \n                     n_medium::Real, n_coverslip::Real, n_immersion::Real)\n\nCalculate z-components of wave vectors in all three media.\n\nArguments\n\nkr2: Squared lateral spatial frequency\nλ: Wavelength in microns\nn_medium: Refractive index of the sample medium\nn_coverslip: Refractive index of the coverslip\nn_immersion: Refractive index of the immersion medium\n\nReturns\n\nTuple of (kzmedium, kzcoverslip, kz_immersion): z-components of wave vectors in each medium\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.fill_vector_pupils!","page":"API Reference","title":"MicroscopePSFs.fill_vector_pupils!","text":"fill_vector_pupils!(vpupil::VectorPupilFunction, dipole::DipoleVector,\n                  base_pupil::Union{Nothing, PupilFunction}=nothing)\n\nFill vector pupil function with field components including dipole orientation, base aberrations, and proper apodization.\n\nThis pre-calculates all position-independent factors of the pupil function.\n\nArguments\n\nvpupil: Vector pupil function to fill\ndipole: Dipole orientation vector\nbase_pupil: Optional base aberration pupil function\n\nReturns\n\nFilled and normalized vector pupil function\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.get_pixel_indices-Tuple{AbstractVector, AbstractVector, AbstractEmitter, Union{Real, NTuple{4, Real}}}","page":"API Reference","title":"MicroscopePSFs.get_pixel_indices","text":"get_pixel_indices(\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter,\n    support::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}}\n) -> Tuple{UnitRange{Int},UnitRange{Int}}\n\nGet the pixel indices that overlap with the support region.\n\nArguments\n\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nsupport: Region of interest, either a radius or explicit bounds (xmin, xmax, ymin, ymax)\n\nReturns\n\nTuple of (irange, jrange) with pixel indices that cover the support region\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels!","text":"integrate_pixels!(\n    result::AbstractMatrix{T},\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2\n) where T <: Real\n\nIntegrate PSF intensity over camera pixels using camera object, storing the result in a pre-allocated matrix.\n\nArguments\n\nresult: Pre-allocated array where results will be stored\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nThe result array, now filled with integrated intensities\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels!","text":"integrate_pixels!(\n    result::AbstractMatrix{T},\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter;\n    sampling::Integer=2\n) where T <: Real\n\nIntegrate PSF intensity over camera pixels, storing the result in a pre-allocated matrix. Automatically uses z-coordinate if both PSF and emitter support it.\n\nArguments\n\nresult: Pre-allocated array where results will be stored\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nThe result array, now filled with integrated intensities scaled by emitter.photons\n\nNotes\n\nArray is indexed as [y,x] with [1,1] at top-left pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude!","text":"integrate_pixels_amplitude!(\n    result::AbstractMatrix{Complex{T}},\n    psf::AbstractPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2\n) where T <: Real\n\nIntegrate PSF complex amplitude over camera pixels using camera object, storing the result in a pre-allocated matrix.\n\nArguments\n\nresult: Pre-allocated complex array where results will be stored\npsf: Point spread function to integrate\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nThe result array, now filled with integrated complex amplitudes\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude!","text":"integrate_pixels_amplitude!(\n    result::AbstractMatrix{Complex{T}},\n    psf::AbstractPSF,\n    pixel_edges_x::AbstractVector,\n    pixel_edges_y::AbstractVector,\n    emitter::AbstractEmitter;\n    sampling::Integer=2\n) where T <: Real\n\nIntegrate PSF complex amplitude over camera pixels, storing the result in a pre-allocated matrix. Automatically uses z-coordinate if both PSF and emitter support it.\n\nArguments\n\nresult: Pre-allocated complex array where results will be stored\npsf: Point spread function to integrate\npixel_edges_x, pixel_edges_y: Arrays defining pixel edge coordinates\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nThe result array, now filled with integrated complex amplitudes\n\nNotes\n\nArray is indexed as [y,x] with [1,1] at top-left pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 3}, Vector3DPSF, AbstractCamera, AbstractEmitter}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.integrate_pixels_amplitude!","text":"integrate_pixels_amplitude!(\n    result::AbstractArray{Complex{T},3},\n    psf::Vector3DPSF,\n    camera::AbstractCamera,\n    emitter::AbstractEmitter;\n    sampling::Integer=2\n) where T <: Real\n\nSpecial version of amplitude integration for Vector3DPSF that preserves polarization components. Uses the flexible core integration function that handles vector returns.\n\nArguments\n\nresult: Pre-allocated 3D complex array where results will be stored, dimensions [y, x, pol]\npsf: Vector3DPSF instance\ncamera: Camera geometry defining pixel edges\nemitter: Emitter with position information\nsampling: Subpixel sampling density (default: 2)\n\nReturns\n\nThe result array, filled with integrated complex amplitudes for each polarization\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kmax-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.kmax","text":"kmax(p::PupilFunction)\n\nGet maximum spatial frequency in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kmax-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.kmax","text":"Get maximum spatial frequency in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kpixelsize-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.kpixelsize","text":"kpixelsize(p::PupilFunction)\n\nGet pupil plane sampling in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.kpixelsize-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.kpixelsize","text":"Get pupil plane sampling in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.k₀-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.k₀","text":"k₀(p::PupilFunction)\n\nGet central wavevector magnitude in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.k₀-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.k₀","text":"Get central wavevector magnitude in μm⁻¹\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.normalize!-Tuple{PupilFunction}","page":"API Reference","title":"MicroscopePSFs.normalize!","text":"normalize!(p::PupilFunction)\n\nNormalize pupil function to unit energy using Parseval's theorem.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.normalize!-Tuple{VectorPupilFunction}","page":"API Reference","title":"MicroscopePSFs.normalize!","text":"normalize!(p::VectorPupilFunction)\n\nNormalize the electric field components of the vector pupil function. Ensures total energy across both components equals 1.\n\nArguments\n\np: Vector pupil function to normalize\n\nReturns\n\nNormalized vector pupil function\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.supports_3d-Tuple{Type{<:AbstractPSF}}","page":"API Reference","title":"MicroscopePSFs.supports_3d","text":"supports_3d(psf_type::Type{<:AbstractPSF}) -> Bool\n\nCheck if a PSF type supports 3D evaluation via psf(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.update_pupils!-Tuple{Vector3DPSF}","page":"API Reference","title":"MicroscopePSFs.update_pupils!","text":"update_pupils!(psf::Vector3DPSF) -> Vector3DPSF\n\nUpdate the vector pupil function based on stored Zernike coefficients and/or base pupil. This is useful after modifying aberrations to regenerate the pupil fields.\n\nArguments\n\npsf: Vector3DPSF to update\n\nReturns\n\nUpdated Vector3DPSF\n\nNotes\n\nRequires either stored Zernike coefficients or a base pupil\nReturns the updated PSF for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#Zernike-Module-Internal-API","page":"API Reference","title":"Zernike Module Internal API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MicroscopePSFs.Zernike]\nPublic = false","category":"page"},{"location":"api/#MicroscopePSFs.Zernike.add_astigmatism!-2","page":"API Reference","title":"MicroscopePSFs.Zernike.add_astigmatism!","text":"add_astigmatism!(coeffs::ZernikeCoefficients, \n                 amount::Real, \n                 angle::Real=0.0) -> ZernikeCoefficients\n\nAdd astigmatism with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_coma!-2","page":"API Reference","title":"MicroscopePSFs.Zernike.add_coma!","text":"add_coma!(coeffs::ZernikeCoefficients, \n          amount::Real, \n          angle::Real=0.0) -> ZernikeCoefficients\n\nAdd coma with specified magnitude and angle.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.add_defocus!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.add_defocus!","text":"add_defocus!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd defocus aberration (n=2, l=0).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.add_spherical!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.add_spherical!","text":"add_spherical!(coeffs::ZernikeCoefficients, amount::Real) -> ZernikeCoefficients\n\nAdd primary spherical aberration.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.build_zernike_basis-Tuple{Integer, Integer}","page":"API Reference","title":"MicroscopePSFs.Zernike.build_zernike_basis","text":"build_zernike_basis(grid_size::Integer, num_terms::Integer;\n                   indexing::ZernikeIndexing=OSA) -> Matrix{Float64}\n\nBuild a matrix of Zernike polynomials for least-squares fitting.\n\nArguments\n\ngrid_size: Size of the sampling grid\nnum_terms: Number of Zernike terms to include\nindexing: Indexing convention for polynomials\n\nReturns\n\nMatrix of size (validpoints, numterms) containing Zernike values\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.evaluate_polynomial_grid-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"MicroscopePSFs.Zernike.evaluate_polynomial_grid","text":"evaluate_polynomial_grid(n::Integer, l::Integer, grid_size::Integer) -> Matrix{Float64}\n\nGenerate a grid of Zernike polynomial values for visualization.\n\nArguments\n\nn: Radial order\nl: Azimuthal frequency\ngrid_size: Size of output grid\n\nReturns\n\nMatrix of polynomial values over [-1,1] × [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.fit_error-Tuple{AbstractMatrix{<:Complex}, ZernikeCoefficients}","page":"API Reference","title":"MicroscopePSFs.Zernike.fit_error","text":"fit_error(pupil::AbstractMatrix{<:Complex}, coeffs::ZernikeCoefficients;\n         indexing::ZernikeIndexing=OSA) -> Float64\n\nCalculate RMS error between pupil and its Zernike fit.\n\nReturns\n\nRMS error normalized to mean pupil magnitude\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.get_nl","page":"API Reference","title":"MicroscopePSFs.Zernike.get_nl","text":"get_nl(j::Integer, indexing::ZernikeIndexing=OSA) -> Tuple{Int,Int}\n\nGet (n,l) indices from either OSA or Noll index.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.merge!","page":"API Reference","title":"MicroscopePSFs.Zernike.merge!","text":"merge!(target::ZernikeCoefficients, \n       source::ZernikeCoefficients, \n       weight::Real=1.0) -> ZernikeCoefficients\n\nMerge source coefficients into target with optional weighting.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.propagate_field-Union{Tuple{T}, Tuple{ZernikeCoefficients{T}, Vararg{T, 6}}} where T<:Real","page":"API Reference","title":"MicroscopePSFs.Zernike.propagate_field","text":"propagate_field(coeffs::ZernikeCoefficients{T},\n               λ::T, n::T, nₐ::T,\n               r::T, φ::T, z::T;\n               nk::Integer=100) where {T<:Real}\n\nPropagate field from pupil described by Zernike coefficients to point (r,φ,z).\n\nU(r,φ,z) = 2π ∫₀^kmax dkr kr e^{2πiz√(k²-kr²)} ∑{n,m} Rn^m Jm(2πkr r)[Ca cos(mφ) + Cb sin(mφ)]\n\nCa is the complex coefficient for the Zernike mode (n,m) and Cb is the complex coefficient for (n,-m).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.rms-Tuple{ZernikeCoefficients}","page":"API Reference","title":"MicroscopePSFs.Zernike.rms","text":"rms(coeffs::ZernikeCoefficients) -> Tuple{Float64,Float64}\n\nCalculate RMS values for magnitude and phase coefficients (excluding piston).\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.scale!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.scale!","text":"scale!(coeffs::ZernikeCoefficients, factor::Real) -> ZernikeCoefficients\n\nScale all coefficients (except piston) by given factor.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.significant_terms-2","page":"API Reference","title":"MicroscopePSFs.Zernike.significant_terms","text":"significant_terms(coeffs::ZernikeCoefficients, \n                 threshold::Real=0.01) -> Vector{Tuple{Int,Float64,Float64}}\n\nReturn list of significant terms: (index, magnitude, phase) above threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#MicroscopePSFs.Zernike.trim!-Tuple{ZernikeCoefficients, Real}","page":"API Reference","title":"MicroscopePSFs.Zernike.trim!","text":"trim!(coeffs::ZernikeCoefficients, threshold::Real) -> ZernikeCoefficients\n\nSet coefficients below threshold (relative to RMS) to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#MicroscopePSFs.Zernike.unwrap_phase-Tuple{AbstractVector{<:Real}}","page":"API Reference","title":"MicroscopePSFs.Zernike.unwrap_phase","text":"unwrap_phase(phase::AbstractVector{<:Real}) -> Vector{Float64}\n\nUnwrap phase values to handle 2π discontinuities.\n\n\n\n\n\n","category":"method"},{"location":"conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"This page documents the conventions used throughout MicroscopePSFs.jl.","category":"page"},{"location":"conventions/#Coordinate-System","page":"Conventions","title":"Coordinate System","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"MicroscopePSFs.jl uses the following coordinate system conventions:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Physical units: All distances are in micrometers (μm)\nOrigin: The origin (0,0,0) is at the PSF center\nAxes:\nx-axis: Lateral direction (positive right)\ny-axis: Lateral direction (positive down)\nz-axis: Axial direction (positive away from objective)","category":"page"},{"location":"conventions/#Image-Coordinates","page":"Conventions","title":"Image Coordinates","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"When generating PSF images:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Images are returned as Julia matrices with indices [row, column]\nThis corresponds to [y, x] in the coordinate system\nThe first element [1, 1] is the top-left pixel","category":"page"},{"location":"conventions/#Normalization","page":"Conventions","title":"Normalization","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"PSF models use the following normalization conventions:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Intensity: PSF intensity is normalized to integrate to 1.0 over the entire domain\nAmplitude: Complex amplitudes are normalized such that |amplitude|² gives the normalized intensity\nGenerated images: PSF images are normalized to sum to 1.0 by default, unless specified otherwise","category":"page"},{"location":"conventions/#Parameters","page":"Conventions","title":"Parameters","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Common parameters across PSF models:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in micrometers (μm)\nn: Refractive index of the sample medium\nn_i: Refractive index of the immersion medium","category":"page"},{"location":"conventions/#Aberrations","page":"Conventions","title":"Aberrations","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Aberrations are represented using Zernike polynomials:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Zernike coefficients use the Noll indexing scheme by default\nCoefficients are specified in wavelength units\nPositive z (defocus) corresponds to increasing the optical path length\nNote that this is consistent with a sample moving away from the objective","category":"page"},{"location":"conventions/#Units","page":"Conventions","title":"Units","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Parameter Unit\nWavelength Micrometers (μm)\nPosition Micrometers (μm)\nPixel size Micrometers (μm)\nSigma Micrometers (μm)\nNA Dimensionless\nRefractive index Dimensionless\nZernike coefficients Wavelengths","category":"page"},{"location":"conventions/#Performance-Considerations","page":"Conventions","title":"Performance Considerations","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Array dimensions are typically ordered as [y, x] for 2D and [y, x, z] for 3D\nFor performance-critical code, provide pre-allocated arrays whenever possible\nPSF models are designed to be thread-safe for parallel evaluation","category":"page"},{"location":"conventions/#Type-Hierarchy","page":"Conventions","title":"Type Hierarchy","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The package uses the following type hierarchy structure:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"AbstractPSF\n├── Gaussian2D\n├── Airy2D\n├── Scalar3DPSF\n├── Vector3DPSF\n└── SplinePSF","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The Gaussian2D and Airy2D types are 2D PSF models, while Scalar3DPSF and Vector3DPSF are 3D PSF models. Each implements the appropriate methods for PSF evaluation in their respective dimensions.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"MicroscopePSFs.jl provides a consistent interface across all PSF types, making it easy to switch between different models with minimal code changes.","category":"page"},{"location":"interface/#Core-Interface","page":"Interface","title":"Core Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All PSF types implement the following core interface methods:","category":"page"},{"location":"interface/#PSF-Evaluation","page":"Interface","title":"PSF Evaluation","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Evaluate PSF at specified position (call operator)\n(psf::AbstractPSF)(x, y)      # 2D evaluation\n(psf::AbstractPSF)(x, y, z)   # 3D evaluation\n\n# Get complex amplitude\namplitude(psf::AbstractPSF, x, y)      # 2D amplitude\namplitude(psf::AbstractPSF, x, y, z)   # 3D amplitude","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The coordinate system uses physical units (microns) with the origin at the PSF center.","category":"page"},{"location":"interface/#Pixel-Integration","page":"Interface","title":"Pixel Integration","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Create camera and emitter\n# Using constructor with pixel edges directly\npixel_edges_x = collect(0:0.1:2.0)  # Convert to Vector\npixel_edges_y = collect(0:0.1:2.0)  # Convert to Vector\ncamera = IdealCamera(pixel_edges_x, pixel_edges_y)  # 20x20 pixels, 100nm size\nemitter = Emitter2D(1.0, 1.0, 1000.0)               # At (1μm, 1μm) with 1000 photons\n\n# Generate realistic microscope image\npixels = integrate_pixels(psf, camera, emitter)\n\n# For complex amplitude integration\npixels_amplitude = integrate_pixels_amplitude(psf, camera, emitter)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The integrate_pixels function is the primary way to generate physically realistic microscope images, accounting for:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"PSF shape\nCamera pixel geometry\nEmitter position and intensity","category":"page"},{"location":"interface/#Working-with-PSFs","page":"Interface","title":"Working with PSFs","text":"","category":"section"},{"location":"interface/#Creating-PSF-Instances","page":"Interface","title":"Creating PSF Instances","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Each PSF type has its own constructor with parameters specific to that model. For example:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# Create a Gaussian2D PSF with sigma=150nm\npsf_gaussian = Gaussian2D(0.15)\n\n# Create an Airy2D PSF with NA=1.4 and wavelength=532nm\npsf_airy = Airy2D(1.4, 0.532)\n\n# Create a Vector3D PSF with more parameters\n# Note: Create a dipole vector for the orientation (z-axis in this case)\ndipole_z = DipoleVector(0.0, 0.0, 1.0)  # Dipole along z-axis\npsf_vector = Vector3DPSF(\n    1.4,                # Numerical aperture\n    0.68,               # Wavelength in microns\n    dipole_z,           # Dipole orientation (along optical axis)\n    n_medium=1.33,      # Sample medium refractive index\n    n_immersion=1.518,  # Immersion medium refractive index\n    n_coverslip=1.518   # Coverslip refractive index\n)","category":"page"},{"location":"interface/#Using-the-Same-Code-with-Different-PSF-Models","page":"Interface","title":"Using the Same Code with Different PSF Models","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The common interface allows you to write generic code that works with any PSF type:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"function analyze_psf_width(psf::AbstractPSF)\n    # Generate intensity profile\n    x = range(-1, 1, length=100)\n    intensities = [psf(xi, 0.0) for xi in x]\n    \n    # Calculate FWHM or other properties\n    # ...\n    \n    return results\nend\n\n# Works with any PSF model that implements the 2D interface\n# Note: Vector3DPSF and Scalar3DPSF only support 3D evaluation with (x,y,z)\nresults_gaussian = analyze_psf_width(Gaussian2D(0.15))\nresults_airy = analyze_psf_width(Airy2D(1.4, 0.532))","category":"page"},{"location":"interface/#Example:-Visualizing-Different-PSF-Models","page":"Interface","title":"Example: Visualizing Different PSF Models","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"using MicroscopePSFs\nusing CairoMakie\n\n# Define position and image grid\nx = range(-1, 1, length=100)\ny = range(-1, 1, length=100)\n\n# Create different PSF models - using only 2D PSFs\n# Note: Vector3DPSF requires a dipole orientation\ndipole_z = DipoleVector(0.0, 0.0, 1.0)  # Dipole along z-axis (for reference)\npsfs = [\n    Gaussian2D(0.15),\n    Airy2D(1.4, 0.532)\n    # Scalar3DPSF only supports 3D interface with (x,y,z) and isn't included here\n    # Vector3DPSF only supports 3D interface and isn't included here\n]\ntitles = [\"Gaussian2D\", \"Airy2D\"]\n\n# Compute PSF intensity values\nintensity_values = [[psf(xi, yi) for yi in y, xi in x] for psf in psfs]\n\n# Create visualization\nfig = Figure(size=(1000, 800))\nfor (i, img) in enumerate(intensity_values)\n    ax = Axis(fig[div(i-1, 2)+1, mod(i-1, 2)+1], \n              aspect=DataAspect(),\n              title=titles[i],\n              xlabel=\"x (μm)\",\n              ylabel=\"y (μm)\")\n    hm = heatmap!(ax, x, y, img, colormap=:viridis)\n    Colorbar(fig[div(i-1, 2)+1, mod(i-1, 2)+3], hm)\nend\n\n# Display or save the figure\nfig","category":"page"},{"location":"interface/#Performance-Considerations","page":"Interface","title":"Performance Considerations","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The interface is designed to be both flexible and performant. For high-performance applications, consider:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Vectorizing operations when evaluating PSFs at multiple positions\nUsing SplinePSF to pre-compute complex PSFs for faster evaluation\nUsing the appropriate PSF model for your needs (simpler models are faster)","category":"page"},{"location":"psfs/vector3d/#Vector3DPSF","page":"Vector3D","title":"Vector3DPSF","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF model implements a comprehensive three-dimensional point spread function based on vectorial diffraction theory. It accounts for polarization effects, high-NA phenomena, dipole emission patterns, refractive index interfaces, and arbitrary aberrations, providing the highest level of physical accuracy among the PSF models.","category":"page"},{"location":"psfs/vector3d/#Mathematical-Model","page":"Vector3D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF implements the full Richards-Wolf vector diffraction theory, accounting for the vectorial nature of light. The key formula for the electric field at the image plane is:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"PSF(x - x_i y - y_i z_i z_s) = sum_m=xy sum_n=p_x p_y p_z Fh(k_x k_y)w_mnA(k_x k_y)e^iota 2pi(k_x x_i+k_y y_i+k_zmathrmmed z_i-k_zmathrmimmz_s)^2","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Where:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"(x_i y_i z_i) is the emitter position where z_i represents the depth above the coverslip\nz_s is the distance the sample stage was moved from nominal focus\nF denotes the Fourier transform operation \nh(k_x k_y) is the complex pupil function incorporating aberrations \nw_mn represents electric field components at the pupil plane\nA(k_x k_y) is the apodization factor for energy conservation \nk_zmathrmmed and k_zmathrmimm are z-components of wave vectors in the sample and immersion media","category":"page"},{"location":"psfs/vector3d/#Constructor-and-Parameters","page":"Vector3D","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Vector3DPSF(nₐ::Real, λ::Real, dipole::DipoleVector;\n            base_pupil::Union{Nothing, PupilFunction}=nothing,\n            base_zernike::Union{Nothing, ZernikeCoefficients}=nothing,\n            n_medium::Real=1.33,\n            n_coverslip::Real=1.52,\n            n_immersion::Real=1.52,\n            z_stage::Real=0.0, \n            grid_size::Integer=128)","category":"page"},{"location":"psfs/vector3d/#Required-Parameters","page":"Vector3D","title":"Required Parameters","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"nₐ: Numerical aperture of the objective\nλ: Wavelength of light in microns\ndipole: Dipole orientation vector specified using DipoleVector","category":"page"},{"location":"psfs/vector3d/#Optional-Parameters","page":"Vector3D","title":"Optional Parameters","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"base_pupil: Optional base aberration pupil function (default: none)\nbase_zernike: Zernike coefficients for aberrations (default: none)\nn_medium: Refractive index of the sample medium (default: 1.33, water)\nn_immersion: Refractive index of the immersion medium (default: 1.52, oil)\nn_coverslip: Refractive index of the coverslip (default: 1.52, glass)\nz_stage: Distance the sample stage was moved (μm) (default: 0.0)\ngrid_size: Size of grid for pupil function (default: 128)","category":"page"},{"location":"psfs/vector3d/#Key-Features","page":"Vector3D","title":"Key Features","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Polarization Effects: Models the vectorial nature of light propagation\nDipole Emission Patterns: Accounts for the orientation of fluorescent dipoles\nHigh-NA Accuracy: Correctly handles the optical physics at high numerical apertures\nRefractive Index Interfaces: Models light propagation across media interfaces\nSupercritical Angle Fluorescence: Captures SAF effects for emitters near coverslip","category":"page"},{"location":"psfs/vector3d/#Dipole-Orientations","page":"Vector3D","title":"Dipole Orientations","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF model allows simulating different dipole orientations:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create dipole vectors for different orientations\ndipole_x = DipoleVector(1.0, 0.0, 0.0)  # X-oriented dipole\ndipole_y = DipoleVector(0.0, 1.0, 0.0)  # Y-oriented dipole\ndipole_z = DipoleVector(0.0, 0.0, 1.0)  # Z-oriented dipole\ndipole_xy = DipoleVector(0.707, 0.707, 0.0)  # 45° in XY plane","category":"page"},{"location":"psfs/vector3d/#Refractive-Index-Interfaces","page":"Vector3D","title":"Refractive Index Interfaces","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"The Vector3DPSF accounts for refractive index mismatches:","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Water sample with oil immersion objective\npsf = Vector3DPSF(\n    1.4, 0.532, dipole_z,\n    n_medium=1.33,   # Water sample\n    n_immersion=1.52  # Oil immersion\n)","category":"page"},{"location":"psfs/vector3d/#Supercritical-Angle-Fluorescence","page":"Vector3D","title":"Supercritical Angle Fluorescence","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"A notable feature of the Vector3DPSF model is its ability to accurately capture Supercritical Angle Fluorescence (SAF), which occurs when light emitted by fluorophores near the coverslip is collected at angles exceeding the critical angle. SAF contribution decreases as the emitter moves away from the coverslip.","category":"page"},{"location":"psfs/vector3d/#Examples","page":"Vector3D","title":"Examples","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"# Create a basic Vector3DPSF with Z-oriented dipole\npsf = Vector3DPSF(\n    1.4,                # Numerical aperture\n    0.532,              # Wavelength in microns\n    dipole_z,           # Z-oriented dipole\n    n_medium=1.33,      # Sample is water\n    n_immersion=1.52   # Immersion oil\n)\n\n# Create a PSF with aberrations\nzc = ZernikeCoefficients(15)\nadd_spherical!(zc, 0.5)  # Add 0.5 waves of spherical aberration\npsf_aberrated = Vector3DPSF(\n    1.4, 0.532, dipole_z,\n    n_medium=1.33,\n    base_zernike=zc\n)","category":"page"},{"location":"psfs/vector3d/#Limitations","page":"Vector3D","title":"Limitations","text":"","category":"section"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"Computational Intensity: Most computationally demanding PSF model\nParameter Complexity: Requires understanding of multiple physical parameters\nSpeed: Significantly slower than other PSF models, especially with fine grid sizes","category":"page"},{"location":"psfs/vector3d/","page":"Vector3D","title":"Vector3D","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"psfs/overview/#PSF-Types-Overview","page":"Overview","title":"PSF Types Overview","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"MicroscopePSFs.jl provides several PSF (Point Spread Function) models with varying complexity, accuracy, and computational requirements. This page gives an overview of the available models and guidance on selecting the appropriate PSF for your application.","category":"page"},{"location":"psfs/overview/#PSF-Model-Comparison","page":"Overview","title":"PSF Model Comparison","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"PSF Type Parameters 2D/3D Aberrations Polarization Relative Speed\nGaussian2D σ 2D No No Fastest\nAiry2D NA, λ 2D No No Fast\nScalar3DPSF NA, λ, n 3D Yes No Moderate\nVector3DPSF NA, λ, dipole, n_medium, etc. 3D Yes Yes Slowest\nSplinePSF any 2D/3D Via source PSF Via source PSF Fast evaluation","category":"page"},{"location":"psfs/overview/#When-to-Use-Each-PSF-Type","page":"Overview","title":"When to Use Each PSF Type","text":"","category":"section"},{"location":"psfs/overview/#Gaussian2D","page":"Overview","title":"Gaussian2D","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Rapid prototyping and initial development\nSimple fitting algorithms where computational speed is critical\nApplications where physical accuracy is less important than performance\nEducational purposes demonstrating basic PSF concepts","category":"page"},{"location":"psfs/overview/#Airy2D","page":"Overview","title":"Airy2D","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Diffraction-limited 2D imaging simulations\nMore accurate 2D fitting that accounts for diffraction rings\nCases where you need a physically accurate model but don't need 3D capabilities\nApplications requiring a good balance between accuracy and speed","category":"page"},{"location":"psfs/overview/#Scalar3DPSF","page":"Overview","title":"Scalar3DPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"3D imaging simulations with moderate accuracy requirements\nModeling defocus, spherical aberration, and other aberrations\nApplications with moderate NA objectives (typically NA < 1.2)\nWhen you need 3D capabilities but polarization effects aren't critical","category":"page"},{"location":"psfs/overview/#Vector3DPSF","page":"Overview","title":"Vector3DPSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"High-NA objectives (NA > 1.2)\nApplications where polarization effects matter\nModeling complex dipole emission patterns\nResearch requiring the highest physical accuracy\nSimulations with significant refractive index mismatches\nWhen you need to account for all types of optical aberrations","category":"page"},{"location":"psfs/overview/#SplinePSF","page":"Overview","title":"SplinePSF","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Best for:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Accelerating computationally intensive PSF models\nUsing experimental PSF measurements from calibration beads\nPerformance-critical applications like real-time fitting\nCreating fast approximations of complex physical models","category":"page"},{"location":"psfs/overview/#Standard-Usage-Pattern","page":"Overview","title":"Standard Usage Pattern","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"All PSF types follow the same core interface, making it easy to switch between models:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"# Create a PSF (example with Airy2D)\npsf = Airy2D(1.4, 0.532)  # NA=1.4, λ=532nm\n\n# Evaluate at specific position\nintensity = psf(0.1, 0.2)  # at x=0.1μm, y=0.2μm\n\n# Get complex field amplitude\namp = amplitude(psf, 0.1, 0.2)\n\n# Create image grid\nx = y = range(-1, 1, length=101)  # μm\nimg = [psf(xi, yi) for yi in y, xi in x]\n\n# Camera integration example\npixel_size = 0.1  # μm\ncamera = IdealCamera(1:20, 1:20, pixel_size)\nemitter = Emitter2D(1.0, 1.0, 1000.0)  # x, y, photons\npixels = integrate_pixels(psf, camera, emitter)","category":"page"},{"location":"psfs/overview/#Visual-Comparison","page":"Overview","title":"Visual Comparison","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Below is a comparison of the different PSF models using the same physical parameters:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"using MicroscopePSFs\nusing CairoMakie\n\nfunction compare_psf_profiles()\n    # Common parameters\n    na = 1.4\n    wavelength = 0.532  # μm\n    n = 1.518\n    \n    # Create consistent PSF instances\n    gaussian = Gaussian2D(0.22 * wavelength / na)\n    airy = Airy2D(na, wavelength)\n    scalar = Scalar3DPSF(na, wavelength, n)\n    \n    # Dipole for vector PSF (z-oriented)\n    dipole_z = DipoleVector(1.0, 0.0, 0.0)\n    vector = Vector3DPSF(na, wavelength, dipole_z, n_medium=n)\n    \n    # Define positions for profile\n    x = range(-1, 1, length=200)  # μm\n    y = 0.0\n    z = 0.0\n    \n    # Calculate profiles\n    gaussian_profile = [gaussian(xi, y) for xi in x]\n    airy_profile = [airy(xi, y) for xi in x]\n    scalar_profile = [scalar(xi, y, z) for xi in x]\n    vector_profile = [vector(xi, y, z) for xi in x]\n    \n    # Create figure\n    fig = Figure(size=(900, 700))\n    \n    # 1D profiles\n    ax1 = Axis(fig[1, 1:2], \n              xlabel=\"Position (μm)\", \n              ylabel=\"Normalized Intensity\",\n              title=\"PSF Intensity Profiles (y=0)\")\n    \n    lines!(ax1, x, gaussian_profile, label=\"Gaussian2D\", linewidth=2, color=:blue)\n    lines!(ax1, x, airy_profile, label=\"Airy2D\", linewidth=2, color=:red)\n    lines!(ax1, x, scalar_profile, label=\"Scalar3DPSF\", linewidth=2, color=:green)\n    lines!(ax1, x, vector_profile, label=\"Vector3DPSF\", linewidth=2, color=:purple)\n    \n    axislegend(ax1, position=:rt)\n    \n    # 2D images\n    x_grid = y_grid = range(-1, 1, length=101)  # μm\n    \n    # Calculate 2D images\n    gaussian_img = [gaussian(xi, yi) for yi in y_grid, xi in x_grid]\n    airy_img = [airy(xi, yi) for yi in y_grid, xi in x_grid]\n    scalar_img = [scalar(xi, yi, 0.0) for yi in y_grid, xi in x_grid]\n    vector_img = [vector(xi, yi, 0.0) for yi in y_grid, xi in x_grid]\n    \n    # Plot 2D images\n    psf_images = [gaussian_img, airy_img, scalar_img, vector_img]\n    titles = [\"Gaussian2D\", \"Airy2D\", \"Scalar3DPSF\", \"Vector3DPSF\"]\n    \n    for (i, (img, title)) in enumerate(zip(psf_images, titles))\n        ax = Axis(fig[2, i], aspect=DataAspect(), \n                 title=title,\n                 xlabel=\"x (μm)\", \n                 ylabel=i==1 ? \"y (μm)\" : \"\")\n        \n        hm = heatmap!(ax, x_grid, y_grid, img, colormap=:viridis)\n    end\n    \n    return fig\nend\n\nfig = compare_psf_profiles()","category":"page"},{"location":"psfs/overview/#PSF-Conversion","page":"Overview","title":"PSF Conversion","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"The PSF types provide methods to convert between models where appropriate:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"# Convert Airy2D to Gaussian2D approximation\nairy = Airy2D(1.4, 0.532)\ngaussian = Gaussian2D(airy)  # Automatically uses appropriate σ\n\n# Convert Gaussian2D to equivalent Airy2D\ngaussian = Gaussian2D(0.15)\nairy = Airy2D(gaussian, λ=0.532)  # Need to specify wavelength","category":"page"},{"location":"psfs/overview/#Computational-Considerations","page":"Overview","title":"Computational Considerations","text":"","category":"section"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"When selecting a PSF model, consider the trade-off between accuracy and computational cost:","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"Gaussian2D: Closed-form expression, extremely fast\nAiry2D: Uses Bessel functions, fast but more expensive than Gaussian\nScalar3DPSF: Requires numerical integration or pre-computation, moderate speed\nVector3DPSF: Most computationally intensive, especially with aberrations\nSplinePSF: Fast evaluation but requires initial computation or measurement","category":"page"},{"location":"psfs/overview/","page":"Overview","title":"Overview","text":"For performance-critical applications, consider using SplinePSF to pre-compute a more complex PSF model for faster repeated evaluations.","category":"page"},{"location":"#MicroscopePSFs.jl","page":"Home","title":"MicroscopePSFs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for simulating microscope point spread functions (PSFs).","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MicroscopePSFs.jl provides a flexible and performant framework for calculating microscope point spread functions (PSFs) using various models, from simple 2D Gaussians to full 3D vectorial models. The package is designed for use in single-molecule localization microscopy (SMLM) and other fields requiring accurate optical simulations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple PSF models: Gaussian2D, Airy2D, Scalar3DPSF, Vector3DPSF, and Spline PSFs\nCommon interface for all PSF types with function-call syntax psf(x, y, z)\nRealistic camera pixel integration with integrate_pixels(psf, camera, emitter)\nSupport for optical aberrations via Zernike polynomials\nGPU acceleration (for supported models)\nOptimized for performance in single-molecule fitting applications\nInteroperability with the broader Julia ecosystem","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MicroscopePSFs\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using MicroscopePSFs\nusing CairoMakie\n\n# Create a Gaussian2D PSF\npsf = Gaussian2D(0.15)  # σ = 150nm\n\n# Evaluate at a specific position\nintensity = psf(0.1, 0.2)  # Intensity at (x,y) = (0.1μm, 0.2μm)\n\n# Generate a PSF image\nx = range(-1, 1, length=101)  # μm\ny = range(-1, 1, length=101)  # μm\nimg = [psf(xi, yi) for yi in y, xi in x]\n\n# Visualize the PSF\nfig = Figure(size=(600, 500))\nax = Axis(fig[1, 1], aspect=DataAspect(),\n          title=\"Gaussian PSF (σ=150nm)\",\n          xlabel=\"x (μm)\", \n          ylabel=\"y (μm)\")\nhm = heatmap!(ax, x, y, img, colormap=:viridis)\nColorbar(fig[1, 2], hm)\n\n# Create a simulated microscope image\npixel_edges_x = collect(0:0.1:2.0)  # Convert to Vector\npixel_edges_y = collect(0:0.1:2.0)  # Convert to Vector\ncamera = IdealCamera(pixel_edges_x, pixel_edges_y)  # 20x20 pixels, 100nm size\nemitter = Emitter2D(1.0, 1.0, 1000.0)               # At (1μm, 1μm) with 1000 photons\npixels = integrate_pixels(psf, camera, emitter)\n\n# Camera physical coordinates\nx_phys = (camera.pixel_edges_x[1:end-1] + camera.pixel_edges_x[2:end]) / 2\ny_phys = (camera.pixel_edges_y[1:end-1] + camera.pixel_edges_y[2:end]) / 2\n\n# Visualize the camera image\nax2 = Axis(fig[2, 1:2], aspect=DataAspect(),\n           title=\"Integrated Camera Image\",\n           xlabel=\"x (μm)\", \n           ylabel=\"y (μm)\")\nax2.yreversed = true  # Flip y axis to match camera convention\nhm2 = heatmap!(ax2, x_phys, y_phys, pixels', colormap=:viridis)\nscatter!(ax2, [emitter.x], [emitter.y], \n         color=:red, marker=:cross, markersize=15)\n\nfig","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the navigation menu for detailed documentation on interfaces, conventions, and specific PSF types.","category":"page"},{"location":"psfs/gaussian2d/#Gaussian2D","page":"Gaussian2D","title":"Gaussian2D","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D PSF model represents the microscope point spread function as an isotropic 2D Gaussian function. While this is a mathematical approximation rather than a physical model derived from diffraction theory, it provides excellent computational efficiency for rapid prototyping and performance-critical algorithms.","category":"page"},{"location":"psfs/gaussian2d/#Mathematical-Model","page":"Gaussian2D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D PSF is defined as:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"I(x y) = frac12pisigma^2 expleft(-fracx^2 + y^22sigma^2right)","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"where:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"x y are coordinates in physical units (microns)\nsigma is the standard deviation in the same units","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"This function is normalized to integrate to 1 over the entire domain, ensuring energy conservation.","category":"page"},{"location":"psfs/gaussian2d/#Constructor-and-Parameters","page":"Gaussian2D","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"Gaussian2D(σ::Real)","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"σ: Standard deviation in microns, representing the width of the PSF","category":"page"},{"location":"psfs/gaussian2d/#Alternative-Constructor","page":"Gaussian2D","title":"Alternative Constructor","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"Gaussian2D(psf::Airy2D)  # Create from an Airy PSF","category":"page"},{"location":"psfs/gaussian2d/#Key-Features","page":"Gaussian2D","title":"Key Features","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"Computational Efficiency: Fastest PSF model in the package, using a simple closed-form expression\nSimplicity: Simple mathematical form makes it ideal for prototyping\nApproximation: Provides a reasonable approximation of the central peak of diffraction-limited PSFs","category":"page"},{"location":"psfs/gaussian2d/#Examples","page":"Gaussian2D","title":"Examples","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"Creating a Gaussian PSF:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"# Create a PSF with 150nm standard deviation\npsf = Gaussian2D(0.15)\n\n# Create a Gaussian approximation of an Airy disk\nairy_psf = Airy2D(1.4, 0.532)  # NA=1.4, wavelength=532nm\ngaussian_approximation = Gaussian2D(airy_psf)  # Automatically sets appropriate σ","category":"page"},{"location":"psfs/gaussian2d/#Relationship-to-Airy-Function","page":"Gaussian2D","title":"Relationship to Airy Function","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"The Gaussian2D model can approximate the Airy disk pattern using the empirical relationship:","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"sigma approx 022 fraclambdatextNA","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"where λ is the wavelength and NA is the numerical aperture. This approximation works best near the center of the PSF.","category":"page"},{"location":"psfs/gaussian2d/#Limitations","page":"Gaussian2D","title":"Limitations","text":"","category":"section"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"No Diffraction Rings: Doesn't capture the diffraction rings present in real microscope PSFs\nNo Defocus Modeling: Can't model effects of defocus or 3D imaging\nNo Aberrations: Doesn't account for optical aberrations\nSimplified Physics: Mathematical approximation rather than physically derived model\nLess Accurate at Edges: Diverges from physical PSFs at larger distances from the center","category":"page"},{"location":"psfs/gaussian2d/","page":"Gaussian2D","title":"Gaussian2D","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"},{"location":"psfs/scalar3d/#Scalar3DPSF","page":"Scalar3D","title":"Scalar3DPSF","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The Scalar3DPSF model implements a three-dimensional point spread function based on scalar diffraction theory. This model accounts for defocus and optical aberrations using a complex pupil function approach, providing a good balance between physical accuracy and computational efficiency.","category":"page"},{"location":"psfs/scalar3d/#Mathematical-Model","page":"Scalar3D","title":"Mathematical Model","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The Scalar3DPSF uses the Fourier optics approach to calculate the complex field distribution:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"U(mathbfr) = int_pupil P(boldsymbolrho) e^i k boldsymbolrho cdot mathbfr dboldsymbolrho","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"where:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"U(mathbfr) is the complex field amplitude at position mathbfr = (x y z)\nP(boldsymbolrho) is the complex pupil function at pupil coordinates boldsymbolrho\nk = 2pi  lambda is the wave number\nThe intensity is calculated as I(mathbfr) = U(mathbfr)^2","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"The pupil function can incorporate various aberrations, typically represented using Zernike polynomials.","category":"page"},{"location":"psfs/scalar3d/#Constructor-and-Parameters","page":"Scalar3D","title":"Constructor and Parameters","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"Scalar3DPSF(na::Real, wavelength::Real, n::Real; \n            pupil::Union{Nothing, PupilFunction}=nothing,\n            pupil_data::Union{Nothing, AbstractMatrix}=nothing,\n            coeffs::Union{Nothing, ZernikeCoefficients}=nothing)","category":"page"},{"location":"psfs/scalar3d/#Required-Parameters","page":"Scalar3D","title":"Required Parameters","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"na: Numerical aperture of the objective\nwavelength: Wavelength of light in microns\nn: Refractive index of the medium","category":"page"},{"location":"psfs/scalar3d/#Optional-Parameters","page":"Scalar3D","title":"Optional Parameters","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"pupil: Pre-created PupilFunction instance\npupil_data: Complex matrix to initialize the pupil function\ncoeffs: ZernikeCoefficients instance for representing aberrations","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"You should provide exactly one of the optional parameters. If none are provided, an unaberrated pupil is created.","category":"page"},{"location":"psfs/scalar3d/#Key-Features","page":"Scalar3D","title":"Key Features","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"3D Imaging: Models PSF behavior throughout 3D space, not just in focus\nAberration Modeling: Supports arbitrary optical aberrations via Zernike polynomials\nComplex Field: Provides access to both amplitude and phase information\nPhysical Realism: Based on physical principles of scalar diffraction theory","category":"page"},{"location":"psfs/scalar3d/#Aberration-Modeling","page":"Scalar3D","title":"Aberration Modeling","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"A key feature of the Scalar3DPSF is its ability to incorporate optical aberrations:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"# Create Zernike coefficients object\nzc = ZernikeCoefficients(15)  # Up to 15th Zernike polynomial\n\n# Add common aberrations\nadd_defocus!(zc, 1.0)         # 1 wave of defocus\nadd_astigmatism!(zc, 0.5)     # 0.5 waves of astigmatism\nadd_coma!(zc, 0.3)            # 0.3 waves of coma\nadd_spherical!(zc, 0.2)       # 0.2 waves of spherical aberration\n\n# Create PSF with these aberrations\npsf = Scalar3DPSF(1.4, 0.532, 1.518, coeffs=zc)","category":"page"},{"location":"psfs/scalar3d/#Examples","page":"Scalar3D","title":"Examples","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"Creating a Scalar3DPSF:","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"# Create a basic unaberrated 3D PSF\npsf = Scalar3DPSF(1.4, 0.532, 1.518)  # NA=1.4, λ=532nm, n=1.518\n\n# Create a PSF with spherical aberration\nzc = ZernikeCoefficients(15)  # Up to 15th Zernike polynomial\nadd_spherical!(zc, 0.5)       # Add 0.5 waves of spherical aberration\npsf_aberrated = Scalar3DPSF(1.4, 0.532, 1.518, coeffs=zc)\n\n# Create a PSF with a pre-computed pupil function\npupil = PupilFunction(1.4, 0.532, 1.518, zernike_coeffs)\npsf_from_pupil = Scalar3DPSF(1.4, 0.532, 1.518, pupil=pupil)","category":"page"},{"location":"psfs/scalar3d/#Limitations","page":"Scalar3D","title":"Limitations","text":"","category":"section"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"No Polarization Effects: Doesn't account for polarization, which becomes significant at high NA (>1.2)\nSimplified Refractive Index Interfaces: Simplified treatment of refractive index interfaces\nScalar Approximation: Uses scalar diffraction theory instead of full vector theory\nModerate NA Assumption: Most accurate for moderate NA values and regions near the focal plane","category":"page"},{"location":"psfs/scalar3d/","page":"Scalar3D","title":"Scalar3D","text":"For standard usage patterns, camera integration, and comparison with other PSF types, see the PSF Overview.","category":"page"}]
}
