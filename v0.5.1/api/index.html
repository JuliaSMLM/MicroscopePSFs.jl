<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MicroscopePSFs.jl</title><meta name="title" content="API Reference · MicroscopePSFs.jl"/><meta property="og:title" content="API Reference · MicroscopePSFs.jl"/><meta property="twitter:title" content="API Reference · MicroscopePSFs.jl"/><meta name="description" content="Documentation for MicroscopePSFs.jl."/><meta property="og:description" content="Documentation for MicroscopePSFs.jl."/><meta property="twitter:description" content="Documentation for MicroscopePSFs.jl."/><meta property="og:url" content="https://JuliaSMLM.github.io/MicroscopePSFs.jl/api/"/><meta property="twitter:url" content="https://JuliaSMLM.github.io/MicroscopePSFs.jl/api/"/><link rel="canonical" href="https://JuliaSMLM.github.io/MicroscopePSFs.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MicroscopePSFs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><span class="tocitem">PSF Types</span><ul><li><a class="tocitem" href="../psfs/overview/">Overview</a></li><li><a class="tocitem" href="../psfs/gaussianpsf/">GaussianPSF</a></li><li><a class="tocitem" href="../psfs/airypsf/">AiryPSF</a></li><li><a class="tocitem" href="../psfs/scalarpsf/">ScalarPSF</a></li><li><a class="tocitem" href="../psfs/vectorpsf/">VectorPSF</a></li><li><a class="tocitem" href="../psfs/splinepsf/">SplinePSF</a></li></ul></li><li><a class="tocitem" href="../zernike/">Zernike Polynomials</a></li><li><a class="tocitem" href="../io/">I/O Functionality</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Complete-API-(All-Documented-Functions)"><span>Complete API (All Documented Functions)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page provides a comprehensive reference of the types and functions in MicroscopePSFs.jl.</p><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><p>These types and functions form the core public API of MicroscopePSFs.jl.</p><h3 id="PSF-Types"><a class="docs-heading-anchor" href="#PSF-Types">PSF Types</a><a id="PSF-Types-1"></a><a class="docs-heading-anchor-permalink" href="#PSF-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.AbstractPSF" href="#MicroscopePSFs.AbstractPSF"><code>MicroscopePSFs.AbstractPSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPSF</code></pre><p>Abstract base type for all Point Spread Functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L3-L7">source</a></section></article><h4 id="2D-PSF-Models"><a class="docs-heading-anchor" href="#2D-PSF-Models">2D PSF Models</a><a id="2D-PSF-Models-1"></a><a class="docs-heading-anchor-permalink" href="#2D-PSF-Models" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.GaussianPSF" href="#MicroscopePSFs.GaussianPSF"><code>MicroscopePSFs.GaussianPSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianPSF{T&lt;:AbstractFloat} &lt;: Abstract2DPSF{T}</code></pre><p>Isotropic 2D Gaussian PSF.</p><p><strong>Fields</strong></p><ul><li><code>σ</code>: Standard deviation in physical units (typically microns)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.AiryPSF" href="#MicroscopePSFs.AiryPSF"><code>MicroscopePSFs.AiryPSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AiryPSF{T&lt;:AbstractFloat} &lt;: Abstract2DPSF{T}</code></pre><p>2D Airy pattern PSF using paraxial, scalar model.</p><p>Field amplitude for a circular aperture is given by:     A(r) = ν/√(4π) * (2J₁(νr)/(νr)) where:     ν = 2π*nₐ/λ     J₁ is the Bessel function of first kind, order 1     r is the radial distance from optical axis</p><p><strong>Fields</strong></p><ul><li><code>nₐ</code>: Numerical aperture</li><li><code>λ</code>: Wavelength in microns</li><li><code>ν</code>: Optical parameter = 2π*nₐ/λ</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L31-L47">source</a></section></article><h4 id="3D-PSF-Models"><a class="docs-heading-anchor" href="#3D-PSF-Models">3D PSF Models</a><a id="3D-PSF-Models-1"></a><a class="docs-heading-anchor-permalink" href="#3D-PSF-Models" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.ScalarPSF" href="#MicroscopePSFs.ScalarPSF"><code>MicroscopePSFs.ScalarPSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScalarPSF{T} &lt;: Abstract3DPSF{T}</code></pre><p>Scalar 3D PSF using explicit pupil function representation.</p><p><strong>Fields</strong></p><ul><li><code>nₐ::T</code>: Numerical aperture</li><li><code>λ::T</code>: Wavelength in microns</li><li><code>n::T</code>: Refractive index</li><li><code>pupil::PupilFunction{T}</code>: Complex pupil function</li><li><code>zernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}</code>: Zernike coefficients used to create this PSF (if applicable)</li></ul><p><strong>Notes</strong></p><p>Can be initialized with either a PupilFunction or ZernikeCoefficients using the ScalarPSF factory function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L70-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.VectorPSF" href="#MicroscopePSFs.VectorPSF"><code>MicroscopePSFs.VectorPSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorPSF{T&lt;:AbstractFloat} &lt;: Abstract3DPSF{T}</code></pre><p>Vector PSF model using explicit pupil function representation. Allows direct manipulation of pupil function for custom aberrations.</p><p><strong>Fields</strong></p><ul><li><code>nₐ::T</code>: Numerical aperture</li><li><code>λ::T</code>: Wavelength in microns</li><li><code>n_medium::T</code>: Sample medium refractive index</li><li><code>n_coverslip::T</code>: Cover slip refractive index</li><li><code>n_immersion::T</code>: Immersion medium refractive index</li><li><code>dipole::DipoleVector{T}</code>: Dipole orientation</li><li><code>z_stage::T</code>: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)</li><li><code>vector_pupils::Vector{VectorPupilFunction{T}}</code>: Vector of pupil functions containing field components. For a single dipole, this contains one pupil. For a rotating dipole, it contains three pupils for x, y, and z orientations.</li><li><code>base_pupil::Union{Nothing, PupilFunction{T}}</code>: Base pupil function representing system aberrations</li><li><code>zernike_coeffs::Union{Nothing, ZernikeCoefficients{T}}</code>: Zernike coefficients used to create this PSF (if applicable)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L102-L121">source</a></section></article><h4 id="PSF-Acceleration"><a class="docs-heading-anchor" href="#PSF-Acceleration">PSF Acceleration</a><a id="PSF-Acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#PSF-Acceleration" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.SplinePSF" href="#MicroscopePSFs.SplinePSF"><code>MicroscopePSFs.SplinePSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplinePSF{T&lt;:AbstractFloat, IT&lt;:AbstractInterpolation} &lt;: AbstractPSF</code></pre><p>A point spread function (PSF) represented as a B-spline interpolation.</p><p><strong>Fields</strong></p><ul><li><code>spline</code>: The B-spline interpolation object </li><li><code>x_range</code>: Range of x-coordinates used for uniform grid interpolation</li><li><code>y_range</code>: Range of y-coordinates used for uniform grid interpolation  </li><li><code>z_range</code>: Range of z-coordinates for 3D PSFs, or <code>nothing</code> for 2D PSFs</li><li><code>original_grid</code>: Original grid data used to create the interpolation</li><li><code>interp_order</code>: Interpolation order used (0=constant, 1=linear, 3=cubic)</li></ul><p><strong>Notes</strong></p><ul><li>Coordinates and ranges are in physical units (typically microns)</li><li>PSF values are preserved from the original PSF that was sampled</li><li>Full implementation is in spline_psf.jl</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L135-L152">source</a></section></article><h3 id="Core-Interface-Functions"><a class="docs-heading-anchor" href="#Core-Interface-Functions">Core Interface Functions</a><a id="Core-Interface-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Interface-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.amplitude" href="#MicroscopePSFs.amplitude"><code>MicroscopePSFs.amplitude</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amplitude(p::PupilFunction, x::Real, y::Real, z::Real)</code></pre><p>Calculate complex amplitude from pupil function integration.</p><p><strong>Arguments</strong></p><ul><li><code>p::PupilFunction</code>: Pupil function</li><li><code>x::Real</code>: X position in μm</li><li><code>y::Real</code>: Y position in μm</li><li><code>z::Real</code>: Z position in μm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L208-L217">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(psf::AbstractPSF, x::Real, y::Real)</code></pre><p>Evaluate complex field amplitude at position (x,y) relative to PSF center.</p><p><strong>Arguments</strong></p><ul><li><code>x, y</code>: Position in microns relative to PSF center</li></ul><p><strong>Returns</strong></p><ul><li>Complex amplitude normalized such that |amplitude|² gives normalized intensity</li></ul><p><strong>Coordinates</strong></p><p>Input coordinates (x,y) are in physical units (microns) relative to PSF center.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">psf = AiryPSF(1.4, 0.532)
amp = amplitude(psf, 0.1, 0.2)
intensity = abs2(amp)  # Convert to intensity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/interfaces.jl#L36-L56">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(psf::AbstractPSF, x::Real, y::Real, z::Real)</code></pre><p>Evaluate complex field amplitude in 3D. z is axial distance from focus in microns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/interfaces.jl#L61-L65">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(psf::ScalarPSF{T}, x::Real, y::Real, z::Real) where {T}</code></pre><p>Calculate complex amplitude at a 3D position using scalar diffraction theory.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: ScalarPSF instance</li><li><code>x, y, z</code>: Position in microns relative to PSF center</li></ul><p><strong>Returns</strong></p><ul><li>Complex amplitude at the specified position</li></ul><p><strong>Notes</strong></p><ul><li>Uses Fourier optics to propagate from pupil to image space</li><li>Accounts for defocus and aberrations encoded in the pupil function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/scalar3d.jl#L66-L81">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(psf::VectorPSF, x::Real, y::Real, z::Real)</code></pre><p>Compute complex vector amplitude at given position.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: Vector PSF instance</li><li><code>x, y</code>: Lateral position in microns relative to PSF center</li><li><code>z</code>: Axial position in microns representing depth above the coverslip</li></ul><p><strong>Returns</strong></p><ul><li>Vector [Ex, Ey] of complex field amplitudes</li></ul><p><strong>Notes</strong></p><ul><li>z coordinate represents the depth above the coverslip</li><li>z_stage in the PSF indicates the distance the stage was moved away from the nominal focal plane</li><li>Includes both UAF and SAF contributions automatically</li><li>Not meaningful for rotating dipoles (throws an error if PSF has multiple pupils)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/vector3d.jl#L239-L257">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(psf::SplinePSF, x::Real, y::Real, z::Real)</code></pre><p>Calculate the complex amplitude of the 3D PSF at position (x, y, z).</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: SplinePSF instance</li><li><code>x, y, z</code>: Coordinates in microns relative to PSF center</li></ul><p><strong>Returns</strong></p><ul><li>Complex amplitude = sqrt(intensity) with zero phase</li></ul><p><strong>Notes</strong></p><ul><li>Returns sqrt(intensity) as Complex to match the interface of other PSFs</li><li>The SplinePSF does not model phase information</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/spline_psf.jl#L385-L400">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(psf::SplinePSF, x::Real, y::Real)</code></pre><p>Calculate the complex amplitude of the PSF at position (x, y) with z=0.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: SplinePSF instance</li><li><code>x, y</code>: Coordinates in microns relative to PSF center</li></ul><p><strong>Returns</strong></p><ul><li>Complex amplitude = sqrt(intensity) with zero phase</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/spline_psf.jl#L406-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels" href="#MicroscopePSFs.integrate_pixels"><code>MicroscopePSFs.integrate_pixels</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels(
    psf::AbstractPSF, 
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitter::AbstractEmitter; 
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF intensity over camera pixels with optional support region optimization.</p><p>For each pixel in the specified region, numerically integrates the PSF intensity using the specified  sampling density. Physical coordinates are relative to camera with (0,0) at top-left corner. Automatically handles z-coordinate if both PSF and emitter support it.</p><p><strong>Arguments</strong></p><ul><li><code>psf::AbstractPSF</code>: Point spread function to integrate</li><li><code>pixel_edges_x::AbstractVector</code>: X-coordinate edges of pixels in microns</li><li><code>pixel_edges_y::AbstractVector</code>: Y-coordinate edges of pixels in microns</li><li><code>emitter::AbstractEmitter</code>: Emitter with position in microns relative to camera</li><li><code>support</code>: Region to calculate (default: Inf = full image)<ul><li>If Real: radius in microns around emitter</li><li>If Tuple: explicit (x<em>min, x</em>max, y<em>min, y</em>max) in microns</li></ul></li><li><code>sampling::Integer=2</code>: Number of samples per pixel in each dimension</li><li><code>threaded::Bool=true</code>: Whether to use multi-threading for integration Set to false when using with automatic differentiation frameworks</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: Integrated intensities where T matches emitter.photons type</li><li>Array is indexed as [y,x] with [1,1] at top-left pixel</li><li>Values represent actual photon counts in each pixel based on emitter&#39;s photon value</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create pixel edges for a 20x20 camera with 100nm pixels
pixel_edges_x = pixel_edges_y = 0:0.1:2.0
emitter = Emitter2D(1.0, 1.0, 1000.0)  # Emitter at (1μm, 1μm) with 1000 photons
psf = GaussianPSF(0.15)  # σ = 150nm

# Calculate over full image
pixels = integrate_pixels(psf, pixel_edges_x, pixel_edges_y, emitter)

# Calculate only within a 0.5μm radius of the emitter
pixels_roi = integrate_pixels(psf, pixel_edges_x, pixel_edges_y, emitter, support=0.5)</code></pre><p>See also: <a href="#MicroscopePSFs.integrate_pixels_amplitude"><code>integrate_pixels_amplitude</code></a>, <a href="#MicroscopePSFs.AbstractPSF"><code>AbstractPSF</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L210-L259">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels(
    psf::AbstractPSF, 
    camera::AbstractCamera, 
    emitter::AbstractEmitter;
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF intensity over camera pixels with optional support region optimization.</p><p>This version takes a camera object instead of explicit pixel edges.</p><p><strong>Arguments</strong></p><ul><li><code>psf::AbstractPSF</code>: Point spread function to integrate</li><li><code>camera::AbstractCamera</code>: Camera geometry defining pixel edges in microns</li><li><code>emitter::AbstractEmitter</code>: Emitter with position in microns relative to camera</li><li><code>support</code>: Region to calculate (default: Inf = full image)<ul><li>If Real: radius in microns around emitter</li><li>If Tuple: explicit (x<em>min, x</em>max, y<em>min, y</em>max) in microns</li></ul></li><li><code>sampling::Integer=2</code>: Number of samples per pixel in each dimension</li><li><code>threaded::Bool=true</code>: Whether to use multi-threading for integration</li></ul><p><strong>Returns</strong></p><ul><li>Array of pixel values with dimensions <a href="matrix indexed [row,col]">y, x</a></li><li>Values are normalized to sum to 1</li><li>Array indices start at [1,1] for top-left pixel</li></ul><p>See also: <a href="#MicroscopePSFs.integrate_pixels_amplitude"><code>integrate_pixels_amplitude</code></a>, <a href="#MicroscopePSFs.AbstractPSF"><code>AbstractPSF</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L307-L337">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels(
    psf::AbstractPSF,
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitters::Vector{&lt;:AbstractEmitter};
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF intensity over camera pixels for multiple emitters with optional support region optimization.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: Point spread function to integrate</li><li><code>pixel_edges_x</code>, <code>pixel_edges_y</code>: Arrays defining pixel edge coordinates</li><li><code>emitters</code>: Vector of emitters with position information</li><li><code>support</code>: Region to calculate for each emitter (default: Inf = full image)<ul><li>If Real: radius in microns around each emitter</li><li>If Tuple: explicit (x<em>min, x</em>max, y<em>min, y</em>max) in microns (fixed region for all emitters)</li></ul></li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true) Set to false when using with automatic differentiation frameworks</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated PSF intensities with dimensions matching the camera</li><li>Values represent actual photon counts from all emitters</li></ul><p><strong>Notes</strong></p><ul><li>Results are the sum of individual emitter contributions (incoherent addition)</li><li>For coherent addition, use <code>integrate_pixels_amplitude</code> and sum complex amplitudes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_multi.jl#L3-L34">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels(
    psf::AbstractPSF,
    camera::AbstractCamera,
    emitters::Vector{&lt;:AbstractEmitter};
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF intensity over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: Point spread function to integrate</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitters</code>: Vector of emitters with position information</li><li><code>support</code>: Region to calculate for each emitter (default: Inf = full image)</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated PSF intensities with dimensions matching the camera</li><li>Values represent actual photon counts from all emitters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_multi.jl#L75-L99">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels(
    psf::SplinePSF,
    camera::AbstractCamera,
    emitter::AbstractEmitter;
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF over camera pixels using interpolation.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: SplinePSF instance</li><li><code>camera</code>: Camera geometry</li><li><code>emitter</code>: Emitter with position information</li><li><code>support</code>: Region to calculate (default: Inf = full image)<ul><li>If Real: radius in microns around emitter</li><li>If Tuple: explicit (x<em>min, x</em>max, y<em>min, y</em>max) in microns</li></ul></li><li><code>sampling</code>: Subpixel sampling density for integration accuracy</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated PSF intensities with dimensions [ny, nx]</li><li>Values represent actual photon counts based on emitter&#39;s photon value</li></ul><p><strong>Notes</strong></p><ul><li>For 3D SplinePSFs (when z_range is defined), requires an emitter with a z-coordinate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/spline_psf.jl#L425-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels_amplitude" href="#MicroscopePSFs.integrate_pixels_amplitude"><code>MicroscopePSFs.integrate_pixels_amplitude</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::AbstractPSF, 
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitter::AbstractEmitter; 
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF complex amplitude over camera pixels with optional support region optimization.</p><p>For each pixel in the specified region, numerically integrates the PSF amplitude using the specified sampling density. Unlike intensity integration, returns unnormalized complex amplitudes which can be used for coherent calculations. Automatically handles z-coordinate if both PSF and emitter support it.</p><p><strong>Arguments</strong></p><ul><li><code>psf::AbstractPSF</code>: Point spread function to integrate</li><li><code>pixel_edges_x::AbstractVector</code>: X-coordinate edges of pixels in microns</li><li><code>pixel_edges_y::AbstractVector</code>: Y-coordinate edges of pixels in microns</li><li><code>emitter::AbstractEmitter</code>: Emitter with position in microns relative to camera</li><li><code>support</code>: Region to calculate (default: Inf = full image)<ul><li>If Real: radius in microns around emitter</li><li>If Tuple: explicit (x<em>min, x</em>max, y<em>min, y</em>max) in microns</li></ul></li><li><code>sampling::Integer=2</code>: Number of samples per pixel in each dimension</li><li><code>threaded::Bool=true</code>: Whether to use multi-threading for integration</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Complex{T}}</code>: Integrated complex amplitudes where T matches emitter.photons type</li><li>Array is indexed as [y,x] with [1,1] at top-left pixel</li><li>Values are not normalized to preserve complex amplitude relationships</li></ul><p><strong>Notes</strong></p><ul><li>For coherent calculations, use this function instead of <code>integrate_pixels</code></li><li>Return type is complex to support PSFs with phase information</li><li>To get intensity from amplitude: <code>abs2.(integrate_pixels_amplitude(...))</code></li></ul><p>See also: <a href="#MicroscopePSFs.integrate_pixels"><code>integrate_pixels</code></a>, <a href="#MicroscopePSFs.AbstractPSF"><code>AbstractPSF</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L358-L398">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::AbstractPSF, 
    camera::AbstractCamera, 
    emitter::AbstractEmitter;
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF complex amplitude over camera pixels with optional support region optimization.</p><p>This version takes a camera object instead of explicit pixel edges.</p><p><strong>Arguments</strong></p><ul><li><code>psf::AbstractPSF</code>: Point spread function to integrate</li><li><code>camera::AbstractCamera</code>: Camera geometry defining pixel edges in microns</li><li><code>emitter::AbstractEmitter</code>: Emitter with position in microns relative to camera</li><li><code>support</code>: Region to calculate (default: Inf = full image)<ul><li>If Real: radius in microns around emitter</li><li>If Tuple: explicit (x<em>min, x</em>max, y<em>min, y</em>max) in microns</li></ul></li><li><code>sampling::Integer=2</code>: Number of samples per pixel in each dimension</li><li><code>threaded::Bool=true</code>: Whether to use multi-threading for integration</li></ul><p><strong>Returns</strong></p><ul><li>Matrix of complex amplitudes</li><li>Array indices start at [1,1] for top-left pixel</li></ul><p>See also: <a href="#MicroscopePSFs.integrate_pixels"><code>integrate_pixels</code></a>, <a href="#MicroscopePSFs.AbstractPSF"><code>AbstractPSF</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L446-L475">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::AbstractPSF,
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitters::Vector{&lt;:AbstractEmitter};
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: Point spread function to integrate</li><li><code>pixel_edges_x</code>, <code>pixel_edges_y</code>: Arrays defining pixel edge coordinates</li><li><code>emitters</code>: Vector of emitters with position information</li><li><code>support</code>: Region to calculate for each emitter (default: Inf = full image)</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated complex amplitudes</li><li>Values represent coherently summed field contributions</li></ul><p><strong>Notes</strong></p><ul><li>Results are the coherent sum of individual emitter field contributions</li><li>For incoherent addition, use <code>abs2.(integrate_pixels_amplitude(...))</code> or use <code>integrate_pixels</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_multi.jl#L120-L148">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::AbstractPSF,
    camera::AbstractCamera,
    emitters::Vector{&lt;:AbstractEmitter};
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: Point spread function to integrate</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitters</code>: Vector of emitters with position information</li><li><code>support</code>: Region to calculate for each emitter (default: Inf = full image)</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated complex amplitudes</li><li>Values represent coherently summed field contributions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_multi.jl#L189-L213">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::VectorPSF,
    camera::AbstractCamera,
    emitter::AbstractEmitter;
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Specialized version of amplitude integration for VectorPSF that preserves polarization components.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: VectorPSF instance</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitter</code>: Emitter with position information</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>3D array of integrated complex amplitudes with dimensions [y, x, pol] where pol index 1 = Ex and pol index 2 = Ey</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/vector3d.jl#L426-L447">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::VectorPSF,
    camera::AbstractCamera,
    emitters::Vector{&lt;:AbstractEmitter};
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF complex amplitude over camera pixels for multiple emitters. Special version for VectorPSF that preserves polarization components.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: VectorPSF instance</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitters</code>: Vector of emitters with position information</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>3D array of integrated complex amplitudes with dimensions [y, x, pol] where pol index 1 = Ex and pol index 2 = Ey</li></ul><p><strong>Notes</strong></p><ul><li>Results are the coherent sum of individual emitter field contributions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/vector3d.jl#L475-L500">source</a></section><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::SplinePSF,
    camera::AbstractCamera,
    emitter::AbstractEmitter;
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF amplitude (complex) over camera pixels.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: SplinePSF instance</li><li><code>camera</code>: Camera geometry</li><li><code>emitter</code>: Emitter with position information</li><li><code>support</code>: Region to calculate (default: Inf = full image)<ul><li>If Real: radius in microns around emitter</li><li>If Tuple: explicit (x<em>min, x</em>max, y<em>min, y</em>max) in microns</li></ul></li><li><code>sampling</code>: Subpixel sampling density for integration accuracy</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated PSF complex amplitudes with dimensions [ny, nx]</li></ul><p><strong>Notes</strong></p><ul><li>For 3D SplinePSFs (when z_range is defined), requires an emitter with a z-coordinate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/spline_psf.jl#L478-L505">source</a></section></article><h3 id="Multi-Emitter-Integration"><a class="docs-heading-anchor" href="#Multi-Emitter-Integration">Multi-Emitter Integration</a><a id="Multi-Emitter-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Emitter-Integration" title="Permalink"></a></h3><p>The following functions support integrating PSFs for multiple emitters:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels-Tuple{AbstractPSF, AbstractCamera, Vector{&lt;:AbstractEmitter}}" href="#MicroscopePSFs.integrate_pixels-Tuple{AbstractPSF, AbstractCamera, Vector{&lt;:AbstractEmitter}}"><code>MicroscopePSFs.integrate_pixels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels(
    psf::AbstractPSF,
    camera::AbstractCamera,
    emitters::Vector{&lt;:AbstractEmitter};
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF intensity over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: Point spread function to integrate</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitters</code>: Vector of emitters with position information</li><li><code>support</code>: Region to calculate for each emitter (default: Inf = full image)</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated PSF intensities with dimensions matching the camera</li><li>Values represent actual photon counts from all emitters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_multi.jl#L75-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels_amplitude-Tuple{AbstractPSF, AbstractCamera, Vector{&lt;:AbstractEmitter}}" href="#MicroscopePSFs.integrate_pixels_amplitude-Tuple{AbstractPSF, AbstractCamera, Vector{&lt;:AbstractEmitter}}"><code>MicroscopePSFs.integrate_pixels_amplitude</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude(
    psf::AbstractPSF,
    camera::AbstractCamera,
    emitters::Vector{&lt;:AbstractEmitter};
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}} = Inf,
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Integrate PSF complex amplitude over camera pixels for multiple emitters with optional support region optimization. This version takes a camera object instead of explicit pixel edges.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: Point spread function to integrate</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitters</code>: Vector of emitters with position information</li><li><code>support</code>: Region to calculate for each emitter (default: Inf = full image)</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array of integrated complex amplitudes</li><li>Values represent coherently summed field contributions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_multi.jl#L189-L213">source</a></section></article><h3 id="Pupil-Functions"><a class="docs-heading-anchor" href="#Pupil-Functions">Pupil Functions</a><a id="Pupil-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Pupil-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.PupilFunction" href="#MicroscopePSFs.PupilFunction"><code>MicroscopePSFs.PupilFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PupilFunction{T}</code></pre><p>Represents a pupil function with physical parameters.</p><p><strong>Fields</strong></p><ul><li><code>nₐ</code>: Numerical aperture</li><li><code>λ</code>: Wavelength in μm</li><li><code>n</code>: Refractive index</li><li><code>field</code>: Complex-valued pupil function array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.VectorPupilFunction" href="#MicroscopePSFs.VectorPupilFunction"><code>MicroscopePSFs.VectorPupilFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorPupilFunction{T}</code></pre><p>Vector pupil function storing Ex,Ey field components as PupilFunctions.</p><p><strong>Fields</strong></p><ul><li><code>nₐ::T</code>: Numerical aperture</li><li><code>λ::T</code>: Wavelength in μm</li><li><code>n_medium::T</code>: Refractive index of the sample medium</li><li><code>n_coverslip::T</code>: Refractive index of the coverslip</li><li><code>n_immersion::T</code>: Refractive index of the immersion medium</li><li><code>Ex::PupilFunction{T}</code>: x-component of electric field</li><li><code>Ey::PupilFunction{T}</code>: y-component of electric field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_pupil.jl#L3-L16">source</a></section></article><h3 id="Zernike-Module"><a class="docs-heading-anchor" href="#Zernike-Module">Zernike Module</a><a id="Zernike-Module-1"></a><a class="docs-heading-anchor-permalink" href="#Zernike-Module" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.ZernikeCoefficients" href="#MicroscopePSFs.Zernike.ZernikeCoefficients"><code>MicroscopePSFs.Zernike.ZernikeCoefficients</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZernikeCoefficients{T&lt;:Real}</code></pre><p>Mutable structure to hold Zernike coefficients for both magnitude and phase of a pupil function. Uses Noll indexing convention starting at index 1.</p><p><strong>Fields</strong></p><ul><li><code>mag::Vector{T}</code>: Coefficients for magnitude (1-indexed per Noll convention)</li><li><code>phase::Vector{T}</code>: Coefficients for phase (1-indexed per Noll convention)</li></ul><p><strong>Notes</strong></p><ul><li>First coefficient (index 1) typically represents piston</li><li>Magnitude coefficients are typically normalized with mag[1] = 1</li><li>Phase coefficients represent phase in radians</li><li>RMS normalization (Noll convention) is used so coefficients directly represent RMS wavefront error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/types.jl#L3-L18">source</a></section></article><h3 id="Zernike-Polynomial-Functions"><a class="docs-heading-anchor" href="#Zernike-Polynomial-Functions">Zernike Polynomial Functions</a><a id="Zernike-Polynomial-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Zernike-Polynomial-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.zernikepolynomial" href="#MicroscopePSFs.Zernike.zernikepolynomial"><code>MicroscopePSFs.Zernike.zernikepolynomial</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zernikepolynomial(n::Integer, l::Integer, ρ::Real, ϕ::Real) -&gt; Real</code></pre><p>Compute the complete Zernike polynomial Z_n^l(ρ,ϕ) with Noll normalization (RMS=1).</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Radial order</li><li><code>l</code>: Azimuthal frequency (signed)</li><li><code>ρ</code>: Radial coordinate (0 ≤ ρ ≤ 1)</li><li><code>ϕ</code>: Azimuthal angle in radians</li></ul><p><strong>Notes</strong></p><ul><li>Uses Noll normalization where RMS=1 over unit circle</li><li>Combines radial polynomial with appropriate trigonometric function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/polynomials.jl#L44-L58">source</a></section><section><div><pre><code class="language-julia hljs">zernikepolynomial(j::Integer, ρ::Real, ϕ::Real) -&gt; Real</code></pre><p>Compute Zernike polynomial using Noll index.</p><p><strong>Arguments</strong></p><ul><li><code>j</code>: Polynomial index using Noll convention</li><li><code>ρ</code>: Radial coordinate</li><li><code>ϕ</code>: Azimuthal angle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/polynomials.jl#L79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.radialpolynomial" href="#MicroscopePSFs.Zernike.radialpolynomial"><code>MicroscopePSFs.Zernike.radialpolynomial</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radialpolynomial(n::Integer, m::Integer, ρ::Real) -&gt; Real</code></pre><p>Compute the unnormalized radial component R_n^m(ρ) of the Zernike polynomial.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Radial order</li><li><code>m</code>: Azimuthal order (absolute value of azimuthal frequency)</li><li><code>ρ</code>: Radial coordinate (0 ≤ ρ ≤ 1)</li></ul><p><strong>Notes</strong></p><ul><li>Returns 0 for ρ &gt; 1</li><li>No normalization applied - returns the standard mathematical form</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/polynomials.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.max_radial_order" href="#MicroscopePSFs.Zernike.max_radial_order"><code>MicroscopePSFs.Zernike.max_radial_order</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_radial_order(num_coeffs::Integer)</code></pre><p>Calculate maximum radial order N given number of coefficients L using Noll indexing. Returns the maximum radial order where at least one Zernike term can be represented (even if not all terms of that order can fit in the coefficient vector).</p><p><strong>Arguments</strong></p><ul><li><code>num_coeffs</code>: Maximum Noll index available</li></ul><p><strong>Returns</strong></p><ul><li>Maximum radial order n where at least the first term of that order has index ≤ num_coeffs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/polynomials.jl#L141-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.evaluate_pupil" href="#MicroscopePSFs.Zernike.evaluate_pupil"><code>MicroscopePSFs.Zernike.evaluate_pupil</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_pupil(coeffs::ZernikeCoefficients, grid_size::Integer) -&gt; Matrix{Complex{Float64}}</code></pre><p>Generate complex pupil function from Zernike coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>coeffs</code>: ZernikeCoefficients containing magnitude and phase coefficients</li><li><code>grid_size</code>: Size of the output grid (grid<em>size × grid</em>size)</li></ul><p><strong>Returns</strong></p><ul><li>Complex-valued matrix representing the pupil function</li></ul><p><strong>Notes</strong></p><ul><li>Output grid is normalized to unit circle</li><li>Points outside unit circle are set to zero</li><li>Phase is applied as exp(iϕ)</li><li>Uses Noll indexing throughout</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/polynomials.jl#L94-L111">source</a></section></article><h3 id="Zernike-Analysis-Functions"><a class="docs-heading-anchor" href="#Zernike-Analysis-Functions">Zernike Analysis Functions</a><a id="Zernike-Analysis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Zernike-Analysis-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.rms" href="#MicroscopePSFs.Zernike.rms"><code>MicroscopePSFs.Zernike.rms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rms(coeffs::ZernikeCoefficients) -&gt; Tuple{Float64,Float64}</code></pre><p>Calculate RMS values for magnitude and phase coefficients (excluding piston).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/utils.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.significant_terms" href="#MicroscopePSFs.Zernike.significant_terms"><code>MicroscopePSFs.Zernike.significant_terms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">significant_terms(coeffs::ZernikeCoefficients, 
                 threshold::Real=0.01) -&gt; Vector{Tuple{Int,Float64,Float64}}</code></pre><p>Return list of significant terms: (index, magnitude, phase) above threshold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/utils.jl#L25-L30">source</a></section></article><h3 id="Index-Conversion"><a class="docs-heading-anchor" href="#Index-Conversion">Index Conversion</a><a id="Index-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Index-Conversion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.nl2osa" href="#MicroscopePSFs.Zernike.nl2osa"><code>MicroscopePSFs.Zernike.nl2osa</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nl2osa(n::Integer, l::Integer) -&gt; Int</code></pre><p>Convert from (n,l) indices to OSA/ANSI single index.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Radial order (≥ 0)</li><li><code>l</code>: Azimuthal frequency, must satisfy:<ul><li>|l| ≤ n</li><li>n - |l| must be even</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>OSA/ANSI single index j = (n(n+2) + l)/2</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; nl2osa(4, 2)
15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/indexing.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.osa2nl" href="#MicroscopePSFs.Zernike.osa2nl"><code>MicroscopePSFs.Zernike.osa2nl</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">osa2nl(j::Integer) -&gt; Tuple{Int,Int}</code></pre><p>Convert from OSA/ANSI single index to (n,l) indices.</p><p><strong>Arguments</strong></p><ul><li><code>j</code>: OSA/ANSI index (≥ 0)</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of (n,l) indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/indexing.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.nl2noll" href="#MicroscopePSFs.Zernike.nl2noll"><code>MicroscopePSFs.Zernike.nl2noll</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nl2noll(n::Integer, l::Integer) -&gt; Int</code></pre><p>Convert from (n,l) indices to Noll single index.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Radial order (≥ 0)</li><li><code>l</code>: Azimuthal frequency, must satisfy:<ul><li>|l| ≤ n</li><li>n - |l| must be even</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>Noll single index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/indexing.jl#L42-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.noll2nl" href="#MicroscopePSFs.Zernike.noll2nl"><code>MicroscopePSFs.Zernike.noll2nl</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">noll2nl(j::Integer) -&gt; Tuple{Int,Int}</code></pre><p>Convert from Noll single index to (n,l) indices.</p><p><strong>Arguments</strong></p><ul><li><code>j</code>: Noll index (&gt; 0)</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of (n,l) indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/indexing.jl#L96-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.osa2noll" href="#MicroscopePSFs.Zernike.osa2noll"><code>MicroscopePSFs.Zernike.osa2noll</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">osa2noll(j::Integer) -&gt; Int</code></pre><p>Convert from OSA/ANSI to Noll index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/indexing.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.noll2osa" href="#MicroscopePSFs.Zernike.noll2osa"><code>MicroscopePSFs.Zernike.noll2osa</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">noll2osa(j::Integer) -&gt; Int</code></pre><p>Convert from Noll to OSA/ANSI index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/indexing.jl#L122-L126">source</a></section></article><h3 id="Emitters"><a class="docs-heading-anchor" href="#Emitters">Emitters</a><a id="Emitters-1"></a><a class="docs-heading-anchor-permalink" href="#Emitters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.DipoleVector" href="#MicroscopePSFs.DipoleVector"><code>MicroscopePSFs.DipoleVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DipoleVector{T} &lt;: Real</code></pre><p>A 3D vector representing the dipole orientation.</p><p><strong>Fields</strong></p><ul><li><code>px::T</code>: x component of the dipole vector</li><li><code>py::T</code>: y component of the dipole vector</li><li><code>pz::T</code>: z component of the dipole vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/emitters.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.DipoleEmitter3D" href="#MicroscopePSFs.DipoleEmitter3D"><code>MicroscopePSFs.DipoleEmitter3D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DipoleEmitter3D{T} &lt;: AbstractEmitter</code></pre><p>3D dipole emitter with position, orientation and optical properties.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: x-coordinate in microns</li><li><code>y::T</code>: y-coordinate in microns </li><li><code>z::T</code>: z-coordinate in microns</li><li><code>photons::T</code>: number of photons</li><li><code>dipole::DipoleVector{T}</code>: dipole orientation vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/emitters.jl#L33-L44">source</a></section></article><h3 id="I/O-Functions"><a class="docs-heading-anchor" href="#I/O-Functions">I/O Functions</a><a id="I/O-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#I/O-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.save_psf" href="#MicroscopePSFs.save_psf"><code>MicroscopePSFs.save_psf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_psf(filename::String, object; metadata::Dict=Dict())</code></pre><p>Save a PSF or related object (e.g., ZernikeCoefficients, PupilFunction) to an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: Path where the PSF will be saved</li><li><code>object</code>: Object to save (PSF, ZernikeCoefficients, PupilFunction, etc.)</li><li><code>metadata</code>: Optional dictionary of additional metadata to include</li></ul><p><strong>Returns</strong></p><ul><li><code>filename</code> for chaining</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/io.jl#L19-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.load_psf" href="#MicroscopePSFs.load_psf"><code>MicroscopePSFs.load_psf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_psf(filename::String)</code></pre><p>Load a PSF or related object (e.g., ZernikeCoefficients, PupilFunction) from an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: Path to the HDF5 file containing a saved PSF object</li></ul><p><strong>Returns</strong></p><ul><li>The loaded object with its original type (PSF, ZernikeCoefficients, PupilFunction, etc.)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Load a previously saved PSF
psf = load_psf(&quot;my_airy_psf.h5&quot;)

# Use the loaded PSF normally
intensity = psf(0.1, 0.2)

# Load Zernike coefficients and use them
zc = load_psf(&quot;zernike_coeffs.h5&quot;)
psf = ScalarPSF(1.4, 0.532, 1.518; zernike_coeffs=zc)</code></pre><p>See also: <a href="../io/#save_psf"><code>save_psf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/io.jl#L56-L81">source</a></section></article><h2 id="Complete-API-(All-Documented-Functions)"><a class="docs-heading-anchor" href="#Complete-API-(All-Documented-Functions)">Complete API (All Documented Functions)</a><a id="Complete-API-(All-Documented-Functions)-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-API-(All-Documented-Functions)" title="Permalink"></a></h2><p>This section lists additional internal functions and types that are documented but not part of the public API.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Abstract2DPSF" href="#MicroscopePSFs.Abstract2DPSF"><code>MicroscopePSFs.Abstract2DPSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Abstract2DPSF{T&lt;:AbstractFloat}</code></pre><p>Abstract type for all 2D point spread functions. Parameterized by numeric type T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Abstract3DPSF" href="#MicroscopePSFs.Abstract3DPSF"><code>MicroscopePSFs.Abstract3DPSF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Abstract3DPSF{T&lt;:AbstractFloat}</code></pre><p>Abstract type for all 3D point spread functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/types.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._calculate_field_amplitude-Tuple{VectorPupilFunction, Vararg{Real, 9}}" href="#MicroscopePSFs._calculate_field_amplitude-Tuple{VectorPupilFunction, Vararg{Real, 9}}"><code>MicroscopePSFs._calculate_field_amplitude</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_calculate_field_amplitude(
    pupil::VectorPupilFunction,
    nₐ::Real, λ::Real, n_medium::Real, n_coverslip::Real, n_immersion::Real, z_stage::Real,
    x::Real, y::Real, z::Real)</code></pre><p>Internal helper function to compute complex vector amplitude at given position.</p><p><strong>Arguments</strong></p><ul><li><code>pupil</code>: Vector pupil function containing Ex and Ey fields</li><li><code>nₐ</code>, <code>λ</code>, <code>n_medium</code>, <code>n_coverslip</code>, <code>n_immersion</code>: Optical parameters </li><li><code>z_stage</code>: Distance the sample stage was moved away from the nominal focal plane</li><li><code>x, y, z</code>: Position in microns</li></ul><p><strong>Returns</strong></p><ul><li>Vector [Ex, Ey] of complex field amplitudes</li></ul><p><strong>Notes</strong></p><ul><li>This is a helper function used by both amplitude() and the PSF evaluation function</li><li>Implements the core field calculation for a single pupil</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/vector3d.jl#L172-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._check_normalization-Tuple{Any}" href="#MicroscopePSFs._check_normalization-Tuple{Any}"><code>MicroscopePSFs._check_normalization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_check_normalization(values; tol=1e-6)</code></pre><p>Internal function to verify array sums to 1 within tolerance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/utils.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._integrate_pixels_core!-Tuple{AbstractArray, AbstractVector, AbstractVector, Function, Real, Real}" href="#MicroscopePSFs._integrate_pixels_core!-Tuple{AbstractArray, AbstractVector, AbstractVector, Function, Real, Real}"><code>MicroscopePSFs._integrate_pixels_core!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_integrate_pixels_core!(
    result::AbstractArray,
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    func::Function,
    emitter_x::Real,
    emitter_y::Real;
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Internal function implementing the core pixel integration logic. Supports both scalar and vector/tensor return types from the function.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Pre-allocated array where integration results will be stored</li><li><code>pixel_edges_x</code>, <code>pixel_edges_y</code>: Arrays defining pixel edge coordinates</li><li><code>func</code>: Function to evaluate at PSF coordinates - can return scalar, vector, or tensor</li><li><code>emitter_x</code>, <code>emitter_y</code>: Emitter coordinates in same units as pixel edges</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true) Set to false when using with automatic differentiation frameworks</li></ul><p><strong>Returns</strong></p><ul><li><code>result</code> array filled with integration values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_core.jl#L101-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._integrate_pixels_generic!-Tuple{AbstractArray, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function}" href="#MicroscopePSFs._integrate_pixels_generic!-Tuple{AbstractArray, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function}"><code>MicroscopePSFs._integrate_pixels_generic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_integrate_pixels_generic!(
    result::AbstractArray,
    psf::AbstractPSF,
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitter::AbstractEmitter,
    f::Function;
    sampling::Integer=2,
    threaded::Bool=true
)</code></pre><p>Generic wrapper for PSF integration that handles coordinate systems and validation. Automatically handles z-coordinates when both PSF and emitter support them. Supports functions that return either scalars or vectors/tensors.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Pre-allocated array where results will be stored</li><li><code>psf</code>: Point spread function to integrate</li><li><code>pixel_edges_x</code>, <code>pixel_edges_y</code>: Arrays defining pixel edge coordinates</li><li><code>emitter</code>: Emitter with position information</li><li><code>f</code>: Function to evaluate (e.g., (p,x,y) -&gt; p(x,y) for intensity)</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>result</code> array filled with integration values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_core.jl#L234-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._integrate_pixels_generic-Union{Tuple{T}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}, Any}} where T" href="#MicroscopePSFs._integrate_pixels_generic-Union{Tuple{T}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}}, Tuple{AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter, Function, Type{T}, Any}} where T"><code>MicroscopePSFs._integrate_pixels_generic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_integrate_pixels_generic(
    psf::AbstractPSF,
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitter::AbstractEmitter,
    f::Function,
    ::Type{T},
    output_dims=();
    sampling::Integer=2,
    threaded::Bool=true
) where T</code></pre><p>Internal generic integration routine used by both intensity and amplitude integration. Creates a new result array and delegates to the in-place version. Supports both scalar and vector/tensor return types.</p><p><strong>Arguments</strong></p><ul><li><code>output_dims</code>: Additional dimensions for the result array beyond the basic [y,x] dimensions. For vector returns (e.g., [Ex, Ey]), set output_dims=(2,) for a [y,x,2] result array.</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Array with dimensions [y,x] or [y,x,output_dims...] depending on the function&#39;s return type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_core.jl#L294-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_check_required_fields-Tuple{Any, Any}" href="#MicroscopePSFs._io_check_required_fields-Tuple{Any, Any}"><code>MicroscopePSFs._io_check_required_fields</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_check_required_fields(group, fields)</code></pre><p>Check if all required fields exist in an HDF5 group. Throws an error if any required field is missing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_load_complex_array-Tuple{Any, Any}" href="#MicroscopePSFs._io_load_complex_array-Tuple{Any, Any}"><code>MicroscopePSFs._io_load_complex_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_load_complex_array(group, name)</code></pre><p>Load a complex array from an HDF5 group by combining real and imaginary parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_load_range-Tuple{Any, Any}" href="#MicroscopePSFs._io_load_range-Tuple{Any, Any}"><code>MicroscopePSFs._io_load_range</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_load_range(group, name)</code></pre><p>Load a range from an HDF5 group by reconstructing from start, step, and length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_load_zernike_coeffs-Tuple{Any}" href="#MicroscopePSFs._io_load_zernike_coeffs-Tuple{Any}"><code>MicroscopePSFs._io_load_zernike_coeffs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_load_zernike_coeffs(file; group_name=&quot;zernike_coefficients&quot;)</code></pre><p>Load ZernikeCoefficients from an HDF5 file from a specified group. Returns nothing if the group doesn&#39;t exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_save_complex_array-Tuple{Any, Any, Any}" href="#MicroscopePSFs._io_save_complex_array-Tuple{Any, Any, Any}"><code>MicroscopePSFs._io_save_complex_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_save_complex_array(group, name, array)</code></pre><p>Save a complex array to an HDF5 group by splitting into real and imaginary parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_save_pupil_params-Tuple{Any, Any}" href="#MicroscopePSFs._io_save_pupil_params-Tuple{Any, Any}"><code>MicroscopePSFs._io_save_pupil_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_save_pupil_params(params, pupil)</code></pre><p>Save common pupil parameters to an HDF5 group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_save_range-Tuple{Any, Any, Any}" href="#MicroscopePSFs._io_save_range-Tuple{Any, Any, Any}"><code>MicroscopePSFs._io_save_range</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_save_range(group, name, range)</code></pre><p>Save a range to an HDF5 group by storing start, step, and length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._io_save_zernike_coeffs-Tuple{Any, Any}" href="#MicroscopePSFs._io_save_zernike_coeffs-Tuple{Any, Any}"><code>MicroscopePSFs._io_save_zernike_coeffs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_io_save_zernike_coeffs(file, coeffs; group_name=&quot;zernike_coefficients&quot;)</code></pre><p>Save ZernikeCoefficients to an HDF5 file in a specified group. Does nothing if coeffs is nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/common.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{AiryPSF}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{AiryPSF}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{AiryPSF})</code></pre><p>Load an AiryPSF from an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/basic_psfs.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{GaussianPSF}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{GaussianPSF}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{GaussianPSF})</code></pre><p>Load a GaussianPSF from an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/basic_psfs.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{PupilFunction}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{PupilFunction}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{PupilFunction})</code></pre><p>Load a PupilFunction from an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/pupil.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ScalarPSF}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ScalarPSF}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{ScalarPSF})</code></pre><p>Load a ScalarPSF from an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/scalar3d.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{SplinePSF}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{SplinePSF}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{SplinePSF})</code></pre><p>Load a SplinePSF from an HDF5 file, reconstructing it using the standard constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/spline.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPSF}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPSF}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{VectorPSF})</code></pre><p>Load a VectorPSF from an HDF5 file, reconstructing all components.</p><p><strong>Arguments</strong></p><ul><li><code>file</code>: Open HDF5 file handle</li><li><code>::Type{VectorPSF}</code>: Type to load</li></ul><p><strong>Returns</strong></p><ul><li>VectorPSF reconstructed from stored data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/vector3d.jl#L59-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPupilFunction}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{VectorPupilFunction}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{VectorPupilFunction})</code></pre><p>Load a VectorPupilFunction from an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/pupil.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ZernikeCoefficients}}" href="#MicroscopePSFs._load_psf_impl-Tuple{HDF5.File, Type{ZernikeCoefficients}}"><code>MicroscopePSFs._load_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_load_psf_impl(file::HDF5.File, ::Type{ZernikeCoefficients})</code></pre><p>Load ZernikeCoefficients from an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/zernike.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._sample_psf_2d-Tuple{AbstractPSF, AbstractRange, AbstractRange}" href="#MicroscopePSFs._sample_psf_2d-Tuple{AbstractPSF, AbstractRange, AbstractRange}"><code>MicroscopePSFs._sample_psf_2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_sample_psf_2d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange)</code></pre><p>Internal helper function to sample a 2D PSF on a regular grid. Returns an array with dimensions [y, x] containing raw PSF values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/spline_psf.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._sample_psf_3d-Tuple{AbstractPSF, AbstractRange, AbstractRange, AbstractRange}" href="#MicroscopePSFs._sample_psf_3d-Tuple{AbstractPSF, AbstractRange, AbstractRange, AbstractRange}"><code>MicroscopePSFs._sample_psf_3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_sample_psf_3d(psf::AbstractPSF, x_range::AbstractRange, y_range::AbstractRange, z_range::AbstractRange)</code></pre><p>Internal helper function to sample a 3D PSF on a regular grid. Returns an array with dimensions [y, x, z] containing raw PSF values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/spline_psf.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, AiryPSF}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, AiryPSF}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, psf::AiryPSF)</code></pre><p>Save an AiryPSF to an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/basic_psfs.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, GaussianPSF}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, GaussianPSF}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, psf::GaussianPSF)</code></pre><p>Save a GaussianPSF to an HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/basic_psfs.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, PupilFunction}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, PupilFunction}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, pupil::PupilFunction)</code></pre><p>Save a PupilFunction to an HDF5 file, including physical parameters and complex field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/pupil.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ScalarPSF}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ScalarPSF}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, psf::ScalarPSF)</code></pre><p>Save a ScalarPSF to an HDF5 file, including pupil function and any Zernike coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/scalar3d.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, SplinePSF}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, SplinePSF}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, psf::SplinePSF)</code></pre><p>Save a SplinePSF to an HDF5 file, including the original grid data used to create the spline interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/spline.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPSF}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPSF}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, psf::VectorPSF)</code></pre><p>Save a VectorPSF to an HDF5 file, including all optical parameters, dipole orientation, and vector pupil fields.</p><p><strong>Arguments</strong></p><ul><li><code>file</code>: Open HDF5 file handle</li><li><code>psf</code>: VectorPSF to save</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/vector3d.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPupilFunction}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, VectorPupilFunction}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, pupil::VectorPupilFunction)</code></pre><p>Save a VectorPupilFunction to an HDF5 file, including all physical parameters and both Ex and Ey field components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/pupil.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ZernikeCoefficients}" href="#MicroscopePSFs._save_psf_impl-Tuple{HDF5.File, ZernikeCoefficients}"><code>MicroscopePSFs._save_psf_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_save_psf_impl(file::HDF5.File, zc::ZernikeCoefficients)</code></pre><p>Save ZernikeCoefficients to an HDF5 file, storing magnitude and phase arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/io/zernike.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.api-Tuple{}" href="#MicroscopePSFs.api-Tuple{}"><code>MicroscopePSFs.api</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>MicroscopePSFs.jl API Overview</strong></p><p>This document provides a concise overview of the MicroscopePSFs.jl package API, designed for both human users and AI assistants.</p><p><strong>Key Concepts</strong></p><p>MicroscopePSFs.jl models <strong>point spread functions (PSFs)</strong> for microscopy applications, particularly single-molecule localization microscopy (SMLM). The package provides:</p><ul><li><strong>2D and 3D PSF models</strong> from simple Gaussian to complex vectorial diffraction</li><li><strong>Aberration modeling</strong> using Zernike polynomials</li><li><strong>Dipole orientation support</strong> for modeling fluorophore emission patterns</li><li><strong>Camera integration</strong> for simulating realistic microscope images</li><li><strong>Performance optimization</strong> through spline interpolation and multi-threading</li></ul><p><strong>Units Convention</strong>: All distances are in <strong>microns</strong> (μm). Wavelengths should be specified in microns (e.g., 0.532 for 532nm green light).</p><p><strong>Type Hierarchy</strong></p><pre><code class="nohighlight hljs">AbstractPSF{T}
├── Abstract2DPSF{T}
│   ├── GaussianPSF{T}         # Isotropic 2D Gaussian
│   └── AiryPSF{T}             # 2D Airy diffraction pattern
├── Abstract3DPSF{T}
│   ├── ScalarPSF{T}           # 3D scalar diffraction
│   └── VectorPSF{T}           # 3D vectorial with dipole
└── SplinePSF{T,IT}            # Spline interpolation (2D/3D)

PupilFunction{T}               # Complex pupil for scalar models
VectorPupilFunction{T}         # Vectorial pupil with polarization</code></pre><p><strong>Essential Types</strong></p><p><strong>2D PSF Models</strong></p><pre><code class="language-julia hljs"># Gaussian PSF - simplest model
struct GaussianPSF{T} &lt;: Abstract2DPSF{T}
    σ::T        # Standard deviation in microns
end

# Airy PSF - diffraction-limited 2D
struct AiryPSF{T} &lt;: Abstract2DPSF{T}
    nₐ::T       # Numerical aperture
    λ::T        # Wavelength in microns
end</code></pre><p><strong>3D PSF Models</strong></p><pre><code class="language-julia hljs"># Scalar diffraction PSF - fast 3D model
struct ScalarPSF{T} &lt;: Abstract3DPSF{T}
    nₐ::T                           # Numerical aperture
    λ::T                            # Wavelength in microns
    n::T                            # Refractive index of immersion medium
    pupil::PupilFunction{T}         # Complex pupil function
    # ... (internal fields)
end

# Vectorial PSF - accurate model with dipole orientation
struct VectorPSF{T} &lt;: Abstract3DPSF{T}
    nₐ::T                           # Numerical aperture
    λ::T                            # Wavelength in microns
    dipole::DipoleVector{T}         # Dipole orientation
    pupil::VectorPupilFunction{T}   # Vector pupil function
    z_stage::T                      # Stage position offset
    # ... (internal fields)
end</code></pre><p><strong>Support Types</strong></p><pre><code class="language-julia hljs"># Dipole orientation (normalized vector)
struct DipoleVector{T}
    px::T
    py::T
    pz::T
end

# Zernike aberration coefficients
struct ZernikeCoefficients{T}
    phase::Vector{T}      # Phase coefficients (radians)
    mag::Vector{T}        # Magnitude coefficients
end</code></pre><p><strong>Constructor Examples</strong></p><p><strong>Basic PSF Construction</strong></p><pre><code class="language-julia hljs">using MicroscopePSFs

# 2D Gaussian PSF with σ = 150nm
psf_gauss = GaussianPSF(0.15)

# 2D Airy PSF: NA=1.4, λ=532nm
psf_airy = AiryPSF(1.4, 0.532)

# 3D Scalar PSF: NA=1.4, λ=680nm, n=1.52 (oil immersion)
psf_scalar = ScalarPSF(1.4, 0.680, 1.52)

# Vector PSF with x-oriented dipole
dipole = DipoleVector(1.0, 0.0, 0.0)  # x-dipole
psf_vector = VectorPSF(1.4, 0.690, dipole; z_stage=0.0)</code></pre><p><strong>PSF with Aberrations</strong></p><pre><code class="language-julia hljs"># Create Zernike coefficients (max radial order 15)
zc = ZernikeCoefficients(15)

# Add specific aberrations (Noll indexing)
zc.phase[5] = 0.3    # Defocus
zc.phase[6] = 0.5    # Vertical astigmatism
zc.phase[7] = -0.2   # Oblique astigmatism

# Create aberrated PSF
psf_aberrated = ScalarPSF(1.4, 0.532, 1.52; zernike_coeffs=zc)</code></pre><p><strong>Spline Interpolation</strong></p><pre><code class="language-julia hljs"># Convert any PSF to spline for fast evaluation
x_range = -2.0:0.05:2.0  # microns
y_range = -2.0:0.05:2.0
z_range = -1.0:0.05:1.0

psf_spline = SplinePSF(psf_scalar, x_range, y_range, z_range)</code></pre><p><strong>Core Functions</strong></p><p><strong>PSF Evaluation</strong></p><pre><code class="language-julia hljs"># 2D PSF evaluation
intensity = psf(x, y)                    # Single point
intensity = psf(x_vec, y_vec)            # Vectorized

# 3D PSF evaluation  
intensity = psf(x, y, z)                 # Single point
intensity = psf(x_vec, y_vec, z_vec)     # Vectorized

# Complex amplitude (before squaring)
amp = amplitude(psf, x, y)              # 2D
amp = amplitude(psf, x, y, z)           # 3D</code></pre><p><strong>Image Generation</strong></p><pre><code class="language-julia hljs"># Setup camera
camera = IdealCamera(nx, ny, pixel_size)  # nx, ny pixels, size in microns

# Create emitter
emitter = Emitter2D(x, y, photons)       # 2D
emitter = Emitter3D(x, y, z, photons)    # 3D

# Generate image
image = integrate_pixels(psf, camera, emitter)

# With support region (faster computation)
image = integrate_pixels(psf, camera, emitter; support=0.5)

# Multiple emitters
emitters = [Emitter3D(x[i], y[i], z[i], photons[i]) for i in 1:n]
image = integrate_pixels(psf, camera, emitters)</code></pre><p><strong>Amplitude Integration</strong></p><pre><code class="language-julia hljs"># Integrate complex amplitude (preserves phase)
complex_image = integrate_pixels_amplitude(psf, camera, emitter)

# Useful for coherent imaging or interferometry</code></pre><p><strong>Common Workflows</strong></p><p><strong>1. Simple 2D Imaging</strong></p><pre><code class="language-julia hljs">using MicroscopePSFs, SMLMData

# Create PSF
psf = GaussianPSF(0.15)  # 150nm standard deviation

# Setup camera: 100x100 pixels, 100nm pixel size
camera = IdealCamera(100, 100, 0.1)

# Create emitter at (5μm, 5μm) with 1000 photons
emitter = Emitter2D(5.0, 5.0, 1000.0)

# Generate image
image = integrate_pixels(psf, camera, emitter)</code></pre><p><strong>2. 3D Localization with Astigmatism</strong></p><pre><code class="language-julia hljs"># Create PSF with astigmatism for 3D
zc = ZernikeCoefficients(5)
zc.phase[6] = 1.0  # Add astigmatism

psf = ScalarPSF(1.4, 0.680, 1.52; zernike_coeffs=zc)

# Emitter at different z positions
for z in [-0.5, 0.0, 0.5]  # microns
    emitter = Emitter3D(5.0, 5.0, z, 1000.0)
    image = integrate_pixels(psf, camera, emitter)
    # PSF shape changes with z due to astigmatism
end</code></pre><p><strong>3. Dipole Orientation Imaging</strong></p><pre><code class="language-julia hljs"># Create dipoles with different orientations
dipole_x = DipoleVector(1.0, 0.0, 0.0)
dipole_z = DipoleVector(0.0, 0.0, 1.0)

psf_x = VectorPSF(1.4, 0.690, dipole_x)
psf_z = VectorPSF(1.4, 0.690, dipole_z)

# Compare PSF patterns
emitter = DipoleEmitter3D(5.0, 5.0, 0.0, 1000.0, dipole_x)
image_x = integrate_pixels(psf_x, camera, emitter)

emitter_z = DipoleEmitter3D(5.0, 5.0, 0.0, 1000.0, dipole_z)
image_z = integrate_pixels(psf_z, camera, emitter)</code></pre><p><strong>4. Performance Optimization with Splines</strong></p><pre><code class="language-julia hljs"># Original PSF (slow for many evaluations)
psf = ScalarPSF(1.4, 0.680, 1.52)

# Convert to spline (fast evaluation)
psf_spline = SplinePSF(psf, -2:0.05:2, -2:0.05:2, -1:0.05:1)

# Use spline for faster multi-emitter simulations
emitters = [Emitter3D(rand()*10, rand()*10, randn()*0.5, 1000.0) 
            for _ in 1:100]
            
@time image_slow = integrate_pixels(psf, camera, emitters)
@time image_fast = integrate_pixels(psf_spline, camera, emitters)
# Spline version is typically 10-100x faster</code></pre><p><strong>Complete Examples</strong></p><p><strong>Example 1: Simulating STORM/PALM Data</strong></p><pre><code class="language-julia hljs">using MicroscopePSFs, SMLMData, Random

# Microscope parameters
NA = 1.4                    # Oil objective
wavelength = 0.647          # 647nm in microns
n_immersion = 1.515         # Oil refractive index

# Create PSF
psf = ScalarPSF(NA, wavelength, n_immersion)

# Camera setup: 256x256 pixels, 160nm pixel size
camera = IdealCamera(256, 256, 0.160)

# Generate random emitters
Random.seed!(42)
n_emitters = 50
emitters = [
    Emitter3D(
        rand() * 40.0,      # x in [0, 40] microns
        rand() * 40.0,      # y in [0, 40] microns  
        randn() * 0.3,      # z in [-0.9, 0.9] microns
        500 + rand() * 2000 # 500-2500 photons
    )
    for _ in 1:n_emitters
]

# Generate image
image = integrate_pixels(psf, camera, emitters; support=0.7)

# Add noise (Poisson + Gaussian read noise)
# Note: Use your preferred noise simulation method
# For example: noisy_image = image + sqrt.(image) .* randn(size(image))  # Simple Poisson approximation
noisy_image = image .+ 0.01 * randn(size(image))  # Gaussian read noise</code></pre><p><strong>Example 2: PSF Engineering for 3D Imaging</strong></p><pre><code class="language-julia hljs">using MicroscopePSFs

# Create tetrapod PSF using phase mask
zc = ZernikeCoefficients(15)

# Tetrapod phase mask coefficients (example values)
zc.phase[11] = 1.5   # Primary spherical
zc.phase[22] = 0.8   # Secondary spherical
zc.phase[5] = 0.3    # Defocus

# Create engineered PSF
psf_tetrapod = ScalarPSF(1.4, 0.680, 1.52; zernike_coeffs=zc)

# Evaluate PSF at different z positions
z_positions = -1.5:0.1:1.5
camera = IdealCamera(64, 64, 0.1)

for (i, z) in enumerate(z_positions)
    emitter = Emitter3D(3.2, 3.2, z, 1000.0)
    image = integrate_pixels(psf_tetrapod, camera, emitter)
    # PSF rotates with z, enabling 3D localization
end</code></pre><p><strong>Example 3: Analyzing PSF Properties</strong></p><pre><code class="language-julia hljs">using MicroscopePSFs

# Create PSF
psf = ScalarPSF(1.4, 0.532, 1.52)

# Compute FWHM at focus
x = -1.0:0.01:1.0
y = 0.0
z = 0.0
intensity = [psf(xi, y, z) for xi in x]
intensity_norm = intensity ./ maximum(intensity)

# Find FWHM
half_max_indices = findall(intensity_norm .&gt;= 0.5)
fwhm = x[half_max_indices[end]] - x[half_max_indices[1]]
println(&quot;Lateral FWHM: $(fwhm * 1000) nm&quot;)

# Axial profile
z_range = -2.0:0.01:2.0
axial_intensity = [psf(0.0, 0.0, zi) for zi in z_range]

# 3D OTF (via FFT of PSF)
# ... (implementation depends on specific analysis needs)</code></pre><p><strong>Important Notes</strong></p><ol><li><strong>Memory efficiency</strong>: Use <code>support</code> parameter in <code>integrate_pixels</code> to limit computation region</li><li><strong>Threading</strong>: Multi-emitter integration is automatically parallelized</li><li><strong>Automatic differentiation</strong>: Compatible with Enzyme.jl for gradient computations</li><li><strong>Normalization</strong>: PSFs are normalized so total integrated intensity equals photon count</li><li><strong>Coordinate system</strong>: (0,0) is at the corner of the first pixel, not the center</li></ol><p><strong>Common Pitfalls</strong></p><ul><li>Remember all distances are in <strong>microns</strong>, not nanometers</li><li>Zernike coefficients use <strong>Noll indexing</strong> (starting from 1)</li><li>For <code>VectorPSF</code>, the dipole vector is automatically normalized</li><li>Support regions should be chosen carefully - too small truncates the PSF, too large wastes computation</li><li>When using splines, ensure the interpolation range covers all possible emitter positions</li></ul><hr/><p><code>api()</code> returns this documentation as a plain <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/api.jl#L26-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.apply_aperture!" href="#MicroscopePSFs.apply_aperture!"><code>MicroscopePSFs.apply_aperture!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_aperture!(p::PupilFunction, radius::Real=1.0)</code></pre><p>Apply circular aperture to pupil function. Radius is relative to NA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.apply_defocus!-Tuple{PupilFunction, Real}" href="#MicroscopePSFs.apply_defocus!-Tuple{PupilFunction, Real}"><code>MicroscopePSFs.apply_defocus!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_defocus!(p::PupilFunction, z::Real)</code></pre><p>Apply defocus phase to pupil function for propagation distance z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.calculate_apodization-NTuple{4, Real}" href="#MicroscopePSFs.calculate_apodization-NTuple{4, Real}"><code>MicroscopePSFs.calculate_apodization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_apodization(kr2::Real, λ::Real, 
                    n_medium::Real, n_immersion::Real)</code></pre><p>Calculate apodization factor for energy conservation.</p><p><strong>Arguments</strong></p><ul><li><code>kr2</code>: Squared lateral spatial frequency</li><li><code>λ</code>: Wavelength in microns</li><li><code>n_medium</code>: Refractive index of the sample medium</li><li><code>n_immersion</code>: Refractive index of the immersion medium</li></ul><p><strong>Returns</strong></p><ul><li>Apodization factor for energy conservation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_tools.jl#L152-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.calculate_axial_phase" href="#MicroscopePSFs.calculate_axial_phase"><code>MicroscopePSFs.calculate_axial_phase</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_axial_phase(z::Real, z_stage::Real, kz_medium::Complex, 
                     kz_coverslip::Complex, kz_immersion::Complex,
                     coverslip_thickness::Real=0.17)</code></pre><p>Calculate total axial phase from defocus.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: Emitter position relative to the coverslip (depth above the coverslip in μm)</li><li><code>z_stage</code>: Distance the sample stage was moved away from the nominal focal plane at the coverslip (μm)</li><li><code>kz_medium</code>: z-component of wave vector in sample medium</li><li><code>kz_coverslip</code>: z-component of wave vector in coverslip</li><li><code>kz_immersion</code>: z-component of wave vector in immersion medium</li><li><code>coverslip_thickness</code>: Thickness of coverslip in mm (default: 0.17mm)</li></ul><p><strong>Returns</strong></p><ul><li>Defocus phase</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_tools.jl#L93-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.calculate_dipole_field_components-Tuple{Complex, Complex, Complex, DipoleVector, Complex, Complex}" href="#MicroscopePSFs.calculate_dipole_field_components-Tuple{Complex, Complex, Complex, DipoleVector, Complex, Complex}"><code>MicroscopePSFs.calculate_dipole_field_components</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_dipole_field_components(ϕ::Complex, sinθ::Complex, cosθ::Complex,
                                dipole::DipoleVector, Tp::Complex, Ts::Complex)</code></pre><p>Calculate vectorial field components for a dipole orientation.</p><p><strong>Arguments</strong></p><ul><li><code>ϕ</code>: Azimuthal angle in pupil plane</li><li><code>sinθ</code>: Sine of polar angle</li><li><code>cosθ</code>: Cosine of polar angle</li><li><code>dipole</code>: Dipole orientation vector</li><li><code>Tp</code>: p-polarization transmission coefficient</li><li><code>Ts</code>: s-polarization transmission coefficient</li></ul><p><strong>Returns</strong></p><ul><li>Tuple (Ex, Ey) of complex field components</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_tools.jl#L120-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.calculate_interface_fresnel-NTuple{4, Real}" href="#MicroscopePSFs.calculate_interface_fresnel-NTuple{4, Real}"><code>MicroscopePSFs.calculate_interface_fresnel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_interface_fresnel(kr2::Real, λ::Real, 
                          n1::Real, n2::Real)</code></pre><p>Calculate Fresnel transmission coefficients for a single interface.</p><p><strong>Arguments</strong></p><ul><li><code>kr2</code>: Squared lateral spatial frequency</li><li><code>λ</code>: Wavelength in microns</li><li><code>n1</code>: Refractive index of first medium</li><li><code>n2</code>: Refractive index of second medium</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of (Tp, Ts): p and s polarization transmission coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_tools.jl#L37-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.calculate_wave_vectors-NTuple{5, Real}" href="#MicroscopePSFs.calculate_wave_vectors-NTuple{5, Real}"><code>MicroscopePSFs.calculate_wave_vectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_wave_vectors(kr2::Real, λ::Real, 
                     n_medium::Real, n_coverslip::Real, n_immersion::Real)</code></pre><p>Calculate z-components of wave vectors in all three media.</p><p><strong>Arguments</strong></p><ul><li><code>kr2</code>: Squared lateral spatial frequency</li><li><code>λ</code>: Wavelength in microns</li><li><code>n_medium</code>: Refractive index of the sample medium</li><li><code>n_coverslip</code>: Refractive index of the coverslip</li><li><code>n_immersion</code>: Refractive index of the immersion medium</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of (kz<em>medium, kz</em>coverslip, kz_immersion): z-components of wave vectors in each medium</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_tools.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.fill_vector_pupils!" href="#MicroscopePSFs.fill_vector_pupils!"><code>MicroscopePSFs.fill_vector_pupils!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill_vector_pupils!(vpupil::VectorPupilFunction, dipole::DipoleVector,
                  base_pupil::Union{Nothing, PupilFunction}=nothing;
                  normalize::Bool=true)</code></pre><p>Fill vector pupil function with field components including dipole orientation, base aberrations, and proper apodization.</p><p>This pre-calculates all position-independent factors of the pupil function.</p><p><strong>Arguments</strong></p><ul><li><code>vpupil</code>: Vector pupil function to fill</li><li><code>dipole</code>: Dipole orientation vector</li><li><code>base_pupil</code>: Optional base aberration pupil function</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>normalize</code>: Whether to normalize the pupil function (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Filled vector pupil function (normalized if <code>normalize=true</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_pupil.jl#L100-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.get_pixel_indices-Tuple{AbstractVector, AbstractVector, AbstractEmitter, Union{Real, NTuple{4, Real}}}" href="#MicroscopePSFs.get_pixel_indices-Tuple{AbstractVector, AbstractVector, AbstractEmitter, Union{Real, NTuple{4, Real}}}"><code>MicroscopePSFs.get_pixel_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_pixel_indices(
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitter::AbstractEmitter,
    support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}}
) -&gt; Tuple{UnitRange{Int},UnitRange{Int}}</code></pre><p>Get the pixel indices that overlap with the support region.</p><p><strong>Arguments</strong></p><ul><li><code>pixel_edges_x</code>, <code>pixel_edges_y</code>: Arrays defining pixel edge coordinates</li><li><code>emitter</code>: Emitter with position information</li><li><code>support</code>: Region of interest, either a radius or explicit bounds (x<em>min, x</em>max, y<em>min, y</em>max)</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of (i<em>range, j</em>range) with pixel indices that cover the support region If the support region doesn&#39;t overlap with the camera, returns empty ranges</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_core.jl#L36-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T&lt;:Real" href="#MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T&lt;:Real"><code>MicroscopePSFs.integrate_pixels!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels!(
    result::AbstractMatrix{T},
    psf::AbstractPSF,
    camera::AbstractCamera,
    emitter::AbstractEmitter;
    sampling::Integer=2,
    threaded::Bool=true
) where T &lt;: Real</code></pre><p>Integrate PSF intensity over camera pixels using camera object, storing the result in a pre-allocated matrix.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Pre-allocated array where results will be stored</li><li><code>psf</code>: Point spread function to integrate</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitter</code>: Emitter with position information</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>The <code>result</code> array, now filled with integrated intensities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L69-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T&lt;:Real" href="#MicroscopePSFs.integrate_pixels!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T&lt;:Real"><code>MicroscopePSFs.integrate_pixels!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels!(
    result::AbstractMatrix{T},
    psf::AbstractPSF,
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitter::AbstractEmitter;
    sampling::Integer=2,
    threaded::Bool=true
) where T &lt;: Real</code></pre><p>Integrate PSF intensity over camera pixels, storing the result in a pre-allocated matrix. Automatically uses z-coordinate if both PSF and emitter support it.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Pre-allocated array where results will be stored</li><li><code>psf</code>: Point spread function to integrate</li><li><code>pixel_edges_x</code>, <code>pixel_edges_y</code>: Arrays defining pixel edge coordinates</li><li><code>emitter</code>: Emitter with position information</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true) Set to false when using with automatic differentiation frameworks</li></ul><p><strong>Returns</strong></p><ul><li>The <code>result</code> array, now filled with integrated intensities scaled by emitter.photons</li></ul><p><strong>Notes</strong></p><ul><li>Array is indexed as [y,x] with [1,1] at top-left pixel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L3-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T&lt;:Real" href="#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractCamera, AbstractEmitter}} where T&lt;:Real"><code>MicroscopePSFs.integrate_pixels_amplitude!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude!(
    result::AbstractMatrix{Complex{T}},
    psf::AbstractPSF,
    camera::AbstractCamera,
    emitter::AbstractEmitter;
    sampling::Integer=2,
    threaded::Bool=true
) where T &lt;: Real</code></pre><p>Integrate PSF complex amplitude over camera pixels using camera object, storing the result in a pre-allocated matrix.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Pre-allocated complex array where results will be stored</li><li><code>psf</code>: Point spread function to integrate</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitter</code>: Emitter with position information</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>The <code>result</code> array, now filled with integrated complex amplitudes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L166-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T&lt;:Real" href="#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 2}, AbstractPSF, AbstractVector, AbstractVector, AbstractEmitter}} where T&lt;:Real"><code>MicroscopePSFs.integrate_pixels_amplitude!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude!(
    result::AbstractMatrix{Complex{T}},
    psf::AbstractPSF,
    pixel_edges_x::AbstractVector,
    pixel_edges_y::AbstractVector,
    emitter::AbstractEmitter;
    sampling::Integer=2,
    threaded::Bool=true
) where T &lt;: Real</code></pre><p>Integrate PSF complex amplitude over camera pixels, storing the result in a pre-allocated matrix. Automatically uses z-coordinate if both PSF and emitter support it.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Pre-allocated complex array where results will be stored</li><li><code>psf</code>: Point spread function to integrate</li><li><code>pixel_edges_x</code>, <code>pixel_edges_y</code>: Arrays defining pixel edge coordinates</li><li><code>emitter</code>: Emitter with position information</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>The <code>result</code> array, now filled with integrated complex amplitudes</li></ul><p><strong>Notes</strong></p><ul><li>Array is indexed as [y,x] with [1,1] at top-left pixel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_single.jl#L113-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 3}, VectorPSF, AbstractCamera, AbstractEmitter}} where T&lt;:Real" href="#MicroscopePSFs.integrate_pixels_amplitude!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 3}, VectorPSF, AbstractCamera, AbstractEmitter}} where T&lt;:Real"><code>MicroscopePSFs.integrate_pixels_amplitude!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_pixels_amplitude!(
    result::AbstractArray{Complex{T},3},
    psf::VectorPSF,
    camera::AbstractCamera,
    emitter::AbstractEmitter;
    sampling::Integer=2,
    threaded::Bool=true
) where T &lt;: Real</code></pre><p>Special version of amplitude integration for VectorPSF that preserves polarization components. Uses the flexible core integration function that handles vector returns.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Pre-allocated 3D complex array where results will be stored, dimensions [y, x, pol]</li><li><code>psf</code>: VectorPSF instance</li><li><code>camera</code>: Camera geometry defining pixel edges</li><li><code>emitter</code>: Emitter with position information</li><li><code>sampling</code>: Subpixel sampling density (default: 2)</li><li><code>threaded</code>: Whether to use multi-threading for integration (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>The <code>result</code> array, filled with integrated complex amplitudes for each polarization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/vector3d.jl#L375-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.kmax-Tuple{PupilFunction}" href="#MicroscopePSFs.kmax-Tuple{PupilFunction}"><code>MicroscopePSFs.kmax</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kmax(p::PupilFunction)</code></pre><p>Get maximum spatial frequency in μm⁻¹</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.kmax-Tuple{VectorPupilFunction}" href="#MicroscopePSFs.kmax-Tuple{VectorPupilFunction}"><code>MicroscopePSFs.kmax</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get maximum spatial frequency in μm⁻¹</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_pupil.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.kpixelsize-Tuple{PupilFunction}" href="#MicroscopePSFs.kpixelsize-Tuple{PupilFunction}"><code>MicroscopePSFs.kpixelsize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kpixelsize(p::PupilFunction)</code></pre><p>Get pupil plane sampling in μm⁻¹</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L42-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.kpixelsize-Tuple{VectorPupilFunction}" href="#MicroscopePSFs.kpixelsize-Tuple{VectorPupilFunction}"><code>MicroscopePSFs.kpixelsize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get pupil plane sampling in μm⁻¹</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_pupil.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.k₀-Tuple{PupilFunction}" href="#MicroscopePSFs.k₀-Tuple{PupilFunction}"><code>MicroscopePSFs.k₀</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">k₀(p::PupilFunction)</code></pre><p>Get central wavevector magnitude in μm⁻¹</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.k₀-Tuple{VectorPupilFunction}" href="#MicroscopePSFs.k₀-Tuple{VectorPupilFunction}"><code>MicroscopePSFs.k₀</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get central wavevector magnitude in μm⁻¹</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_pupil.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.normalize!-Tuple{PupilFunction}" href="#MicroscopePSFs.normalize!-Tuple{PupilFunction}"><code>MicroscopePSFs.normalize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize!(p::PupilFunction)</code></pre><p>Normalize pupil function to unit energy using Parseval&#39;s theorem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/pupil.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.normalize!-Tuple{VectorPupilFunction}" href="#MicroscopePSFs.normalize!-Tuple{VectorPupilFunction}"><code>MicroscopePSFs.normalize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize!(p::VectorPupilFunction)</code></pre><p>Normalize the electric field components of the vector pupil function. Ensures total energy across both components equals 1.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Vector pupil function to normalize</li></ul><p><strong>Returns</strong></p><ul><li>Normalized vector pupil function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/pupils/vector_pupil.jl#L78-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.supports_3d-Tuple{Type{&lt;:AbstractPSF}}" href="#MicroscopePSFs.supports_3d-Tuple{Type{&lt;:AbstractPSF}}"><code>MicroscopePSFs.supports_3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_3d(psf_type::Type{&lt;:AbstractPSF}) -&gt; Bool</code></pre><p>Check if a PSF type supports 3D evaluation via psf(x, y, z).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/integration/integration_core.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.update_pupils!-Tuple{VectorPSF}" href="#MicroscopePSFs.update_pupils!-Tuple{VectorPSF}"><code>MicroscopePSFs.update_pupils!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_pupils!(psf::VectorPSF) -&gt; VectorPSF</code></pre><p>Update the vector pupil functions based on stored Zernike coefficients and/or base pupil. This is useful after modifying aberrations to regenerate the pupil fields.</p><p><strong>Arguments</strong></p><ul><li><code>psf</code>: VectorPSF to update</li></ul><p><strong>Returns</strong></p><ul><li>Updated VectorPSF</li></ul><p><strong>Notes</strong></p><ul><li>Requires either stored Zernike coefficients or a base pupil</li><li>For rotating dipoles (multiple pupils), updates each pupil with the appropriate dipole orientation</li><li>Returns the updated PSF for method chaining</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/psfs/vector3d.jl#L314-L330">source</a></section></article><h3 id="Zernike-Module-Internal-API"><a class="docs-heading-anchor" href="#Zernike-Module-Internal-API">Zernike Module Internal API</a><a id="Zernike-Module-Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Zernike-Module-Internal-API" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroscopePSFs.Zernike.get_nl-Tuple{Integer}" href="#MicroscopePSFs.Zernike.get_nl-Tuple{Integer}"><code>MicroscopePSFs.Zernike.get_nl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nl(j::Integer) -&gt; Tuple{Int,Int}</code></pre><p>Get (n,l) indices from Noll index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/MicroscopePSFs.jl/blob/5a0829bfe0359a33861b2f1cb77abcf305fd8099/src/zernike/indexing.jl#L143-L147">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 5 June 2025 19:48">Thursday 5 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
